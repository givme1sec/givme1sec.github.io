<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Start from Hexo. Chapter 2</title>
    <url>/2020/12/03/Hexo-blog-embellishing/</url>
    <content><![CDATA[<p>记录建立<em>Hexo</em>博客后，逐步优化的过程。<br>目前包括<em>Hexo Menu设置</em>、<em>Hexo语言设置</em>、<em>搜索栏启用</em>、<em>Hexo图片引用</em>、<em>分类与标签</em>、<em>个人资料格式</em>。</p>
<div align="center"><img src="/.io//a.jpg"></div>

<span id="more"></span>

<h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><h3 id="启用Menu"><a href="#启用Menu" class="headerlink" title="启用Menu"></a>启用Menu</h3><p>默认的<em>Hexo</em>页面中<em>Menu</em>是没有被启用的。</p>
<div align="center"><img src="/.io//menu-1.png" width="60%"></div>

<p>启动<em>Menu</em>需要到主题文件夹<code>themes/next</code>中修改 <em>_config.yml</em>文件，启用<em>home</em>、<em>tags</em>、<em>categories</em>、<em>archives</em>。</p>
<div align="center"><img src="/.io//menu-2.png"></div>

<p>再重新部署启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean</span><br><span class="line">&gt; hexo g</span><br><span class="line">&gt; hexo d</span><br></pre></td></tr></table></figure>
<p>启用<em>Menu</em>后的页面如下：</p>
<div align="center"><img src="/.io//menu-3.png" width="80%"></div>

<p>但是这时候<em>Menu</em>里的<em>Tags</em>、<em>Categories</em>这些页面是不能打开的，需要在根目录下新建页面文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hexo new page tags</span><br><span class="line">&gt; hexo new page categories</span><br><span class="line">&gt; hexo new page archives</span><br></pre></td></tr></table></figure>

<p>根目录下的<code>source</code>文件夹中就会生成这几个页面对应的文件：</p>
<div align="center"><img src="/.io//page-1.png"></div>

<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>咳， <del>英语不好就不勉强自己看英文界面了</del>，而且由于语言是英文，每次打开页面<em>Edge</em>都弹出询问翻译，很是恼人，所以干脆一劳永逸把语言改成中文。</p>
<p><strong>主题目录</strong>下有一个<code>language</code>文件夹，里面可以查看主题支持的语言，<em>NexT</em>支持的语言就包括中文：</p>
<div align="center"><img src="/.io//lang-1.png"></div>

<p>文件<code>zh-CN.yml</code>是简体中文，但要把文件名改成<code>zh-Hans.yml</code>。</p>
<p>再打开<strong>博客根目录</strong>下的 <em>_config.yml</em>文件，将<em>language</em>设置成中文：</p>
<div align="center"><img src="/.io//lang-2.png"></div>

<p>重新部署启动：</p>
<div align="center"><img src="/.io//lang-3.png" width="80%"></div>

<h3 id="添加搜索栏"><a href="#添加搜索栏" class="headerlink" title="添加搜索栏"></a>添加搜索栏</h3><p>还可以给<em>Menu</em>加一个搜索的栏目，方便以后查找文章。在博客<strong>根目录</strong>下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; cnpm install hexo-generator-search --save</span><br><span class="line">&gt; cnpm install hexo-generator--searchdb --save</span><br></pre></td></tr></table></figure>

<p>安装之后会在<code>public</code>文件夹下生成一个<code>search.xml</code>文件。（如果没有就执行一遍<code>hexo clean</code>和<code>hexo g</code>)</p>
<p>然后修改<strong>根目录</strong>下的 <em>_config.yml</em>文件，在后面添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>并修改<strong>主题目录</strong>下的 <em>_config.yml</em>文件，将<code>local_search</code>启动：</p>
<div align="center"><img src="/.io//search-1.png"></div>

<p>重新部署启动：</p>
<div align="center"><img src="/.io//search-2.png" width="80%"></div>

<div align="center"><img src="/.io//search-3.png" width="80%"></div>

<h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p>写文章，最重要的是咩？</p>
<p>图 文 并 茂！</p>
<p><em>Hexo</em>中引用图片需要先安装插件：</p>
<p><code>&gt; cnpm install hexo-asset-image --save</code></p>
<p>但是这个插件的内容需要修改,不然可能出<em>bug</em>，打开<code>/node_modules/hexo-asset-image/index.js</code>，内容替换为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">    <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> appendLink = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="comment">// if not with index.html endpos = link.lastIndexOf(&#x27;.&#x27;) + 1 support hexo-abbrlink</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\/index\.html$/</span>.test(link)) &#123;</span><br><span class="line">      <span class="comment">// when permalink is end with index.html, for example 2019/02/20/xxtitle/index.html</span></span><br><span class="line">      <span class="comment">// image in xxtitle/ will go to xxtitle/index/</span></span><br><span class="line">      appendLink = <span class="string">&#x27;index/&#x27;</span>;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    link = link.substring(beginPos, endPos) + <span class="string">&#x27;/&#x27;</span> + appendLink;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">          <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">          <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">          <span class="keyword">if</span>(!(<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src)</span><br><span class="line">            || <span class="regexp">/^\s+\//</span>.test(src)</span><br><span class="line">            || <span class="regexp">/^\s*\/uploads|images\//</span>.test(src))) &#123;</span><br><span class="line">            <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">            <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">            <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">              <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">            srcArray.shift();</span><br><span class="line">            src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">          <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开<strong>根目录</strong>下的 <em>_config.yml</em>文件，找到<code>post_asset_folder</code>设置为<em>true</em>。</p>
<div align="center"><img src="/.io//image-1.png"></div>

<p>这一项表示在新建文章的时候，会自动生成一个同名文件夹，用来存放图片。</p>
<div align="center"><img src="/.io//image-2.png"></div>

<p>打开<strong>主题目录</strong>下的 <em>_config.yml</em>文件，找到<code>url</code>，改成部署的<code>Github</code>仓库地址。</p>
<div align="center"><img src="/.io//image-4.png"></div>


<p>在博客中引用图片时也有两种方式，注意这里直接写图片名就可以了，不需要加路径。</p>
<div align="center"><img src="/.io//image-3.png"></div>

<p>在本地编写<em>Markdown</em>文本的时候，预览中图片是加载不出来的，但是部署到服务器上再打开页面，图片可以正常显示：</p>
<div align="center"><img src="/.io//image-5.png"></div>

<h2 id="Tags-amp-Categories"><a href="#Tags-amp-Categories" class="headerlink" title="Tags &amp; Categories"></a>Tags &amp; Categories</h2><p><em>NexT</em>主题的<em>Tags</em>和<em>Categories</em>是可以从文章中自动生成的，首先<em>Tags</em>和<em>Categories</em>是两个页面，在之前已经在<strong>根目录</strong>生成了对应的<code>tags</code>和<code>categories</code>文件夹，里面各有一个<code>index.md</code>文件。<br>修改其中内容：</p>
<p><code>categories</code>下的<code>type</code>要设置成<code>categories</code>，并删去<code>title</code>，<code>tags</code>下的同样。</p>
<div align="center"><img src="/.io//categories-1.png"></div>
<div align="center"><img src="/.io//tags-1.png"></div>

<p>之后，在写新的文章时，只需要在开头设置好<code>categories</code>和<code>tag</code>即可。</p>
<div align="center"><img src="/.io//tags-2.png" , width="70%"></div>

<p><em>Hexo</em>页面会自动生成<strong>标签云</strong>和<strong>分类</strong>。</p>
<div align="center"><img src="/.io//tags-3.png" , width="90%"></div>
<div align="center"><img src="/.io//tags-4.png" , width="80%"></div>


<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>在<strong>主题根目录</strong>下的 <em>_config.yml</em>文件中可以修改头像和个人链接。</p>
<h3 id="Avatar"><a href="#Avatar" class="headerlink" title="Avatar"></a>Avatar</h3><p>将正方形的<em>GIF</em>图片放入<strong>主题根目录</strong>的<code>source/images/</code>文件夹下，并指定<em>URL</em>。</p>
<div align="center"><img src="/.io//avatar-1.png" , width="80%"></div>

<h3 id="个人链接"><a href="#个人链接" class="headerlink" title="个人链接"></a>个人链接</h3><div align="center"><img src="/.io//social-1.png" , width="80%"></div>
]]></content>
      <categories>
        <category>杂技</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记3-性能监控与调优</title>
    <url>/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><em>“ 该舍的舍不得，只顾着跟往事瞎扯。</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<em>—李宗盛 ”</em></p>
<div align="center"><img src="/.io//1.JPG"></div>

<span id="more"></span>


<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>严格来说：只有对象不会再被用到了，但是GC又不能回收他们的情况，才叫内存泄露。实际中，如果一个生命周期很短的对象被另一个生命周期很长的对象引用，导致生命周期短的对象一直不能被回收，从而造成OOM，也可以成为宽泛意义上的内存泄漏。</p>
<p><strong>泄露的分类：</strong><br>① 经常发生：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存。<br>② 偶然发生：在某些特定的情况下才会发生。<br>③ 一次性：发生内存泄露的方法只会执行一次。<br>④ 隐式泄露：一直站着内存不释放，直到执行结束（如果执行时间特别长，而且有很多这种隐式泄露的对象，最后也会OOM）。</p>
<p><strong>内存泄露的8种情况：</strong><br>① 静态集合类：含有静态集合（如<code>static List list = new ArrayList();</code>）的类，生命周期与JVM程序一致，会发生由于生命周期过长而导致的内存泄露。<br>② 单例模式：同样由于单例的静态特性，它的生命周期与JVM生命周期一样长。<br>③ 内部类持有外部类：内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。如果内部类对象被长期引用，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象。这个外部类对象不会被垃圾回收，造成内存泄露。<br>④ 数据库连接、网络连接、IO连接等连接未释放：这类连接不使用时，需要用<code>close()</code>方法手动关闭后，垃圾回收器才能回收其对象。<br>⑤ 变量不合理的作用域：如一个对象定义的作用范围大于其使用范围、没有把对象及时设置为null。<br>⑥ 改变哈希值：当一个对象被存储进HashSet集合中后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则，对象修改后的哈希值与最初存储进HashSet集合中的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前的对象，造成内存泄露。<br>⑦ 缓存泄露：缓存中加载大量对象但又不被及时清除。可以使用WeakHashMap代表缓存，除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。<br>⑧ 监听器和回调：如果在客户端中实现的API中注册回调，却没有显式取消，那么就会积累造成泄漏。确保回调立即被当做垃圾回收的最佳方法是保存它的弱引用。</p>
<h2 id="JVM监控及诊断工具"><a href="#JVM监控及诊断工具" class="headerlink" title="JVM监控及诊断工具"></a>JVM监控及诊断工具</h2><h3 id="JVM命令行"><a href="#JVM命令行" class="headerlink" title="JVM命令行"></a>JVM命令行</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>查看正在运行的Java进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jps -h</span><br><span class="line">illegal argument: -h</span><br><span class="line">usage: jps [-help]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;hostid&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;hostid&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>options参数：</strong><br>$\bullet$ <code>-q</code>：仅显示进程ID。<br>$\bullet$ <code>-l</code>：显示应用程序主类的全类名。<br>$\bullet$ <code>-m</code>：显示JVM进程启动时传递给主类main()的参数。<br>$\bullet$ <code>-v</code>：列出JVM进程启动时的JVM参数。<br>以上参数可组合使用。</p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>查看JVM统计信息<br>格式为：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jstat</span><br><span class="line">invalid argument count</span><br><span class="line">Usage: jstat -help|-options</span><br><span class="line">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">  &lt;option&gt;      An option reported by the -options option</span><br><span class="line">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class="line">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class="line">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class="line">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class="line">                the name of the host running the target Java virtual machine;</span><br><span class="line">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class="line">                target host. See the jvmstat documentation for a more complete</span><br><span class="line">                description of the Virtual Machine Identifier.</span><br><span class="line">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class="line">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class="line">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class="line">                Where &lt;n&gt; is an integer and the suffix specifies the units as</span><br><span class="line">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class="line">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class="line">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h5><p><strong>类装载参数：</strong><br>$\bullet$ <code>-class</code>：显示ClassLoader相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间。</p>
<p><strong>垃圾回收相关参数：</strong><br>$\bullet$ <code>-gc</code>：显示与GC相关的信息，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。<br>$\bullet$ <code>-gccapacity</code>：显示内容与<code>-gc</code>基本相同，偏重显示Java堆各个区域使用到的最大、最小空间。<br>$\bullet$ <code>-gcutil</code>：显示内容与<code>-gc</code>基本相同，偏重显示已使用空间占总空间的百分比。<br>$\bullet$ <code>gccause</code>：显示内容与<code>-gcutil</code>基本相同，会输出导致最后一次或当前正在发生的GC的原因。<br>$\bullet$ <code>-gcnew</code>：显示新生代GC状况。<br>$\bullet$ <code>-gcnewcapacity</code>：与<code>-gcnew</code>基本相同，偏重显示使用到的最大、最小空间。<br>$\bullet$ <code>-gcold</code>：显示老年代GC情况<br>$\bullet$ <code>gcoldcapacity</code>：显示内容与<code>-gcold</code>基本相同，偏重显示使用到的最大、最小空间。<br>$\bullet$ <code>-gcpermcapacity</code>：显示永久代使用到的最大、最小空间。</p>
<p><strong>JIT相关参数：</strong><br>$\bullet$ <code>-compiler</code>：显示JIT编译器编译过的方法、耗时等信息。<br>$\bullet$ <code>-printcompilation</code>：输出已经被JIT编译的方法。</p>
<h5 id="interval参数"><a href="#interval参数" class="headerlink" title="interval参数"></a>interval参数</h5><p>指定输出统计数据的周期，单位为毫秒。</p>
<h5 id="count参数"><a href="#count参数" class="headerlink" title="count参数"></a>count参数</h5><p>指定查询的总次数。</p>
<h5 id="t参数"><a href="#t参数" class="headerlink" title="-t参数"></a>-t参数</h5><p>在输出信息前加Timestamp，显示程序运行时间。</p>
<h5 id="h参数"><a href="#h参数" class="headerlink" title="-h参数"></a>-h参数</h5><p>在周期性数据输出时，指定多少行数据后输出一个表头信息。</p>
<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>查看虚拟机配置参数信息，也可以用于调整虚拟机配置参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jinfo</span><br><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>① 导出内存映像文件 ② 内存使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jmap</span><br><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>-dump、-heap、-histo</code>最为常用。<br><strong>例：导出内存映像文件</strong><br>手动：<br>导出所有对象 <code>jmap -dump:format=b,file=test.hprof 16696</code><br>只导出存活对象 <code>jmap -dump:live,format=b,file=test.hprof 16696</code></p>
<p>自动：<br>在配置中添加<code>-XX:+HeapDumpOnOutOfMemoryError</code>：在程序发生OOM时，导出应用程序的当前堆快照。<br>并配置路径<code>-XX:HeapDumpPath=e:\test.hprof</code>：指定快照保存位置。</p>
<h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>JDK自带堆分析工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jhat -h</span><br><span class="line">Usage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">        -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For</span><br><span class="line">                          example, -J-mx512m to use a maximum heap size of 512MB</span><br><span class="line">        -stack false:     Turn off tracking object allocation call stack.</span><br><span class="line">        -refs false:      Turn off tracking of references to objects</span><br><span class="line">        -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000</span><br><span class="line">        -exclude &lt;file&gt;:  Specify a file that lists data members that should</span><br><span class="line">                          be excluded from the reachableFrom query.</span><br><span class="line">        -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in</span><br><span class="line">                          both heap dumps with the same ID and same class will</span><br><span class="line">                          be marked as not being &quot;new&quot;.</span><br><span class="line">        -debug &lt;int&gt;:     Set debug level.</span><br><span class="line">                            0:  No debug output</span><br><span class="line">                            1:  Debug hprof file parsing</span><br><span class="line">                            2:  Debug hprof file parsing, no server</span><br><span class="line">        -version          Report version number</span><br><span class="line">        -h|-help          Print this help and exit</span><br><span class="line">        &lt;file&gt;            The file to read</span><br><span class="line"></span><br><span class="line">For a dump file that contains multiple heap dumps,</span><br><span class="line">you may specify which dump in the file</span><br><span class="line">by appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</span><br><span class="line"></span><br><span class="line">All boolean options default to &quot;true&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>例：jhat与jmap命令搭配使用</strong><br>用于分析jmap生成的heap dump文件。使用jhat命令，就启动了一个http服务，默认端口为7000[<a href="http://localhost:7000/]%EF%BC%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/]，在浏览器里执行分析。</a><br>注意：<code>jhat</code>指令在JDK 9、JDK 10中已经被删除。</p>
<h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>打印JVM中线程快照。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;jstack -h</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在thread dump中，留意下面几种状态：<br>$\bullet$ 死锁，Deadlock（重点关注）<br><br>$\bullet$ 等待资源，Waiting on condition（重点关注）<br><br>$\bullet$ 等待获取监视器，Waiting on monitor entry（重点关注）<br><br>$\bullet$ 阻塞，Blocked（重点关注）<br><br>$\bullet$ 执行中，Runnable<br><br>$\bullet$ 暂停，Suspended</p>
<h4 id="jcmd"><a href="#jcmd" class="headerlink" title="jcmd"></a>jcmd</h4><p><a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">官方文档</a><br>在JDK 1.7之后，新增了<code>jcmd</code>，可以实现前面除了<code>jstat</code>之外的所有命令的功能，<code>jcmd</code>拥有<code>jmap</code>的大部分指令，官方也推荐使用<code>jcmd</code>取代使用<code>jmap</code>。</p>
<h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>一些指令，<code>jmap、jstatd</code>可以实现对远程主机的监控。命令<code>jstatd</code>是一个RMI服务端程序，它的作用相当于代理服务器建立本地计算机与远程监控工具的通信。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>$\bullet$ <code>java -XX:+PrintFlagsInitial</code>：查看所有JVM参数启动的初始值。<br>$\bullet$ <code>java -XX:+PrintFlagsFinal</code>：查看所有JVM参数最终值。<br>$\bullet$ <code>java -XX:PrintCommandLineFlags</code>：查看已经被用户或者JVM设置过的详细的XX参数的名称和值。</p>
<h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">官方文档</a></p>
<h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p>IDEA中<code>File-&gt;Settings-&gt;Plugins</code>中可以安装VisualVM的插件，在运行程序时直接启动VisualVM。</p>
<div align="center"><img src="/.io//vvm1.png"></div>
<div align="center"><img src="/.io//vvm2.png"></div>

<h3 id="JMC（Java-Mission-Control）"><a href="#JMC（Java-Mission-Control）" class="headerlink" title="JMC（Java Mission Control）"></a>JMC（Java Mission Control）</h3><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>MAT（Memory Analyse Tool）是基于Eclipse开发的，可以单独使用，也可以作为插件的形式嵌入在Eclipse中使用。MAT同样可以用于分析heap dump（.hprof）文件。优点是能快速生成<strong>内存泄露报表</strong>。<br><a href="www.eclipse.org/mat/downloads.php">下载地址</a></p>
<h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><p>可以在运行Java时测试运行时占用内存情况。Eclipse中有MAT，IDEA中有JProfiler。<br><a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></p>
<h3 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h3><p>Arthas是Alibaba开源的Java诊断工具，提供命令行方式的交互。<br><a href="https://arthas.aliyun.com/zh-cn/">官网</a><br>Arthas只是一个java程序，可以使用<code>java -jar arthas-boot.jar</code>执行。</p>
<h3 id="Flame-Graph（火焰图）"><a href="#Flame-Graph（火焰图）" class="headerlink" title="Flame Graph（火焰图）"></a>Flame Graph（火焰图）</h3><p>火焰图可以直观的显示CPU在程序整个生命周期过程中时间分配的工具。<br><a href="http://www.brendangregg.com/flamegraphs.html">Brendan Gregg的博客</a>对火焰图有很好的讲解。</p>
<h2 id="JVM运行时参数"><a href="#JVM运行时参数" class="headerlink" title="JVM运行时参数"></a>JVM运行时参数</h2><h3 id="JVM参数选项类型"><a href="#JVM参数选项类型" class="headerlink" title="JVM参数选项类型"></a>JVM参数选项类型</h3><h4 id="标准参数选项"><a href="#标准参数选项" class="headerlink" title="标准参数选项"></a>标准参数选项</h4><p>以<code>-</code>开头，比较稳定 ，后续版本基本不会变化。使用<code>java -help</code>可以看到这些参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;java -h</span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 &quot;server&quot; VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="X参数选项"><a href="#X参数选项" class="headerlink" title="-X参数选项"></a>-X参数选项</h4><p>非标转化参数选项，功能比较稳定，以<code>-X</code>开头，使用<code>java -X</code>可以看到所有参数选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:\NBI\JavaTest\JavaDemo&gt;java -X</span><br><span class="line">    -Xint             仅解释模式执行（同时禁用JIT）</span><br><span class="line">    -Xcomp            仅用编译器（同时禁用解释器）</span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="XX参数选项"><a href="#XX参数选项" class="headerlink" title="-XX参数选项"></a>-XX参数选项</h4><p>非标准化参数类型，是使用最多的参数类型，这类选项属于实验性（不稳定），以<code>-XX</code>开头。<br><strong>Boolean类型格式：</strong><br>① <code>-XX:+&lt;option&gt;</code>：启动option属性<br>② <code>-XX:-&lt;option&gt;</code>：禁用option属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如</span><br><span class="line">-XX:+PrintFlagsFinal 输出所有参数的名称和默认值</span><br><span class="line">-XX:-UseParallelGC 禁用并行收集器作为GC</span><br><span class="line">-XX:+UseG1GC 启动G1作为GC</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自动选择年轻代大小以及与Survivor区的比例</span><br></pre></td></tr></table></figure>

<p><strong>非Boolean类型格式：</strong><br>① 数值型格式 <code>-XX:&lt;option&gt;=&lt;number&gt;</code><br>② 非数值型格式 <code>-XX:&lt;name&gt;=&lt;string&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如</span><br><span class="line">数值型格式：</span><br><span class="line">-XX:NewSize=1024m 设置年轻代大小为1024MB</span><br><span class="line">-XX:MaxGCPauseMillis=500 设置GC停顿为500毫秒</span><br><span class="line">-XX:GCTimeRatio=19 设置吞吐量</span><br><span class="line">-XX:NewRatio=2 新生代与老年代比例</span><br><span class="line"></span><br><span class="line">非数值型格式：</span><br><span class="line">-XX:HeapDumpPath=/usr/local/heapdump.hprof 指定heap转存文件的存储路径</span><br></pre></td></tr></table></figure>


<p><strong>常用栈、堆、方法区参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈：</span><br><span class="line">-XXs128k 等价于-XX:ThreadStackSize=128k，设置每个线程的栈的大小为128KB</span><br><span class="line"></span><br><span class="line">堆：</span><br><span class="line">-Xms3550m 等价于-XX:InitialHeapSize，设置JVM初始堆内存为3550MB</span><br><span class="line">-Xmx2550m 等价于-XX:MaxHeapSize，设置JVM最大堆内存为3550MB</span><br><span class="line">-Xmn2g 设置年轻代大小为2G，推荐配置为整个堆大小的3/8</span><br><span class="line">-XX:NewSize=1024m 设置年轻代初始值为1024MB</span><br><span class="line">-XX:MaxNewSize=1024m 设置年轻代最大值为1024MB</span><br><span class="line">-XX:SurvivorRatio=8 Eden与S0（或S1）比值为8</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自动选择各区大小比例</span><br><span class="line">-XX:NewRatio=4 设置老年代与年轻代（Eden+S0+S1）比值</span><br><span class="line">-XX:PretenureSizeThreshold=1024 设置大于此阈值的对象直接分配在老年代，单位为字节，只对Serial、ParNew回收器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 新生代年龄大于该阈值的进入老年代，默认值为15</span><br><span class="line">-XX:+PrintTenuringDistribution JVM在每次GC后打印出当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:TargetSurvivorRatio MinorGC结束后Survivor区中占用空间的期望比例</span><br><span class="line"></span><br><span class="line">方法区：</span><br><span class="line">---永久代---</span><br><span class="line">-XX:PermSize=256m 设置永久代初始值为256MB</span><br><span class="line">-XX:MaxPermSize=256m 设置永久代最大值为256MB</span><br><span class="line"></span><br><span class="line">---元空间---</span><br><span class="line">-XX:MetaspaceSize 初始空间大小</span><br><span class="line">-XX:MaxMetaspaceSize 最大空间，默认没有限制</span><br><span class="line">-XX:+UseCompressedOops 压缩对象指针</span><br><span class="line">-XX:+UseCompressedClassPointers 压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Class Metaspace大小，默认1G</span><br><span class="line"></span><br><span class="line">直接内存：</span><br><span class="line">-XX:MaxDirectMemorySize 设置直接内存容量，若未指定，则默认与Java堆最大值一样</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>OOM常用参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:HeapDumpOnOutOfMemoryError 在内存出现OOM时，把Heap转存（dump）到文件中便于后续分析</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 在出现FullGC之前，生成Heap转储文件</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定的heap转存文件的存储路径</span><br><span class="line">-XX:OnOutOfMemoryError=/opt/Server/restart.sh 指定一个可行性程序或脚本的路径，在发生OOM的时候，去执行这个脚本</span><br></pre></td></tr></table></figure>

<p><strong>不同垃圾回收器的参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Serial回收器：</span><br><span class="line">-XX：+UseSerialGC</span><br><span class="line">Serial是HotSpot中Client模式下默认新生代垃圾回收器</span><br><span class="line">Serial Old是Client模式下默认老年代垃圾回收器</span><br><span class="line"></span><br><span class="line">ParNew回收器：</span><br><span class="line">-XX:+UseParNewGC 手动指定ParNew收集器执行新生代垃圾回收，不影响老年代</span><br><span class="line">-XX:ParallelGCThreads=N 限制线程数量，默认开启和CPU数相同的线程数</span><br><span class="line"></span><br><span class="line">Parallel回收器：</span><br><span class="line">-XX:+UseParallelGC  手动指定Parallel收集器执行新生代垃圾回收</span><br><span class="line">-XX:+UseParallelOldGC 手动指定ParallelOld收集器执行老年代垃圾回收</span><br><span class="line">-XX:ParallelGCThreads 设置新生代并行收集器线程数，一般与CPU数相等，CPU数大于8时，设置为3+[5*CPU_count]/8]</span><br><span class="line">-XX:MaxGCPauseMillis 垃圾回收最大停顿（STW）时间</span><br><span class="line">-XX:GCTimeRatio 垃圾收集时间占总时间比例</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge自适应调节</span><br><span class="line"></span><br><span class="line">CMS回收器：</span><br><span class="line">-XX:+UseConcMarkSweepGC 手动指定使用CMS收集器执行内存回收任务，开启后会自动将-XX:+UseParNewGC打开，即ParNew(Young Gen) + CMS(Old Gen) + Serial Old的组合</span><br><span class="line">-XX:CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK 5及以前默认68，JDK 6及以上默认92（百分比），改选项可以明显降低FullGC次数</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection 指定在执行完FullGC后对内存空间进行压缩整理，一次避免内存碎片的产生，不过由于内存压缩整理过程无法并发执行，导致停顿时间过长</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction 设置在执行多少次FullGC后对内存空间进行压缩整理</span><br><span class="line">-XX:ParallelCMSThreads 设置CMS线程数量，默认为(ParallelGCThreads+3)/4</span><br><span class="line"></span><br><span class="line">G1回收器：</span><br><span class="line">-XX:+UseG1GC 手动执行使用G1进行垃圾回收</span><br><span class="line">-XX:G1HeapRegionSize 设置Region大小，值是2的幂，范围1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆大小的1/2000</span><br><span class="line">-XX:MaxGCPauseMillis 设置期望达到的最大GC停顿时间，默认200毫秒</span><br><span class="line">-XX:ParallelGCThread 设置STW时GC线程数的值，最大为8</span><br><span class="line">-XX:ConcGcThreads 设置并发标记的线程数，一般为(ParallelGCThreads)/4</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值，超过就触发GC，默认45</span><br><span class="line">-XX:G1NewSizePercent -XX:G1MaxNewSizePercent 设置新生代占用整个堆内存的最小百分比，默认5%，最大60%</span><br><span class="line">-XX:G1ReservePercent=10 保留内存区域，防止Survivor的to区溢出  </span><br><span class="line"></span><br><span class="line">##G1收集器主要涉及到MixedGC，MixedGC会回收Young区和部分Old区</span><br><span class="line">---G1的Mixed GC调优参数---</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置堆占用率百分比，达到触发global concurrent marking（全局并发标记），默认45%，值为0表示简短进行全局并发标记</span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent 设置Old区的region被回收时候的对象占比，默认85%，之有Old区的region中存活的对象占用达到了这个百分比，才会在MixedGC中被回收</span><br><span class="line">-XX:G1HeapWastePercent 在global concurrent marking结束后，可以知道所有的区有多少空间要被回收，在每次YoungGC之后和再次发生MixedGC之前，会检查垃圾占比是否达到此参数，达到了下次才会发生MixedGC</span><br><span class="line">-XX:G1MixedGCCountTarget 一次global concurrent marking后，最多执行MixedGC的次数，默认为8</span><br><span class="line">-XX:G1OldCSetRegionThresholdPercent 设置MixedGC收集周期中要收集的Old Region数的上限，默认Java堆的10%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>其他参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+DisableExplicitGC 禁止HotSpot执行system.gc()，默认禁用</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k] -XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k] 指定代码缓存大小</span><br><span class="line">-XX:+UseCodeCacheFlushing 让JVM放弃一些已被编译的代码，避免代码缓存被占满时切换到只解释（interpreted-only）的模式</span><br><span class="line">-XX:+DoEscapeAnalysis 开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking 开启偏向锁</span><br><span class="line">-XX:UseLargePages 开启使用大页面</span><br><span class="line">-XX:+UseTLAB 使用TLAB，默认启用</span><br><span class="line">-XX:+PrintTLAB 打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize 设置TLAB大小</span><br></pre></td></tr></table></figure>

<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><p><strong>GC日志相关参数选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用：</span><br><span class="line">-verbose:gc 输出GC日志信息，默认输出到标准输出</span><br><span class="line">-XX:+PrintGC 等价于-verbose:gc，可以独立使用</span><br><span class="line">-XX:+PrintGCDetails 发生垃圾回收时打印内存回收的详细信息，并在进程退出时输出当前内存各区域分配情况，可以独立使用</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC发生时的时间戳，需要配合-XX:PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC发生时的时间戳（以日期形式），需要配合-XX:PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC 每一次GC前和GC后，都打印堆信息</span><br><span class="line">可以独立使用</span><br><span class="line">-Xloggc:&lt;file&gt; 把GC日志写入到一个文件夹中，而不是打印到标准输出</span><br></pre></td></tr></table></figure>

<h3 id="GCeasy"><a href="#GCeasy" class="headerlink" title="GCeasy"></a>GCeasy</h3><p><a href="https://gceasy.io/">官网</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能监控</tag>
        <tag>性能分析</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记1-内存与垃圾回收</title>
    <url>/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>这一个月打算把JVM学习一下，顺便梳理下知识，写个文档方便以后看吧。</p>
<div align="center"><img src="/.io//1.png"></div>

<span id="more"></span>

<h2 id="JVM发展史"><a href="#JVM发展史" class="headerlink" title="JVM发展史"></a>JVM发展史</h2><p>这一部分就简要介绍一下吧，Java虚拟机的发展按顺序可以写为：<br><em>Sun Classic/Exact VM</em>——&gt;<em>HotSpot VM</em>——&gt;<em>Mobile VM</em>——&gt;<em>JRockit 9</em>——&gt;<em>Liquid VM</em>、<em>Azul VM</em>——&gt;<em>Dalvik VM</em></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。系统虚拟机，如VMWare，是对物理计算机的仿真，提供一个可运行完整操作系统的平台。程序虚拟机，如JVM，专门为执行单个计算机指令而设计。<br>Java虚拟机是一台执行Java字节码的虚拟计算机，其运行的Java字节码不一定由Java语言编译而成。特点<strong>①一次编译，到处运行②自动内存管理③自动垃圾回收</strong>。</p>
<h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><div align="center"><img src="/.io//jvmposition.png" width="80%"></div>

<p>JVM运行在操作系统之上，与硬件没有直接交互。</p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><div align="center"><img src="/.io//jvmstructure.png" width="60%"></div>

<h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>$\bullet$ 类加载子系统负责从文件系统或者网络中加载Class文件，至于它是否可以运行，则由执行引擎决定。<br><br>$\bullet$ 加载的类信息存在方法区中。   </p>
<div align="center"><img src="/.io//classloader.png" width="80%"></div>

<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p><strong>加载阶段：</strong><br>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p><strong>链接阶段：</strong><br><em>验证(Verify)：</em> 保证加载类的正确性。<br><em>准备(Prepare)：</em> 为类变量分配内存并设置该类变量的初值，即零值；准备阶段不包含final修饰的static，因为final在编译的时候就分配了，准备阶段会显式初始化；准备阶段不会为实例变量分配初始化。<br><em>解析(Resolve)：</em> 将常量池内的符号引用转换为直接引用的过程；解析操作往往伴随JVM在执行完初始化之后再执行。</p>
<p><strong>初始化阶段：</strong><br>$\bullet$ 初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。<br>$\bullet$ 只有当类中存在静态成员变量的赋值操作时，才会有<code>&lt;clinit&gt;()</code>方法出现。<br>$\bullet$ <code>&lt;clinit&gt;()</code>不同于类的构造器。构造器是虚拟机视角下的<code>&lt;init&gt;()</code>。<br>$\bullet$ 若该类有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。<br>$\bullet$ 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</p>
<h4 id="两种（对应四个）类加载器"><a href="#两种（对应四个）类加载器" class="headerlink" title="两种（对应四个）类加载器"></a>两种（对应四个）类加载器</h4><p>JVM支持两种类型的类加载器：<strong>引导类加载器(Bootstrap ClassLoader)</strong> 和<strong>自定义类加载器(User-Defined ClassLoader)</strong> ，所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，由于扩展类加载器(Extension ClassLoader)和系统类加载器(Application ClassLoader)都继承ClassLoader类，故属于自定义加载类。</p>
<div align="center"><img src="/.io//classloadertype.png" width="80%"></div>

<p>对于用户自定义类，默认是使用系统类加载器进行加载的，而对于Java核心类，则使用引导类加载器进行加载。<br>图中四个类加载器之间不是继承关系！<br><strong>引导类加载器：</strong> 使用C/C++实现，嵌套在JVM内部；用来加载Java核心类库(JAVA_HOME/jre/lib路径下的类)；只加载包名为java、javax、sun等开头的类；加载扩展类加载器和系统类加载器；不继承ClassLoader；加载扩展类和应用程序类加载器，并指定为它们的父类加载器。<br><strong>扩展类加载器：</strong> 使用Java实现；继承于ClassLoader类；父类加载器为引导类加载器；用来加载java.ext.dirs系统属性所指定的目录中加载类库，或从jre/lib/ext路径下加载类库。<br><strong>应用程序类加载器：</strong> 使用Java实现；继承于ClassLoader类；父类加载器为扩展类加载器；用来加载java.class.path路径下的类；是程序中的默认类加载器。</p>
<p><strong>用户自定义类加载器：</strong> 它的默认父类加载器是应用程序类加载器；自定义加载器可以实现应用隔离；自定义类加载器通常需要继承于ClassLoader。</p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p><strong>避免类的重复加载，确保类的全局唯一性。</strong></p>
<p>①如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；<br>②如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器；<br>③如果父类加载器可以完成类加载任务，就成功返回；否则子加载器尝试自己加载。</p>
<p><em>例：假如要加载String类，默认先由系统类加载器进行加载，但根据双亲委派机制，系统类加载器要把加载任务委托给它的父类加载器：扩展类加载器，扩展类加载器还具有其父类加载器：引导类加载器，这样层层向上，来到了引导类加载器，由于String类是Java核心类库，属于引导类加载器的任务范围，所以直接由引导类加载器进行加载了。</em></p>
<p>双亲委派机制的优点：避免类的重复加载；保护程序安全，防止核心API被随意篡改（假如项目中有一个从网络传输来的伪装成java核心类库的jar包（java.lang.Attack)，在加载过程中，引导类加载器发现该jar包路径由java开头，于是自己执行加载任务，并加载JAVA_HOME/jre/lib下名字为Attack的的jar包，会发现没有这个jar包并抛出异常，避免了恶意攻击 <strong>（沙箱安全机制）</strong>。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>JVM中判断两个类是否为同一个类的条件：<br>$\bullet$ 类的完整类名必须一致，包括包名。<br><br>$\bullet$ 加载这个类的类加载器必须相同。<br>   </p>
<h4 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h4><p><strong>主动使用：</strong><br>$\bullet$ 创建类的实例<br><br>$\bullet$ 访问某个类或接口的静态变量，或者对该静态变量赋值<br><br>$\bullet$ 调用类的静态方法<br><br>$\bullet$ 反射(Class.forName(“java.long.String”))<br><br>$\bullet$ 初始化一个类的子类<br><br>$\bullet$ Java虚拟机启动时被标明启动类的类<br><br>$\bullet$ JDK7开始提供的动态预言支持<br><br><strong>被动使用：</strong><br>除了以上7种情况，其他使用Java类的方式都被看作是对类的被动使用。</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>运行时数据区(Runtime Data Area)包含5个部分：**方法区(Method Area)<strong>、</strong>堆(Heap)<strong>、</strong>虚拟机栈(Virtual Machine Stack)<strong>、</strong>程序计数器(Program Counter Register)<strong>、</strong>本地方法栈(Native Method Stack)**。</p>
<div align="center"><img src="/.io//runtimedataarea.png" width="80%"></div>

<p>运行时数据区与<strong>执行引擎</strong>、<strong>本地方法库</strong>也有交互：字节码文件中的数据加载到运行时数据区，执行引擎将字节码文件编译成机器指令，机器指令在执行时从运行时数据区调取数据并使用；Java调用C中的方法时使用本地方法栈进行分配。 </p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个JVM对应着一个进程，只有一个Runtime实例，支持多线程。在HotSpot JVM中，每个线程与操作系统的本地线程直接映射，Java线程终止后，本地线程也被回收。</p>
<p>JVM中的线程分为守护线程和普通线程，JVM中只剩下守护线程时，JVM就可以退出了。</p>
<p>一个JVM进程中的所有线程共享方法区和堆，虚拟机栈、本地方法栈、程序计数器则是线程私有的。</p>
<h4 id="程序计数器（无OOM、无GC）"><a href="#程序计数器（无OOM、无GC）" class="headerlink" title="程序计数器（无OOM、无GC）"></a>程序计数器（无OOM、无GC）</h4><p>JVM中的程序计数器是对物理程序计数器的一种模拟，用于存储指向下一条指令的地址，由执行引擎读取该地址对应的下一条操作指令(即istore_3，把第三个变量保存到局部变量表中)，并操作局部变量表、操作数栈、把字节码指令翻译成机器指令。</p>
<div align="center"><img src="/.io//pctest2.png" width="60%"></div>

<p><strong>为什么使用PC？</strong><br>PC使CPU来回切换线程时指导从哪继续执行，PC为线程私有，每个线程都有一个单独的PC，为了准确记录各个线程当前正在执行的字节码指令的地址。</p>
<h4 id="虚拟机栈（有OOM、有SOF、无GC）"><a href="#虚拟机栈（有OOM、有SOF、无GC）" class="headerlink" title="虚拟机栈（有OOM、有SOF、无GC）"></a>虚拟机栈（有OOM、有SOF、无GC）</h4><p>栈管运行，堆管存储。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。不同线程的栈帧之间不能相互引用。</p>
<p><strong>Java虚拟机规范允许Java栈的大小是动态的或是固定不变的。</strong><br>$\bullet$ 如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个<strong>StackOverflowError</strong>异常。<br>$\bullet$ 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，Java虚拟机会抛出一个<strong>OutOfMemoryError</strong>异常。<br>可以通过<code>-Xss1024k</code>这种方式设置线程的最大栈空间。   </p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">pulbic <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//vmstack.png" width="50%"></div>

<p>执行<em>methodA()</em> 的时候，为<em>methodA()</em> 创建一个栈帧，$i、j$ 依次入栈，最后会执行<em>methodB()</em> ，再为<em>methodB()</em> 创建一个栈帧，$k、p$ 依次入栈。栈顶方法为当前方法，只有当前方法是有效的。</p>
<h5 id="栈运行的原理"><a href="#栈运行的原理" class="headerlink" title="栈运行的原理"></a>栈运行的原理</h5><p>$\bullet$ 不同线程中所包含的栈帧是不允许相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。<br><br>$\bullet$ 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的返回结果给前一个栈帧，接着，虚拟机会丢弃该栈帧，使得前一个栈帧称为当前栈帧。<br><br>$\bullet$ Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。两种方式都会导致栈帧被弹出。<br></p>
<p><strong>栈帧的内部结构</strong></p>
<div align="center"><img src="/.io//stackframe.png" width="80%"></div>

<h5 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h5><p>$\bullet$ 用数组实现，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型（int、double等）、对象引用（reference），以及returnAddress类型。<br><br>$\bullet$ 这些数据类型在局部变量表中的存储空间以<strong>局部变量槽（Slot）</strong> 来表示，32位的数据类型占用1个Slot，64位数据类型（long、double）占用两个Slot。<br>$\bullet$ 局部变量表所需的容量大小在编译期确定，运行期间大小不变。<br><br>$\bullet$ 是线程的私有数据，不存在安全问题。<br><br>$\bullet$ 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会放在index为0的Slot处。<br></p>
<p>栈帧中与性能调优关系最密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。<br>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h5 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h5><p>用数组实现。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈、出栈。<br>$\bullet$ 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。<br><br>$\bullet$ <strong>操作数栈是JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。<br>$\bullet$ 操作数栈的深度在编译期确定。<br><br>$\bullet$ 与局部变量表中的Slot类似，32位的数据占用一个栈单位深度，64位的数据占用两个栈单位深度。<br><br>$\bullet$ 栈只能通过出栈（Pop）和入栈（Push）操作数据。<br><br>$\bullet$ 方法有返回值的话，返回值存入当前栈帧的操作数栈中。<br><br>$\bullet$ Java虚拟机的解释引擎是基于操作数栈的执行引擎。<br></p>
<p><strong>栈顶缓存技术：</strong><br>HotSpot JVM使用栈顶缓存技术（ToS, Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低内存的读/写次数，提升执行引擎的执行效率。</p>
<h5 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h5><p>$\bullet$ 动态连接是帧中保存的<strong>指向运行时常量池</strong>的方法引用。<br>$\bullet$ 在class文件的常量池中，描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，动态连接的作用就是将这些符号引用转换为调用方法的直接引用。<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><img src="/.io//dl3.png" width="80%"></div>

<p><strong>方法的调用：</strong><br><strong>静态连接：</strong> 如果被调用的目标方法在编译期可知，且运行期保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态连接。<br><strong>动态连接：</strong> 如果被调用的目标方法在编译期无法确定，只能在运行期将调用方法的符号引用转换位直接引用，这种转换过程具有动态性，因此被称为动态连接。<br><strong>非虚方法：</strong> 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，如静态方法、私有方法、final方法、实例构造器、弗雷方法。<br><strong>虚方法：</strong> 其他的方法称为虚方法。</p>
<p><strong>方法调用指令：</strong><br>普通调用指令：<br>$\bullet$ invokestatic：调用静态方法，解析阶段确定唯一方法版本。<br><br>$\bullet$ invokespecial：调用<code>&lt;init&gt;</code>方法、私有方法、父类方法，解析阶段确定唯一方法版本。<br>$\bullet$ invokevirtual：调用所有虚方法。<br><br>$\bullet$ invokeinterface：调用接口方法。<br></p>
<p>动态调用指令：<br>$\bullet$ invokedynamic：动态解析出需要调用的方法，然后执行。<br></p>
<h5 id="方法出口（Return-Address）"><a href="#方法出口（Return-Address）" class="headerlink" title="方法出口（Return Address）"></a>方法出口（Return Address）</h5><p>方法结束有两种方式：①正常执行完成；②出现未处理的异常，非正常退出。<br>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<strong>方法正常退出时</strong>，调用者PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。<strong>异常退出时</strong>，返回地址通过异常表现来确定，栈帧中一般不会保存这部分信息。</p>
<h4 id="本地方法栈（有OOM，有SOF，无GC）"><a href="#本地方法栈（有OOM，有SOF，无GC）" class="headerlink" title="本地方法栈（有OOM，有SOF，无GC）"></a>本地方法栈（有OOM，有SOF，无GC）</h4><p><strong>本地方法库：</strong><br>有时Java应用需要与Java外面的环境交互这是本地方法存在的主要原因。目前该方法使用的越来越少了，除非是与硬件有关的应用。</p>
<p>Java虚拟机栈用于管理Java方法的调用，本地方法栈用于管理本地方法的调用。<br>$\bullet$ 本地方法栈允许被实现成固定或者是可动态扩展的内存大小。与VM栈基本相同，也有OOM和SOF。<br><br>$\bullet$ 本地方法是用C语言实现的。<br><br>$\bullet$ 具体做法是在本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库。<br><br>$\bullet$ 当某个线程调用一个本地方法时，它就进入了一个全新的不再受虚拟机管制的世界。<br><br>$\bullet$ 并不是所有的JVM都支持本地方法，HotSpot JVM中，将本地方法栈和虚拟机栈合二为一。<br></p>
<h4 id="堆（有OOM，有GC）"><a href="#堆（有OOM，有GC）" class="headerlink" title="堆（有OOM，有GC）"></a>堆（有OOM，有GC）</h4><p>Java堆是被所有线程共享的一块内存区域，也是垃圾收集器管理的内存区域，在虚拟机启动时创建并确定空间大小，但是大小可调节。此内存区域的唯一目的是存放对象实例。</p>
<p>$\bullet$ 栈中存放普通数据和引用数据类型的地址，堆中存放相应的实例对象，栈中的值都被弹出时，堆中的对象不会立即被回收，只有在堆空间不足时，才会调用GC，清理没有被引用的实例。<br><br>$\bullet$ Java堆可以处于物理上不连续的空间中，但在逻辑上它是连续的。<br><br>$\bullet$ 并不是所有的对象都在堆上分配内存，也存在栈上分配——逃逸分析（Escape Analysis）<br><br>$\bullet$ 堆是执行GC的重点区域。<br></p>
<h5 id="堆空间的划分（分代收集理论）："><a href="#堆空间的划分（分代收集理论）：" class="headerlink" title="堆空间的划分（分代收集理论）："></a>堆空间的划分（分代收集理论）：</h5><p><strong>JDK 1.7及之前</strong><br>$\bullet$ 新生代（New/Young Generation Space）<br><br>$\bullet$ 老年代（Old/Tenure Generation Space）<br><br>$\bullet$ 永久代（Permanent Generation）<br></p>
<div align="center"><img src="/.io//jdk7heap.png" width="80%"></div>

<p><strong>JDK 1.8及以后</strong><br>$\bullet$ 新生代（New/Young Generation Space）<br><br>$\bullet$ 老年代（Old/Tenure Generation Space）<br><br>$\bullet$ 元空间（Meta Space）<br></p>
<p>默认情况下：<br>新生代 $:$ 老年代 $=$ 1 $:$ 2 <br><br>Eden $:$ S0 $:$ S1 $=$ 8 $:$ 1 $:$ 1 <br><br>如果默认不是以上比例，关闭自适应内存分配策略<code>-XX:-UseAdaptiveSizePolicy</code></p>
<div align="center"><img src="/.io//jdk8heap.png" width="80%"></div>

<p>存储在JVM中的Java对象可以分为两类：<br>$\bullet$ 生命周期较短，这类对象的创建和消亡都非常迅速。<br><br>$\bullet$ 生命周期非常长，在某些极端情况下与JVM生命周期保持一致。<br><br>$\bullet$ 几乎所有的Java对象都是在Eden区被new出来的。<br><br>$\bullet$ 绝大部分的Java对象在新生代中就被销毁了（朝生夕死，寿命很短）。<br></p>
<h5 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h5><h6 id="Yong-Minor-Garbage-Collection-YGC-Minor-GC"><a href="#Yong-Minor-Garbage-Collection-YGC-Minor-GC" class="headerlink" title="Yong/Minor Garbage Collection(YGC/Minor GC)"></a>Yong/Minor Garbage Collection(YGC/Minor GC)</h6><div align="center"><img src="/.io//ygc1.png" width="80%"></div>

<p>对象首先分配在Eden，当Eden满的时候，会触发YGC（Minor GC）（GC的同时会出现STW，Stop-The-World，停止用户线程），判断哪些对象是垃圾，哪些不是垃圾，图中红色对象是垃圾，绿色是仍要使用的对象。GC后仍要使用的对象被放入S0区，且寿命加1。</p>
<div align="center"><img src="/.io//ygc2.png" width="80%"></div>

<p>Eden的空间被清理干净后，继续会有新的对象分配进来，当Eden满的时候会再次执行GC，Eden中需要继续使用的对象放入S1区中，同时S0中的两个对象也要进行GC，判断哪些是垃圾哪些还要继续使用，S0中需要继续使用的对象也放入S1区中，此时的S0区相当于from区，S1区相当于to区，未被GC的对象寿命均加1。</p>
<div align="center"><img src="/.io//ygc3.png" width="80%"></div>

<p>Eden不断被占满、GC的过程周而复始，如图，当S1区中有对象的寿命已经达到15（年龄阈值，默认为15，TenuringThreshold）且仍要继续使用时，这些对象会进行promotion（晋升），放入老年代中。</p>
<p><strong>总结：</strong><br>$\bullet$ GC频繁在新生代收集，很少在老年代收集，几乎不在元空间收集。<br><br>$\bullet$ 只有当Eden满的时候才会触发YGC，S0、S1满不会触发YGC；YGC一旦触发，会对Eden、S0、S1都进行回收。<br><br>$\bullet$ <strong>内存分配的特殊情况：</strong>对于超大对象，①Eden中放的下但S0或S1区中放不下，直接晋升到老年代；②如果进行YGC之后Eden中仍然没有足够的空间、或Eden本身的空间就小于对象大小，那么该对象将被直接放入老年代，如果老年代也放不下，进行Major GC，对老年代进行垃圾回收，如果Major GC后的空间足以放下对象，则将对象放入老年代，如果Major GC后的空间仍然不足，抛出OOM。<br>$\bullet$ 堆空间分代的理由就是优化GC性能，不同代进行GC的频率不同。如果不分代，每次GC都要扫描整个堆空间。<br></p>
<h6 id="Partial-GC和Full-GC"><a href="#Partial-GC和Full-GC" class="headerlink" title="Partial GC和Full GC"></a>Partial GC和Full GC</h6><p><strong>Partial GC:指目标不是完整收集整个Java堆的垃圾收集，分为下面几种</strong><br>$\bullet$ Minor GC/Young GC，新生代的垃圾收集。<br><br>$\bullet$ Major GC/Old GC，老年代的垃圾收集，（Full GC和Major GC有时会混淆使用，指代老年代收集，要根据上下文区分），Major GC比Minor GC慢10倍以上，STW更长，Major GC后内存还不足就报OOM。<br><br>$\bullet$ Mixed GC，整个新生代以及部分老年代的垃圾收集，只有G1收集器会有这种行为。<br><br><strong>Full GC：指目标是整个Java堆和方法区的垃圾收集</strong></p>
<h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><p>$\bullet$ 优先分配到Eden。<br><br>$\bullet$ 大对象直接分配到老年代，但要尽量避免程序中出现过多的大对象。<br><br>$\bullet$ 长期存活的对象分配到老年代。<br><br>$\bullet$ 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。<br><br>$\bullet$ 空间分配担保，Eden进行Minor GC后仍有很多对象存活，且Survivor区中不足以容纳这些对象时，需要老年代提供空间分配担保。<code>-XX:HandlePromotionFailure</code><br></p>
<h5 id="从逃逸分析看内存分配策略"><a href="#从逃逸分析看内存分配策略" class="headerlink" title="从逃逸分析看内存分配策略"></a>从逃逸分析看内存分配策略</h5><p>之前提到，堆并不是对象存储的唯一选择，经过<strong>逃逸分析（Escape Analysis）</strong>后，如果发现一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否发生逃逸的关键，看new的对象是否有可能在方法外被调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 1，未发生逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2, 发生逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 3, 未发生逃逸 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 4， 发生逃逸</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用逃逸分析，编译器可以对代码做如下优化：<br>$\bullet$ <strong>栈上分配</strong>，将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的首选。线程结束，栈空间被回收，局部变量对象也被回收，这样就无需GC。<br>$\bullet$ <strong>同步省略</strong>，如果一个对象发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。线程同步的代价很高，会降低并发性和性能，锁对象只能被一个线程访问而没有被发布到其他线程时，可以取消同步（同步省略），也叫锁消除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis)&#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            <span class="function">v</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\bullet$ <strong>分离对象或标量替换</strong>，有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。标量（Scalar）指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。还可以再分解的数据叫聚合量（Aggregate），如Java中的对象。在JIT阶段，经过逃逸分析发现一个对象不会被外界访问的话，就会把这个对象拆解成若干个其中包含若干个成员变量来代替。这个过程就是标量替换。</p>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p>为什么有TLAB？<br>$\bullet$ 堆区是线程共享区域，任何线程都可以访问堆区的共享数据。<br><br>$\bullet$ 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。<br><br>$\bullet$ 为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。<br></p>
<p>TLAB，Thread Local Allocation Buffer（%1Eden），对Eden区进行划分，JVM为每个线程分配了一个私有缓存区域，可以避免非线程安全问题，并提升内存分配吞吐量（称为快速分配策略），对象大于TLAB大小时，在剩余Eden空间进行分配。</p>
<h5 id="堆空间设置参数"><a href="#堆空间设置参数" class="headerlink" title="堆空间设置参数"></a>堆空间设置参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial: 查看所有参数初始默认值</span><br><span class="line">-XX:+PrintFlagsFinal: 查看所有参数最终值</span><br><span class="line">-Xms256m: 初始堆空间设置为256MB，默认为物理内存的<span class="number">1</span>/<span class="number">64</span></span><br><span class="line">-Xmx256m: 最大堆空间内存设置为256MB，默认为物理内存的<span class="number">1</span>/<span class="number">4</span>，建议将初始堆内存和最大堆内存设置成一样大</span><br><span class="line">-Xmn128m: 新生代大小设置为128MB</span><br><span class="line">-XX:NewRatio=<span class="number">2</span>: 老年代:新生代 比例为<span class="number">2</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>: Eden:S0/S1 比例为<span class="number">8</span></span><br><span class="line">-XX:MaxTenuringThreshold: 新生代垃圾最大年龄阈值</span><br><span class="line">-XX:+PrintGCDetails: 打印GC日志</span><br><span class="line"></span><br><span class="line">cmd指令：</span><br><span class="line">jps: 查看JVM进程号</span><br><span class="line">jinfo -flag NewRatio 进程号: 查看JVM老年代与新生代的比例</span><br></pre></td></tr></table></figure>

<h4 id="方法区（有OOM，有GC）"><a href="#方法区（有OOM，有GC）" class="headerlink" title="方法区（有OOM，有GC）"></a>方法区（有OOM，有GC）</h4><p>栈、堆、方法区的交互关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法区 java栈      java堆</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>逻辑上将方法区看做堆的一部分，堆有GC和压缩算法（处理内存碎片），方法区可能没有对二者的实现，方法区还有一个别名叫Non-Heap（非堆），目的就是要与堆分开。所以，方法区看做是一块独立于Java堆的内存空间。</p>
<div align="ceneter"><img src="/.io//methodarea.png" width="80%"></div>

<p>$\bullet$ 方法区与Java堆一样，是各个线程共享的内存区域。<br><br>$\bullet$ 方法区在JVM启动的时候被创建，它在实际物理内存空间中不一定是连续的，与堆一样。<br><br>$\bullet$ 方法区的大小可以选择固定大小或可扩展，与堆一样。<br><br>$\bullet$ 方法区的大小决定系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出OOM错误（①加载大量第三方Jar包②Tomcat部署工程过多（30-50个）③大量动态的生成反射类）。<br><br>$\bullet$ 关闭JVM就会释放方法区的内存。<br></p>
<h5 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h5><p>JDK 1.7及以前，方法区称为永久代。JDK 1.8及以后，使用元空间取代了永久代。本质上，方法区和永久代并不等价。（永久代更像是HotSpot虚拟机中的方言，在JDK 1.7及以前把方法区叫做永久代，在JDK 1.8及以后把方法区叫做元空间。在其他Java虚拟机中，如BEA JRockit和IBM J9，方法区就是方法区，没有永久代的叫法。）</p>
<p>永久代与元空间的最大区别在于：元空间不再虚拟机设置的内存中，而是使用本地内存，不只是名字变了，内部结构也发生了变化。</p>
<p><strong>方法区演进细节</strong></p>
<p><strong>JDK 1.6及以前：</strong><br>有永久代，静态变量存放在永久代。</p>
<div align="center"><img src="/.io//methodareajdk6.png" width="70%"></div>

<p><strong>JDK 1.7：</strong><br>有永久代，但已逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。</p>
<div align="center"><img src="/.io//methodareajdk7.png" width="70%"></div>

<p><strong>JDK 1.8及以后：</strong><br>使用本地内存，无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。</p>
<div align="center"><img src="/.io//methodareajdk8.png" width="70%"></div>

<p><strong>调整StringTable位置的原因：</strong><br>JDK 1.7中将StringTable放到了堆空间里，因为永久代的回收效率很低，在Full GC时才会触发，而Full GC只有在老年代、永久代空间不足时才会出现。这就导致StringTable回收效率不高，而开发时会有大量字符串被创建，回收效率低会导致永久代内存不足，放到堆里可以及时回收内存。</p>
<p><strong>静态变量的位置</strong><br>对于静态变量，它的对象实体始终都存在堆空间里，而指向对象实体的静态引用从方法区转移到了堆中，故在JDK 1.8中，静态变量与类型都存储在堆中。</p>
<p><strong>为什么用元空间替换永久代？</strong><br>①是完成JRockit与HotSpot融合工作的一部分，JRockit中没有永久代。<br>②为永久代设置的空间大小很难确定。<br>③对永久代调优困难。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，字节码文件中的常量池加载到方法区后，就称为运行时常量池，包含数量值、字符串值、类引用、字段引用、方法引用。如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，JVM就会抛出OOM异常。</p>
<p>常量池可以看做成一张表，它的作用就就是使虚拟机根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h5><p>方法区的有时也会需要垃圾回收，但是效果往往难以令人满意。它主要回收两部分内容：①常量池中废弃的常量；②不再使用的类型。</p>
<p>废弃的常量判断：没有被任何地方引用，就可以回收。<br>废弃的类型判断：①该类所有的实例（该类及派生子类）都已经被回收；②加载该类的加载器都已经被回收；③该类对应的java.lang.Class对象没有在任何地方被引用（即不能再通过反射访问）。</p>
<h5 id="方法区设置参数"><a href="#方法区设置参数" class="headerlink" title="方法区设置参数"></a>方法区设置参数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JDK <span class="number">1.7</span></span><br><span class="line">-XX:PermSize=100m 为永久代设置初始分配空间，默认值<span class="number">20.</span>75MB</span><br><span class="line">-XX:MaxPerSize=100m 为永久代设置最大可分配空间，<span class="number">32</span>位机器默认值64MB，<span class="number">64</span>位机器默认值82MB</span><br><span class="line"></span><br><span class="line">JDK <span class="number">1.8</span></span><br><span class="line">-XX:MetaspaceSize=100m 为元空间设置初始分配空间，默认值21MB</span><br><span class="line">-XX:MaxMetaspaceSize=100m 为元空间设置最大可分配空间，默认值-<span class="number">1</span>，表示没有限制</span><br></pre></td></tr></table></figure>

<h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h5><p>$\bullet$ new<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a person.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">PersonBuilder或PersonFactory的静态方法</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 反射<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种，Class的newInstance，只能调用空参的构造器，权限必须是public</span></span><br><span class="line">Object person = Class.forName(<span class="string">&quot;Person&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，Constructor的newInstance，可以调用空参和带参的构造器，权限无要求</span></span><br><span class="line"><span class="comment">// 空参</span></span><br><span class="line">Constructor person1 = Class.forName(<span class="string">&quot;Person&quot;</span>).getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="comment">// 带参</span></span><br><span class="line">Constructor person2 = Class.forName(<span class="string">&quot;Person&quot;</span>).getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;).newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 使用clone()，不调用任何的构造器，但当前的类需要实现Cloneable()接口，实现clone()方法。<br><br>$\bullet$ 使用反序列化：从文件中或网络中获取对象的二进制流，还原成内存中的对象。<br><br>$\bullet$ 使用第三方库Objenesis。<br></p>
<h5 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h5><p>$\bullet$ 判断对象对应的类是否加载、链接、初始化（加载对象所处的类）。<br><br>$\bullet$ 为对象分配内存。①如果内存规整：指针碰撞（指针指向可用内存的起始地址，每分配一部分空间，指针向后移动分配出的空间大小，再次指向可用内存）；②如果内存不规整：虚拟机维护一个列表（记录哪些内存块是可用的），在列表中找到足够大的空间分配给对象实例，称为空闲列表。<br><br>$\bullet$ 处理并发安全问题。①采用CAS（Compare And Swap）配上失败重试保证更新的原子性。②每个线程预先分配一个TLAB。<br><br>$\bullet$ 初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。<br><br>$\bullet$ 设置对象的对象头。<br><br>$\bullet$ 执行init方法进行初始化，初始化后一个真正可用额对象才被完全创建出来。<br></p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>$\bullet$ <strong>对象头</strong>，包含<strong>①运行时元数据</strong>（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）<strong>②类型指针</strong>，指向类元数据InstanceClass，确定该对象所属的类型。<br>$\bullet$ <strong>实例数据</strong>，这是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段。<br>$\bullet$ <strong>对齐填充</strong>，仅仅起到占位符的作用。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。<br><strong>句柄访问：</strong><br>①优点：稳定句柄地址，对象被移动时只改变句柄中的实例数据指针，栈空间的地址不需要修改。<br>②缺点：有空间开销，且访问效率较低。<br><strong>直接指针（HotSpot采用）：</strong><br>①优点：速度快，节省了一次指针定位的开销。<br>②缺点：对象被移动时，栈空间中的地址要进行修改。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存不是虚拟机运行时数据区的一部分，而是Java堆外的、直接向系统申请的内存区间。通常访问直接内存的速度会优于Java堆，即读写性能高。<br>$\bullet$ 读写频繁的场合会考虑使用直接内存。<br><br>$\bullet$ Java的NIO（New IO/Non-Blocking IO）库允许Java程序使用直接内存，用于数据缓存区。<br><br>$\bullet$ 也有OOM。<br><br>$\bullet$ 缺点：分配回收成本高；不受JVM内存回收管理。<br><br>$\bullet$ 通过<code>-XX:MaxDirectMemorySize</code>设置。<br></p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>虚拟机的执行引擎是由软件自行实现的，不受物理条件限制地定制指令集和执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。<br>JVM的主要任务是负责装载字节码到其内部，执行引擎的任务是把字节码指令解释/编译为对应平台上的本地机器指令，充当了将高级语言翻译为机器语言的译者。</p>
<div align="center"><img src="/.io//ee.png" width="80%"></div>

<p>Java是半编译半解释型语言，既包括解释器，有包括编译器，在执行Java代码时，解释执行和编译执行二者结合起来进行。</p>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>字节码是一种中间状态的二进制代码，比机器码更加抽象，需要翻译后才能成为机器码。</p>
<h4 id="前端编译：解释器"><a href="#前端编译：解释器" class="headerlink" title="前端编译：解释器"></a>前端编译：解释器</h4><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将字节码文件中每条指令“翻译”为对应平台的本地机器指令执行。<br>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<p>前端编译器不包含在JVM中。</p>
<h4 id="后端编译：编译器"><a href="#后端编译：编译器" class="headerlink" title="后端编译：编译器"></a>后端编译：编译器</h4><h5 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h5><p>JIT（Just In Time Compiler）即时编译器是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。<br><strong>热点代码：</strong><br>根据字节码中的代码被调用执行的频率，决定需要直接编译为对应平台本地机器指令的代码，这些需要被编译为本地代码的字节码，称为“热点代码”。JIT会对被频繁调用的“热点代码”做深度优化。<br>如：一个被多次调用的方法，循环次数较多的循环体。由于JIT在编译这些代码时发生在方法执行过程中，故称为栈上替换（OSR， On Stack Replacement）。<br>HotSpot中采用的热点探测方式是基于计数器的热点探测（使用热度衰减）。</p>
<h5 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h5><p>AOT（Ahead Of Time Compiler）提前编译器<strong>在程序运行之前</strong>直接把程序编译成与目标机器指令集相关的二进制代码。<br>AOT编译的过程为：.java$\rightarrow$.class$\rightarrow$.so(机器码)<br>由于机器码与硬件是紧密相关的，所以AOT其实破坏了Java“一次编译，导出运行”的特性。</p>
<h5 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h5><p>JDK 10中加入的新的即时编译器，仍在Experimental状态。使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMC1Compiler</code>，效果已追平C2编译器。</p>
<h5 id="集大成者——HotSpot"><a href="#集大成者——HotSpot" class="headerlink" title="集大成者——HotSpot"></a>集大成者——HotSpot</h5><p>HotSpot采用解释器与即时编译器并存的架构，在JVM运行时，解释器和即时编译器能够相互协作，选择最合适的方式权衡直接解释执行代码和编译本地代码的时间。<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。而编译器需要先将代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。<br>当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<br>同时，解释执行在编译执行进行激进优化不成立的时候，作为编译器的“逃生门”。<br><strong>C1和C2编译器：</strong><br>在HotSpot中，有两个JIT编译器，分别为Client Compiler和Server Compiler，简称为C1和C2编译器。C1编译器会对字节码进行简单和可靠地优化，耗时短；C2编译器会进行激进优化，耗时长，但优化的代码执行效率更高。基于逃逸分析，C2的优化有标量替换、栈上分配、同步消除。</p>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><h4 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h4><p>$\bullet$ 常量与常量的拼接结果在常量池，原理是编译器优化。<br><br>$\bullet$ 常量池中不会存在相同内容的变量。<br><br>$\bullet$ 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。<br><br>$\bullet$ 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回次对象地址。<br></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StringTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;stringtable&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;string&quot;</span> + <span class="string">&quot;table&quot;</span>; <span class="comment">//编译期优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是变量拼接，需要在堆空间中new String()，字符串内容为拼接后的结果</span></span><br><span class="line">    String s5 = s1 + <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;string&quot;</span> + s2;</span><br><span class="line"></span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    s1 + s2 的细节：</span></span><br><span class="line"><span class="comment">    StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    s.append(&quot;string&quot;);</span></span><br><span class="line"><span class="comment">    s.append(&quot;table&quot;);</span></span><br><span class="line"><span class="comment">    s.toString()  ---&gt; 约等于new String(&quot;stringtable&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    【StringBuilder.append()方法比拼接符&quot;+&quot;的速度快。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ①：StringBuilder.append()自始至终只创建一个StringBuilder对象；</span></span><br><span class="line"><span class="comment">    &quot;+&quot;拼接方式则创建了多个StringBuilder和String对象；</span></span><br><span class="line"><span class="comment">    ②：使用&quot;+&quot;拼接方式，内存中由于创建了较多的StringBuilder和String对象，</span></span><br><span class="line"><span class="comment">    内存占用更大，如果进行GC，需要花费更多的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在实际开发中，如果基本确定前后添加的字符串长度不高于某个限定值highlevel的情况下，建议使用构造器：</span></span><br><span class="line"><span class="comment">    StringBuilder s = new StringBuilder(highlevel); // new char [highlevel]】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* intern()：判断字符串常量池中是否存在&quot;stringtable&quot;值，</span></span><br><span class="line"><span class="comment">     *如果存在，则返回常量池中&quot;stringtable&quot;的地址，</span></span><br><span class="line"><span class="comment">     *如果不存在，则在常量池中加载一份&quot;stringtable&quot;，并返回该对象的地址。*/</span></span><br><span class="line">    String s8 = s6.intern();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定都使用StringBuilder</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，</span></span><br><span class="line"><span class="comment">       则仍然使用编译期优化，即非StringBuilder的方式</span></span><br><span class="line"><span class="comment">    2. 针对与final修饰类、方法、基本数据类型、引用数据类型的，</span></span><br><span class="line"><span class="comment">       能使用final则建议使用final</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">final</span> String s9 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s10 = <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s11 = s9 + s10;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    s3 == s4 true</span></span><br><span class="line"><span class="comment">    s3 == s5 false</span></span><br><span class="line"><span class="comment">    s3 == s6 false</span></span><br><span class="line"><span class="comment">    s3 == s7 false</span></span><br><span class="line"><span class="comment">    s5 == s6 false</span></span><br><span class="line"><span class="comment">    s5 == s7 false</span></span><br><span class="line"><span class="comment">    s6 == s7 false</span></span><br><span class="line"><span class="comment">    s3 == s8 true</span></span><br><span class="line"><span class="comment">    s3 == s11 true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如何保证变量s指向的是字符串常量池的数据：</span></span><br><span class="line"><span class="comment">    1. String s = &quot;stringtable&quot;; // 字面量定义</span></span><br><span class="line"><span class="comment">    2. String s = new String(&quot;stringtable&quot;).intern();</span></span><br><span class="line"><span class="comment">       String s = new StringBuilder(&quot;stringtable&quot;).toString().intern();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StringTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// jdk7后把字符串常量池放在了堆中，所有jdk版本不一样，结果也不一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种与jdk版本无影响</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>); <span class="comment">//返回堆空间的1</span></span><br><span class="line">    s.intern(); </span><br><span class="line">    <span class="comment">/* 注意不是s = s.intern()，s.intern()只是在执行了</span></span><br><span class="line"><span class="comment">     * 下在常量池中查找1的操作，即使它找到了1，也没有返回，</span></span><br><span class="line"><span class="comment">     * 而s=s.intern()则把在字符串常量池中查找到的1的地址</span></span><br><span class="line"><span class="comment">     * 重新返回给了自己。调用之前字符串中有现成的1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>; <span class="comment">// 字面量方式，指向常量池中的1</span></span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    <span class="comment">// jdk6及以前 false</span></span><br><span class="line">    <span class="comment">// jdk7及以后 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种jdk版本有影响</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    <span class="comment">/* s3的地址为；new String(&quot;11&quot;)，但执行完后，</span></span><br><span class="line"><span class="comment">     * 字符串常量池中不存在11（与jdk版本无关）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    s3.intern(); </span><br><span class="line">    <span class="comment">/* jdk6中：在字符串常量池中创建了一个新的对象&quot;11&quot;，</span></span><br><span class="line"><span class="comment">     * 有新的地址。在jdk7及以后，由于常量池在堆中，</span></span><br><span class="line"><span class="comment">     * 而堆中已经有&quot;11&quot;了，常量池中直接存储堆中&quot;11&quot;的地址*/</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>; </span><br><span class="line">    <span class="comment">//s4记录上一行代码执行时，常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;s3 == s4&quot;</span>);</span><br><span class="line">    <span class="comment">// jdk6及以前 false</span></span><br><span class="line">    <span class="comment">// jdk7及以后 true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. new String(&quot;ab&quot;)会创建几个对象？</span></span><br><span class="line"><span class="comment">   2个</span></span><br><span class="line"><span class="comment">   在堆中放入java.lang.String;</span></span><br><span class="line"><span class="comment">   在字符串常量池放ab(字节码中可以看)。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   new String(&quot;a&quot;) + new String(&quot;b&quot;)会创建介个对象？</span></span><br><span class="line"><span class="comment">   6个</span></span><br><span class="line"><span class="comment">   变量拼接，创建java.lang.StringBuilder；</span></span><br><span class="line"><span class="comment">   在堆中创建java.lang.String；</span></span><br><span class="line"><span class="comment">   在字符串常量池中创建a；</span></span><br><span class="line"><span class="comment">   在队中创建java.lang.String；</span></span><br><span class="line"><span class="comment">   在字符串常量池中创建b。</span></span><br><span class="line"><span class="comment">   StringBuilder中的toString()会在堆中生成ab，在字符串常量池中没有ab</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>String的垃圾回收：<code>-XX:+PrintStringTableStatistics</code></p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java和C++最大的区别就在于内存动态分配和垃圾收集技术。GC发生在方法区和<strong>堆空间</strong>。<br>关于垃圾收集有三个经典问题：<br>①哪些内存需要回收？<br>②什么时候回收？<br>③如何回收？</p>
<p><strong>什么是垃圾？</strong><br>垃圾是指运行程序中没有任何指针指向的对象。这个对象就是需要被回收的垃圾。<br>如果不及时对内存中的垃圾进行回收，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出（OutOfMemory）</strong>。<br>倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄露</strong>。</p>
<p><strong>为什么需要GC？</strong></p>
<p>如果不进行垃圾回收，内存迟早会被消耗完。<br>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。<br>没有GC就不能保证应用程序的正常进行。<br>Java的自动内存管理机制，无需开发人员手动参与内存的分配与回收，降低内存泄露和内存溢出的风险，更专注于业务开发，但也弱化了Java开发人员对出现内存溢出问题时的定位和解决能力。</p>
<h4 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h4><h5 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h5><p>调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>会显式触发<strong>Full GC</strong>，但<code>System.gc()</code>不确保垃圾回收能立即执行。</p>
<h5 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h5><p>$\bullet$ 内存溢出（OutOfMemory）：没有空闲内存，并且垃圾收集器也无法提供更多内存。<br><br><strong>没有空闲内存：</strong> ①Java虚拟机的堆内存设置不够（可能存在内存泄露）；②创建了大量对象，并且长时间不能被垃圾收集器收集。<br><strong>GC后也无足够内存：</strong> ①JVM尝试回收软引用指向的对象；②对于超大对象JVM判断GC不能解决问题，于是不触发GC直接抛出OOM。</p>
<p>$\bullet$ 内存泄露（MemoryLeak）<br><br>只有对象不会再被程序用到了，但GC又不能回收他们的情况，才叫内存泄露。<br>例子：①单例模式：单例（一个进程只有一个实例）的生命周期和应用程序一样长，如果单例程序持有对外部对象的应用的话，那么这个外部对象是不能回收的，导致内存泄露；②：数据库连接（<code>dataSource.getConnection()</code>），网络连接（<code>socket</code>）和IO连接必须手动close，否则是不能回收的。</p>
<h5 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop-The-World"></a>Stop-The-World</h5><p>指在GC事件发生时，用户线程会停顿，没有有任何响应，这个停顿称为STW。被STW中断的用户线程会在完成GC后恢复，频繁中断会造成用户体验不佳，要尽量减少STW。<br>STW是JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，STW不可避免，但优秀的GC会使用户几乎感觉不到STW。<br>开发中不要使用<code>System.gc()</code>，会导致STW。</p>
<h5 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h5><p><strong>并发（Concurrent）：</strong><br>①在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在$\color{red}一个处理器$上运行。<br>②并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间区间，然后在这几个时间区间中来回切换，由于CPU处理速度非常快，只要时间间隔处理得当，就可以让用户感觉是多个应用程序在同时进行。</p>
<div align="center"><img src="/.io//concurrent.png" width="80%"></div>

<p><strong>并行（Parallel）：</strong><br>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，称为并行。<br>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，一个CPU多个核也可以并行。</p>
<div align="center"><img src="/.io//parallel.png" width="87%"></div>

<p><strong>垃圾回收的并行：</strong> STW时，多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<br><strong>垃圾回收的串行：</strong> 相较于并行的概念，单线程执行；如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。<br><strong>垃圾回收的并发：</strong> 用户线程和垃圾收集线程同时执行（不一定是并行，因为仍然存在STW），CMS、G1都是这样。</p>
<h5 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h5><p><strong>安全点（Safe Point）：</strong> 应用程序线程并不是在所有地方都能停下来开始GC，只有在特定位置才能停下来开始GC，这些位置称为安全点。安全点太少会使GC等待时间过长，安全点太多会使GC过于频繁。<br><strong>如何保证GC时，所有线程都在最近的安全点停下？</strong><br>①主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己中断挂起。<br>②抢先式中断（目前没有虚拟机采用了）：中断所有线程，如果有线程不在安全点，就恢复线程使其到达最近安全点。<br><strong>安全区域（Safe Region）：</strong> 程序在执行时，走到安全点挂起，当程序本身就在Sleep或Blocked状态时，是不能向前走的，这时用安全区域的方法。安全区域指在一段代码中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。安全区域看做扩展长度的安全点。 </p>
<h5 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h5><p>JDK1.2之后对引用的概念进行了扩充，强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），引用强度依次减弱。<br><strong>强引用：</strong> 程序代码中普遍存在的引用赋值，任何情况下，只要强引用还在，GC就不会回收被引用的对象。<br><strong>软引用：</strong> 内存足够时，不会回收软引用的对象；系统发生内存溢出之前，才会回收软引用的对象，如果回收后仍没有足够空间，抛出OOM。<br><strong>弱引用：</strong> 只要发生GC，弱引用对象就会被回收。<br><strong>虚引用：</strong> 一个对象是否有虚引用的存在，完全不会对其生存周期构成影响。唯一目的是该对象被回收时收到一个系统通知。</p>
<h4 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h4><h5 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h5><p>在堆内存中区分出哪些是存活对象，哪些是死亡对象，当一个对象不被任何存活对象引用时，就宣判该对象已死亡。标记为死亡的对象才会释放其内存空间，这个过程称为<strong>垃圾标记阶段</strong>。判断对象存活有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h6 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h6><p>对每个对象都保留一个整型的引用计数器属性，用于记录对象被引用的情况。</p>
<p><strong>算法思想：</strong><br>对于一个对象A，只要有任何一个对象引用了A，A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，表示A不再被使用，可进行回收。<br><strong>优点：</strong> 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。<br><strong>缺点：</strong> ①需要单独的字段存储计数器，增加了存储空间开销。②每次赋值需要更新计数器，伴随加减法操作，增加了时间开销。③无法处理循环引用问题，故在Java的垃圾回收器中没有使用这类算法。</p>
<h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>也称为根搜索算法、追踪性垃圾收集。实现简单、执行高效，可以解决循环引用的问题，防止内村泄露，是Java垃圾回收器选择的垃圾标记算法。</p>
<p><strong>GC Roots</strong>根集合是一组必须活跃的引用，包括：<br>①虚拟机栈中引用的对象；②本地方法栈内JNI（本地方法）引用的对象；③方法区中类静态属性引用的对象；④方法区中常量引用的对象；⑤Java虚拟机内部的引用；⑥反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p><strong>算法思想：</strong><br>$\bullet$ 以GC Roots为起始点，从上至下搜索被根对象集合所连接的目标对象是否可达。<br><br>$\bullet$ 内存中存活的对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。<br><br>$\bullet$ 如果目标对象没有任何引用链相连，则是不可达的，说明该对象已经死亡，标记为垃圾对象，其他对象则为存活对象。<br></p>
<h5 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h5><p>在区分出内存中的存活对象和死亡对象之后，GC就要执行垃圾回收释放内存了。下面是常见的三种垃圾收集算法。。</p>
<h6 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h6><p>堆中的有效内存空间被耗尽时，执行Stop-The-World，然后进行两项工作：标记、清除。<br><strong>标记：</strong> 从引用根节点开始遍历，标记所有被引用的对象，记录在Header中。<br><strong>清除：</strong> 对堆内存从头到尾线性遍历，如果发现某个对象的Header没有标记为可达，则回收。这里的清除并不是真的置空，而是把需要清除的对象地址保存在空闲列表中，下次有新的对象需要加载时，判断列表的位置空间是否够，够就存放。</p>
<div align="center"><img src="/.io//mark-sweep.png" width="80%"></div>

<p><strong>优点；</strong> 基础且常见。<br><strong>缺点：</strong> ①效率不高（标记时要从根节点递归遍历所有可达对象，清除时要遍历整个内存空间）；②GC时需要STW；③清理出的内存空间不一定连续，有内存碎片。</p>
<h6 id="标记-复制算法（Mark-Copying）"><a href="#标记-复制算法（Mark-Copying）" class="headerlink" title="标记-复制算法（Mark-Copying）"></a>标记-复制算法（Mark-Copying）</h6><p>解决了标记-清除算法收集效率方面的缺陷。将活着的内存空间分为两块，每次只使用其中的一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<div align="center"><img src="/.io//mark-copying.png" width="80%"></div>

<p><strong>优点：</strong> ①没有标记和清除过程，实现简单，运行高效；②复制过去以后保证空间的连续性，不会出现内存碎片。<br><strong>缺点：</strong> ①需要两倍内存空间；②对于G1这种将内存拆分成大量region的GC，来回复制需要GC维护region之间的引用关系，开销也大。③复制的存活对象数量不能太大。</p>
<h6 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h6><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但在老年代，大部分对象都是存活对象。基于老年代垃圾回收的特性，需要使用其他算法。<br>$\bullet$ 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。<br><br>$\bullet$ 第二阶段将所有的存活对象压缩到内存的一端，按顺序存放。之后清理边界外所有的空间。<br></p>
<div align="center"><img src="/.io//mark-compact.png" width="80%"></div>

<p><strong>优点：</strong> ①消除了标记-清除算法中，内存区域分散的缺点，给新对象分配内存时，JVM只需持有一个内存的起始地址即可；②避免了复制算法中内存减半的代价。<br><strong>缺点：</strong> ①效率低于标记-复制算法；②移动对象的同时，如果对象被其他对象引用，需要调整引用地址；③移动时有STW。</p>
<h6 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h6><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>需要两倍内存大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>目前所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的，不用生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p>
<p>$\bullet$ 年轻代（Young Gen）<br><br>年轻代区域相对老年代较小，对象生命周期短、存活率低，回收频繁。<br>使用<em>标记-复制</em>算法，复制算法效率只与当前存活对象大小有关，很适用于年轻代的回收。复制算法内存利用率不高的问题，通过HosSpot中的两个survivor的设计得到缓解。</p>
<p>$\bullet$ 老年代（Old Gen）<br><br>老年代区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。<br>由于存在大量存活率高的对象，复制算法不再适用，一般由<em>标记-清除和标记-整理算法混合实现</em> <strong>（CMS）</strong>。<br>CMS是基于标记-清除算法实现的，对对象的回收率很高，同时采用基于标记-整理算法的Serial Old回收器进行Full GC处理碎片问题。</p>
<h5 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h5><p>上述的算法在垃圾回收过程中会出现STW状态，增量收集算法让垃圾收集线程和应用程序线程交替执行。每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。<br>增量收集算法的基础是标记-清除和标记-复制算法，通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。<br><strong>缺点：</strong> 由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总成本上升，造成系统吞吐量下降。</p>
<h5 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h5><p>主要针对G1垃圾收集器，与增量收集算法一样，都是为了降低GC产生的停顿时间。堆空间很大时，GC需要的时间也长，通过将内存区域划分成多个region，每个region独立使用独立回收，每次合理地回收若干个region，而不是整个堆空间，从而减少一次GC所产生的的停顿。<br><strong>分代算法</strong> 按照对象的生命周期，将堆空间分为新生代和老年代两部分。<br><strong>分区算法</strong> 则将堆空间分成连续的region（有的region里放Eden区数据，有的region放survivor区数据，有的region放old gen数据，有的region放大对象(Humongous)）。</p>
<div align="center"><img src="/.io//region.png" width="80%"></div>


<h5 id="finalization机制"><a href="#finalization机制" class="headerlink" title="finalization机制"></a>finalization机制</h5><p>是对象被销毁之前的自定义处理逻辑，回收对象之前，先调用这个对象的finalize()方法，可以被重写，用于对象被回收时进行资源释放。<br>不要主动调用finalize()方法，应交给垃圾回收机制调用：①finalize()可能会导致对象复活；②finalize()方法的执行时间没有保证，完全由GC线程决定；③糟糕的finalize()会影响GC性能。</p>
<p><strong>对象的三种状态：</strong><br>$\bullet$ 可触及的：存在对这个对象的引用，即存活。<br><br>$\bullet$ 可复活的：对这个对象的所有引用都被释放，但在finalize()中可能复活（又出现了新的引用）。<br><br>$\bullet$ 不可触及的：finalize()调用后仍没有复活，该对象进入不可触及状态，一定要死亡，且finalize()只能调用一次。<br></p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>可以用过<code>-XX:+PrintCommandLineFlags</code>可以查看默认的垃圾回收器。或者通过命令行指令<code>jinfo -flag 相关垃圾回收器参数 进程ID</code>。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">&gt; jinfo -flag UseParallelGC <span class="number">924</span></span><br><span class="line">-XX:+UseParallelGC // +号表示正在使用           </span><br><span class="line">&gt; jinfo -flag UseParallelOldGC <span class="number">924</span></span><br><span class="line">-XX:+UseParallelGCOldGC</span><br><span class="line">&gt; jinfo -flag UseG1GC <span class="number">924</span></span><br><span class="line">-XX:-UseG1GC // -号表示没有使用</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。<br></p>
<div align="center"><img src="/.io//serial-parallel.png" width="80%"></div>

<p>串行垃圾回收指同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾回收结束。串行回收默认被应用在客户端的Client模式下的JVM中。<br>并行垃圾回收可以运用多个CPU同时执行垃圾回收，提升了应用的吞吐量，但与串行回收一样有STW独占停顿时间。<br>$\bullet$ 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。<br><br>并发式垃圾回收器与应用程序线程交替工作，以减少应用程序停顿时间。<br>独占式垃圾回收器（Stop-The-World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收完全结束。<br>$\bullet$ 按照碎片处理方式，可以分为压缩式垃圾回收器和非压缩式垃圾回收器。<br><br>$\bullet$ 按工作的内存空间分，分为年轻代垃圾回收器和老年代垃圾回收器。<br></p>
<h5 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h5><p><strong>Serial回收器</strong>采用复制算法、串行回收和Stop-The-World机制。是HotSpot中Client模式下的默认新生代垃圾回收器。<br><strong>Serial Old回收器</strong>采用标记-压缩算法，串行回收和Stop-The-World机制。Client模式下默认的老年代垃圾回收器。在Server模式下，①与Parallel Scavenge配合使用；②作为老年代CMS回收器的后备垃圾收集方案。<br><strong>优点：</strong> 简单、高效（与其他单线程GC相比）。<br><strong>缺点：</strong> 只会使用一个CPU或一条收集线程去完成垃圾收集工作，并STW。<br><strong>总结：</strong> 对于交互性强的应用不可接受，已经不使用。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC // 新生代使用Serial GC，老年代使用Serial Old GC</span><br></pre></td></tr></table></figure>

<h5 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h5><p>ParNew回收器是Serial回收器的多线程版本,Par代表并行，New代表新生代。<br>ParNew回收器采用复制算法，并行回收和Stop-The-World，是很多JVM在Server模式下默认的新生代垃圾回收器。（由于和ParNew组合使用的CMS和Serial Old已经废弃了，ParNew基本也不使用了）<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseParNewGC // 新生代使用ParNew GC</span><br></pre></td></tr></table></figure>
<h5 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h5><p><strong>Parallel Scavenge回收器</strong>采用复制算法，并行回收和Stop-The-World，在HotSpot中用于回收年轻代的垃圾。<br>与ParNew不同，Parallel Scavenge回收器目的是达到可控的吞吐量，并具有自适应调节策略。<strong>适用于</strong>后台运算、低交互的任务。<br><strong>Parallel Old回收器</strong>采用标记-压缩算法，并行回收和Stop-The-World，在JDK 1.6开始替代Serial Old成为老年代的默认回收器。<br>Parallel<br>Parallel Scavenge和Parallel Old的底层架构是自成一派的。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseParallelGC // 新生代使用Parallel GC</span><br><span class="line">-XX:+UseParallelOldGC // 老年代使用Parallel Old GC</span><br><span class="line">// 这两个参数，开启其中一个，另一个也会被激活</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads //设置年轻代并行回收器的线程数，一般与CPU数相等，CPU数量小于8，设置为CPU数量；CPU数量大于8，设置为3+(5*CPU_count)/8</span><br><span class="line"></span><br><span class="line">-XX:MaxGCPauseMillis // 设置垃圾回收器最大停顿时间（STW时间，单位毫秒）</span><br><span class="line">-XX:GCTimeRatio // 垃圾收集时间占总时间的比例</span><br><span class="line">// 这两个参数之间的关系也是此消彼长的</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy </span><br><span class="line">/* 设置Parallel Scavenge回收器自适应调节策略</span><br><span class="line">在这种模式下，年轻代的大小、Eden和Survivor的比例、</span><br><span class="line">晋升老年代的对象年龄等参数会被自动调整，</span><br><span class="line">已达到在堆大小、吞吐量和停顿时间之间的平衡点*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h5><p>CMS（Concurrent Mark Sweep）回收器是HotSpot中第一款真正意义上的并发垃圾回收器（非独占式），第一次实现了让垃圾收集线程和用户线程同时工作。<br>CMS采用标记-清除算法，并发回收和Stop-The-World，是老年代垃圾回收器。CMS尽可能的缩短GC时用户线程停顿时间，这种低延迟的特性适合强交互的应用。</p>
<h6 id="CMS工作流程分为4个阶段"><a href="#CMS工作流程分为4个阶段" class="headerlink" title="CMS工作流程分为4个阶段"></a>CMS工作流程分为4个阶段</h6><div align="center"><img src="/.io//cms.png"></div>

<p><strong>初始标记阶段（Init-Mark）：</strong> 执行STW，所有工作线程由于STW而短暂暂停，该阶段仅标记出GC Roots能直接关联到的对象。<br><strong>并发标记阶段（Concurrent-Mark）：</strong> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长但是不需要停顿用户线程，与垃圾收集线程一起并发运行。<br><strong>重新标记阶段（Remark）：</strong> 执行STW，由于在并发标记过程中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长，但比并发标记阶段时间段。<br><strong>并发清除阶段（Concurrent-Sweep）：</strong> 清理删除标记阶段判断的已经死亡的对象，释放内存空间，与用户线程并发。</p>
<p><strong>总结：</strong><br>①在并发标记阶段，用户线程还在继续执行，应确保用户线程有足够的内存可用，因此CMS不能像其他垃圾回收器一样等到老年代几乎被填满才进行回收，而是当堆内存使用率达到某一阈值时就开始进行回收，如果CMS运行期间预留的内存无法满足用户线程需要，会出现Concurrent Mode Failure，虚拟机临时启用Serial Old回收器作为后备方案，这时停顿时间会变长。<br>②由于CMS采用标记-清除算法，不可避免会产生内存碎片，需要使用空闲列表进行内存分配。之所以不采用标记-压缩算法是因为，在并发清除阶段，用户线程和垃圾回收线程是并发工作的，如果使用标记-压缩算法，会移动对象的位置，导致用户线程找不到对象。<br><strong>优点：</strong> 并发收集，低延迟。<br><strong>缺点：</strong> ①会产生内存碎片，可能导致提前触发Full GC；②对CPU资源敏感，CMS虽然不会停顿用户线程，但回收时会占用一部分CPU资源，导致用户线程变慢；③无法处理浮动垃圾。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC // 手动指定使用CMS</span><br><span class="line">// 开启该参数后会自动将-XX:+UseParNewGC打开，即</span><br><span class="line">// ParNew(Young Gen) + CMS(Old Gen) + Serial Old 的组合</span><br><span class="line"></span><br><span class="line">-XX:CMSInitiatingOccupanyFraction </span><br><span class="line">// 设置堆内存使用率的阈值，一旦达到该阈值，就开始回收</span><br><span class="line">// JDK 6及以后默认92%</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h5><p>为了适应不断扩大的内存和不断增加的处理器数量，G1垃圾回收器在JDK 7引入、JDK 9中代替了CMS成为默认的垃圾回收器。G1的目标是：在延迟可控的情况下获得尽可能高的吞吐量。</p>
<p>G1是并行回收器，它把堆内存分为很多不相关的区域（Region，物理上不连续），用不同的Region表示Eden、S0、S1、老年代。G1有计划的避免在整个Java堆上进行全区域的垃圾回收，通过跟踪各个Region里面垃圾堆积的价值大小（回收获得的空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许收集的时间，优先回收价值最大的Region。由于该方法侧重于回收垃圾最大的Region，所以称为Garbage First，G1。</p>
<h6 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h6><p><strong>并行与并发：</strong><br>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW。<br>并发性：G1可以与应用程序交替执行，部分工作可以和应用程序同时执行。一般来说不会在整个回收阶段发生完全阻塞应用程序的情况。<br><strong>分代收集：</strong><br>G1是分代型垃圾回收器，它不要求整个Eden、年轻代、老年代都是连续的，也不坚持固定的大小和固定的数量，而是使用Region代替。G1还增加了一种新的内存区域，叫做Humongous，主要用于存储大对象，如果超过1.5个Region，就放到H，如果一个H区装不下一个大对象，G1就会寻找连续的H区来存储。G1基本把H区看做老年代的一部分。<br>Region中包含了逻辑上的年轻代和老年代。<br>与之前的各类回收器不同，它同时兼顾年轻代和老年代的垃圾收集！</p>
<div align="center"><img src="/.io//region.png" width="80%"></div>

<p><strong>空间整合：</strong><br>G1执行的内存回收以Region为单位，Region之间是复制算法，但整体上可看作标记-压缩算法，避免了内存碎片，有利于大对象的分配。<br><strong>可预测的停顿时间模型（Soft Real-Time）：</strong><br>G1除了追求低停顿外，还建立了可预测的停顿时间模型，可以明确指定在一个M毫秒的时间片段内，消耗在垃圾收集上的时间不多于N毫秒（尽可能的，所以是Soft）。优先回收价值最大的Region。</p>
<p><strong>缺点：</strong> G1为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。小内存上CMS表现大概率优于G1，大内存上G1有优势，平衡点在6-8GB之间。</p>
<p><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseG1GC // 手动指定使用G1回收器</span><br><span class="line">-XX:G1HeapRegionSize // 设置每个Region大小，值是2的幂，范围1MB-32MB，默认为堆空间的1/2000</span><br><span class="line">-XX:MaxGCPauseMillis // 设置期望达到的最大GC停顿时间指标，默认200ms，过小会导致Full GC</span><br><span class="line">-XX:ParallelGCThread // 设置STW工作线程数，最大为8</span><br><span class="line">-XX:ConcGCThreads // 设置并发标记的线程数，为并行垃圾回收线程数（ParallelGCThreads）的1/4做左右</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=percent // 设置触发并发GC周期的Java堆占用率阈值，默认45%</span><br></pre></td></tr></table></figure>
<h6 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h6><p>主要包括3个环节<br><strong>年轻代GC（Young GC）：</strong> 先STW，年轻代Eden区用尽时开始年轻代回收，从年轻代区间移动存活对象到S0、S1或老年代区间，也有可能是两个区间都涉及。<br><strong>老年代并发标记过程（Concurrent Marking）：</strong> 堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。<br><strong>混合回收（Mixed GC）：</strong> 标记完成后马上开始混合回收过程。G1 GC从老年代区间移动存活对象到空闲区间，这些空闲区间也称为老年代的一部分。G1的老年代回收不需要回收整个老年代，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起回收的。<br><strong>（特殊情况下，用于提供一种失败保护机制）Full GC</strong></p>
<div align="center"><img src="/.io//g1.png" width="80%"></div>

<h6 id="G1的Remembered-Set（R-Set）"><a href="#G1的Remembered-Set（R-Set）" class="headerlink" title="G1的Remembered Set（R Set）"></a>G1的Remembered Set（R Set）</h6><p>一个Region中的对象可能被其他Region的对象所引用，这是否意味着判断对象存活时，需要扫描整个堆？<br>无论是G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描。每个Region都有一个对应的Remembered Set。R Set中记录指向该Region中对象的所有引用。<br>每次Reference类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作，检查要写入的Reference指向的对象与Reference是否在一个Region中，如果不同，通过CardTable把相关引用信息记录到Reference指向的对象所在Region对应的R Set中。<br>当进行垃圾收集时，在GC根节点的枚举范围内加入R Set，就可以保证不进行全局扫描也不会有遗漏。</p>
<div align="center"><img src="/.io//rset.png" width="80%"></div>

<p>JDK11中引入Epsilon垃圾回收器和ZGC（可伸缩的低延迟垃圾回收器）</p>
<h5 id="不同GC之间的组合关系"><a href="#不同GC之间的组合关系" class="headerlink" title="不同GC之间的组合关系"></a>不同GC之间的组合关系</h5><p>一共有7款<strong>经典</strong>的垃圾回收器（Garbage Collector）：</p>
<table>
<thead>
<tr>
<th></th>
<th>按工作方式分</th>
</tr>
</thead>
<tbody><tr>
<td>串行回收器</td>
<td>Serial、Serial Old</td>
</tr>
<tr>
<td>并行回收器</td>
<td>ParNew、Parallel Scavenge、Parallel Old</td>
</tr>
<tr>
<td>并发回收器</td>
<td>CMS、G1</td>
</tr>
</tbody></table>
<div align="center"><img src="/.io//gczuhe.png" width="80%"></div>


<table>
<thead>
<tr>
<th></th>
<th>按工作的内存空间分</th>
</tr>
</thead>
<tbody><tr>
<td>新生代回收器</td>
<td>Serial、ParNew、Parallel Scavenge</td>
</tr>
<tr>
<td>老年代回收器</td>
<td>Serial Old、Parallel Old、CMS</td>
</tr>
<tr>
<td>整堆回收器（新生代、老年代都能回收）</td>
<td>G1</td>
</tr>
</tbody></table>
<div align="center"><img src="/.io//gczuhe2.png" width="80%"></div>

<p><strong>——黑色实线</strong> 表示两个回收器可以搭配使用<br><br>$\color{red}- -红色虚线$ 表示JDK 8时将Serial+CMS、ParNew+Serial Old声明废弃，并在JDK 9中完全取消。<br><br>$\color{green}- -绿色虚线$ 表示在JDK 14中弃用Parallel Scavenge+SerialOld。<br><br>$\color{blue}- -青色虚线$ 表示在JDK 14中删除CMS。<br><br>CMS与Parallel Scavenge不兼容，CMS与Serial Old作为储备方案。不同的GC适用不同的场景，要妥善选择。</p>
<h5 id="GC的主要性能指标"><a href="#GC的主要性能指标" class="headerlink" title="GC的主要性能指标"></a>GC的主要性能指标</h5><p><strong>吞吐量（Throughput）：</strong> 运行用户代码的时间占总运行时间的比例。</p>
<p>$吞吐量={运行用户代码时间 \over 运行用户代码时间+垃圾收集时间}$</p>
<p>吞吐量优先，意味着在单位时间内，STW时间最短。<br><strong>暂停时间（Pause Time）：</strong> 执行垃圾收集时，程序的工作线程被暂停的时间。<br>暂停时间短一般回收频率高，延迟低。暂停时间和吞吐量之间的关系是此消彼长的，二者的折衷方案是，<strong>最大吞吐量优先的情况下，降低停顿时间</strong>。<br><strong>内存占用：</strong> Java堆区所占的内存大小。</p>
<h5 id="七种常见GC比较"><a href="#七种常见GC比较" class="headerlink" title="七种常见GC比较"></a>七种常见GC比较</h5><div align="center"><img src="/.io//7gc.png" width="100%"></div>

<h5 id="后起之秀"><a href="#后起之秀" class="headerlink" title="后起之秀"></a>后起之秀</h5><h6 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h6><p>Epsilon只做内存分配，不做垃圾回收。</p>
<h6 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h6><p>在OpenJDK 12引入，特点是低停顿时间，但吞吐量下降。由RedHat公司提出。</p>
<h6 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h6><p><a href="https://docs.oracle.com/en/java/javase/12/gctuning/">官方文档</a><br>在JDK 11引入，特点也是低停顿时间，仍处于Experimental阶段。<br>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现任意堆内存大小都可以把垃圾收集的停顿时间限制在10ms以内的低延迟。<br>ZGC是一款基于Region内存布局的，不设分代的（暂时），使用了读屏障、染色指针、内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。<br>ZGC的工作过程可以分为4个阶段：并发标记$\rightarrow$并发预备重分配$\rightarrow$并发重分配$\rightarrow$并发重映射。<br>ZGC几乎在所有地方都是并发执行的，除了初始标记是STW，所以停顿时间几乎就耗费在了初始标记上，这部分的实际时间是非常少的。</p>
<h5 id="GC日志打印"><a href="#GC日志打印" class="headerlink" title="GC日志打印"></a>GC日志打印</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log // 根目录是project</span><br></pre></td></tr></table></figure>
<p>常见的日志分析工具：GCViewer、<strong>GCEasy</strong></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾回收</tag>
        <tag>内存分配</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记2-字节码与类的加载</title>
    <url>/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<div align="center"><img src="/.io//1.JPG"></div>

<span id="more"></span>

<h2 id="字节码看代码执行细节"><a href="#字节码看代码执行细节" class="headerlink" title="字节码看代码执行细节"></a>字节码看代码执行细节</h2><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">//flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//inttest2.png" width="70%"></div>

<p>从上面的字节码文件中可以看到，<code>Integer x = 5</code>调用了<code>Integer</code>对象中的<code>valueOf</code>方法，<code>valueOf</code>方法中的<code>IntegerCache.cache</code>是<code>IntegerCache</code>方法中声明为全局常量的数组，数组大小为256，保存了$[-128, 127]$中的所有整数，如果<code>i</code>的值在该区间，直接从<code>IntegerCache.cache</code>数组中取出这个数，否则new一个<code>Integer</code>。</p>
<div align="center"><img src="/.io//inttest1.png" width="80%"></div>

<p><strong>Example1：</strong><br>① <code>5</code>在这个区间中，所以<code>x</code>指向的地址是<code>IntegerCache.cache</code>数组中<code>int</code>型数据<code>5</code>的位置，<code>Integer</code>本身有一个装箱的操作，所以<code>x</code>是一个引用数据类型。字节码文件中的<code>astore_1</code>表示<code>x</code>保存在了局部变量表索引为1的位置（索引为0的位置保存main方法的参数args）。</p>
<p>② <code>int y = 5</code>对基本数据类型<code>y</code>赋值<code>5</code>。一般情况下，引用数据类型和基本数据类型不能做<code>==</code>的操作，但是<code>x</code>又包含拆箱的操作，所以相当于取出了基本数据类型<code>5</code>与<code>y</code>进行比较，返回结果必然是<code>true</code>。</p>
<p><strong>Example2：</strong><br>由于<code>i1</code>和<code>i2</code>指向的都是<code>IntegerCache.cache</code>中<code>10</code>的位置，所以返回<code>true</code>。</p>
<p><strong>Example3：</strong><br>由于<code>i3</code>和<code>i4</code>赋值<code>128</code>超出了<code>IntegerCache.cache</code>的数组的范围，所以new了两个<code>Integer</code>对象，<code>i3</code>和<code>i4</code>指向了不同的索引地址，故返回<code>false</code>。</p>
<h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        String str2 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//stringtest2.png" width="100%"></div>

<div align="center"><img src="/.io//stringtest3.png" width="80%"></div>


<p><strong>Example1：</strong><br>上图中可以看到<code>str1</code>和<code>str2</code>指向的是两个完全不同的对象，所以判断<code>str1 == str2</code>会返回<code>false</code>。</p>
<p><strong>Example2：</strong><br>在<code>String str3 = new String(&quot;helloworld&quot;)</code>中，<code>new String()</code>会调用<code>StringBuilder.toString()</code>方法，内部<code>new</code>了一个<code>String</code>，故<code>str2 == str3</code>返回<code>false</code>。</p>
<h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Example1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Father();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"> * Father.x = 10</span></span><br><span class="line"><span class="comment"> * 20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//sontest1.png" width="100%"></div>


<p>成员变量（非静态）的赋值过程（按先后顺序排列）：①默认初始化 ②显示初始化/代码块中初始化 ③构造器中初始化 ④有了对象之后，可以<code>Object.prop</code>或<code>Object.method()</code>的方式初始化</p>
<figure class="highlight plaintext"><figcaption><span>f </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">**Example2:**</span><br><span class="line">```java</span><br><span class="line">public class SonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Father f = new Son();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line"> * Son.x = 0</span><br><span class="line"> * Son.x = 30</span><br><span class="line"> * 20</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//sontest2.png" width="100%"></div>

<p>代码<code>Father f = new Son()</code>首先new了一个Son对象，调用Son的构造器进行初始化前，先调用其父类对象Father的构造器<code>public Father()&#123;&#125;</code>，里面有<code>this.print()</code>，由于子类对象Son重写了父类对象Father的<code>print()</code>方法，所以实际调用的是Son中的<code>print()</code>，此时Son.x还没有复制，故打印<code>Son.x = 0</code>。父类构造器执行完后，再执行子类构造器，子类构造器对成员变量初始化之前，先有显示初始化方法<code>int x = 30</code>，故在子类构造器中<code>this.print()</code>打印<code>Son.x = 30</code>。最后执行<code>System.out.println(f.x)</code>，由于属性不存在多态性，<code>f.x</code>调用的是父类Father中的<code>x</code>，<code>Father.x</code>在父类构造器中最后被复制为<code>20</code>，故打印<code>20</code>。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><h3 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h3><p>字节码文件由源代码经编译器编译生成，里面是JVM指令，而与C、C++编译后直接生成机器码（这也是C、C++比Java快的原因）。</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）构成。虚拟机中的许多指令并不包含操作数，只有一个操作码。</p>
<div align="center"><img src="/.io//classfile1.png" width="80%"></div>

<h3 id="解读字节码文件"><a href="#解读字节码文件" class="headerlink" title="解读字节码文件"></a>解读字节码文件</h3><p>① Jclasslib（或IDEA中Jclasslib插件）<br>② javap指令：JDK自带的反解析工具 <code>javap -v Test.class</code>或<code>javap -v Test.class &gt; Test.txt</code><br>④ Binary Viewer<br>③ Notepad++中HEX-editor插件</p>
<h3 id="字节码文件格式"><a href="#字节码文件格式" class="headerlink" title="字节码文件格式"></a>字节码文件格式</h3><p>Class文件没有分隔符，其中的字节顺序、数量都被严格限制。<br>Class文件格式用类似C语言结构体的方式进行数据存储，这种结构只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<br>$\bullet$ 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br><br>$\bullet$ 表示由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明。</p>
<h3 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h3><p>字节码文件的基本结构和框架是非常稳定的，如下：</p>
<div align="center"><img src="/.io//classfilestruc.png"></div>

<p>以<strong>Demo.class</strong>的字节码文件为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Demo.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ind <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>编译Demo.class后得到的字节码文件：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ca	fe	ba	be	00	00	00	34	00	16	0a	00	04	00	12	09</span><br><span class="line">00	03	00	13	07	00	14	07	00	15	01	00	03	6e	75	6d</span><br><span class="line">01	00	01	49	01	00	06	3c	69	6e	69	74	3e	01	00	03</span><br><span class="line">28	29	56	01	00	04	43	6f	64	65	01	00	0f	4c	69	6e</span><br><span class="line">65	4e	75	6d	62	65	72	54	61	62	6c	65	01	00	12	4c</span><br><span class="line">6f	63	61	6c	56	61	72	69	61	62	6c	65	54	61	62	6c</span><br><span class="line">65	01	00	04	74	68	69	73	01	00	13	4c	63	6f	6d	2f</span><br><span class="line">63	6f	6d	70	61	6e	79	2f	44	65	6d	6f	31	3b	01	00</span><br><span class="line">03	61	64	64	01	00	03	28	29	49	01	00	0a	53	6f	75</span><br><span class="line">72	63	65	46	69	6c	65	01	00	0a	44	65	6d	6f	31	2e</span><br><span class="line">6a	61	76	61	0c	00	07	00	08	0c	00	05	00	06	01	00</span><br><span class="line">11	63	6f	6d	2f	63	6f	6d	70	61	6e	79	2f	44	65	6d</span><br><span class="line">6f	31	01	00	10	6a	61	76	61	2f	6c	61	6e	67	2f	4f</span><br><span class="line">62	6a	65	63	74	00	21	00	03	00	04	00	00	00	01	00</span><br><span class="line">02	00	05	00	06	00	00	00	02	00	01	00	07	00	08	00</span><br><span class="line">01	00	09	00	00	00	38	00	02	00	01	00	00	00	0a	2a</span><br><span class="line">b7	00	01	2a	04	b5	00	02	b1	00	00	00	02	00	0a	00</span><br><span class="line">00	00	0a	00	02	00	00	00	03	00	04	00	04	00	0b	00</span><br><span class="line">00	00	0c	00	01	00	00	00	0a	00	0c	00	0d	00	00	00</span><br><span class="line">01	00	0e	00	0f	00	01	00	09	00	00	00	3d	00	03	00</span><br><span class="line">01	00	00	00	0f	2a	2a	b4	00	02	05	60	b5	00	02	2a</span><br><span class="line">b4	00	02	ac	00	00	00	02	00	0a	00	00	00	0a	00	02</span><br><span class="line">00	00	00	06	00	0a	00	07	00	0b	00	00	00	0c	00	01</span><br><span class="line">00	00	00	0f	00	0c	00	0d	00	00	00	01	00	10	00	00</span><br><span class="line">00	02	00	11											</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//classfile2.jpg"></div>



<p>$\bullet$ 使用开头<strong>4个字节</strong>的无符号整数表示的<strong>魔数</strong>而不是扩展名来进行识别主要是基于安全性方面的考虑，因为文件扩展名可以随意地改动。魔数固定值为0xCAFEBABE，不会改变。如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出<code>ClassFormatError</code>。<br>$\bullet$ 之后的<strong>4个字节</strong>存储Class文件的<strong>版本号</strong>，第5、6个字节表示编译的副版本号<code>minor_version</code>，第7、8个字节表示编译的主版本号<code>major_version</code>。不同版本的Java编译器编译的Class文件对应的版本是不一样的，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行高版本编译器生成的Class文件，抛出<code>java.lang.UnsupportedClassVersionError</code>。<br>版本号和Java编译器的对应关系如下表：</p>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<p>$\bullet$ 版本号后的是<strong>常量池计数器</strong>（<strong>2个字节</strong>，容量计数从1开始，即constant_pool_count=1表示常量池中有0个常量项，而计数0表示不引用任何一个常量项） 和若干个常量池表项。常量池是整个Class文件的基石。<br>常量池<strong>主要</strong>存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。  </p>
<p>常量池中每一项常量都是一个表，JDK 1.7之后共有14种不同的表结构数据，如下所示：</p>
<div align="center"><img src="/.io//constant.jpg"></div>

<p>这14种表的共同点是：表开始的第一位是一个<code>u1</code>类型的的标志位<code>tag</code>，代表当前这个常量项使用的是哪种表结构。且除了<code>CONSTANT_Utf8_info</code>外其他常量项占用的字节数固定。</p>
<p>常量池是Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。<br></p>
<p>$\bullet$ 之后是<strong>访问标识（access_flag）</strong>，<strong>2个字节</strong>，用来识别一些类或者接口层次访问信息。</p>
<p>在<code>Demo.class</code>文件中<code>access_flag</code>的值为<code>0x0021</code>，是<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>的加和。</p>
<div align="center"><img src="/.io//accessflag.png" width="90%"></div>

<p>① 如果一个Class文件被设置了<code>ACC_INTERFACE</code>标志，那么同时也要设置<code>ACC_ABSTRACT</code>标志，并不能再设置<code>ACC_FINAL</code>、<code>ACC_SUPER</code>和<code>ACC_ENUM</code>。</p>
<p>② 如果没有设置<code>ACC_INTERFACE</code>标志，那么这个Class文件可以设置上表中除<code>ACC_ANNOTATION</code>以外的所有标志，但<code>ACC_FINAL</code>和<code>ACC_ABSTRACT</code>是互斥的不可同时设置。</p>
<p>③ 针对Java虚拟机指令集的编译器都应当设置<code>ACC_SUPER</code>。</p>
<p>④ 注解类型必须设置<code>ACC_ANNOTATION</code>标志。</p>
<p>$\bullet$ 访问标记后，会指定该<strong>类的类别、父类类别以及实现的接口</strong>，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>字段表集合</strong>用于描述接口或类中声明的变量，<strong>包括</strong>类级变量以及实例级变量，<strong>不包括</strong>方法内部、代码块内部声明的局部变量和从父类、实现的接口中继承的字段。字段表集合指向常量池索引的集合。<br>字段表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>其中，字段表访问标志：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>方法表集合</strong>指向常量池索引集合，描述每个方法的签名。字节码文件中每一个method_info都对应这一个类或者接口中的方法信息。methods表<strong>包括</strong>当前类或接口中的方法，<strong>不包括</strong>从父类或接口中继承的方法。<br>方法表结构与字段表一样，如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>访问标志：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法之能本类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>enum</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>属性表集合</strong>描述Class文件携带的辅助信息，通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p>
<p>以属性表的Code属性为例，Code属性表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>Code属性中还有<code>LineNumberTable</code>和<code>LocalVariableTable</code>两个内部属性。</p>
<h3 id="指令解析Class文件"><a href="#指令解析Class文件" class="headerlink" title="指令解析Class文件"></a>指令解析Class文件</h3><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><p>①<code>javac</code>、<code>javac -g</code>的区别：<br>使用<code>javac test.java</code>编译后得到的字节码文件不会生成对应的局部变量表等信息。<code>javac -g test.java</code>则可以。默认情况下，Eclipse和IEDA在编译时也会生成局部变量表、指令和代码行偏移量映射表等信息。</p>
<h4 id="反编译指令"><a href="#反编译指令" class="headerlink" title="反编译指令"></a>反编译指令</h4><p>使用<code>javap</code>或<code>javap -help</code>可以看到可用选项。</p>
<div align="center"><img src="/.io//javap.png"></div>

<p>使用<code>javap -v Demo.class &gt; Demo.txt</code>反解析字节码文件存入<code>Demo.txt</code>中：</p>
<div align="center"><img src="/.io//javap1.png"></div>

<div align="center"><img src="/.io//javap2.png"></div>

<h2 id="字节码指令-1"><a href="#字节码指令-1" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</p>
<p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。</p>
<p><strong>i</strong> 代表对 <strong>int</strong> 类型的数据操作<br><strong>l</strong> 代表 <strong>long</strong><br><strong>s</strong> 代表 <strong>short</strong><br><strong>b</strong> 代表 <strong>byte</strong><br><strong>c</strong> 代表 <strong>char</strong><br><strong>f</strong> 代表 <strong>float</strong><br><strong>d</strong> 代表 <strong>double</strong></p>
<p>由于大部分指令都没有支持整数类型byte、char、short和boolean，编译器会在编译期或运行期将byte和short类型的数据（和数组）带符号扩展为相应的int类型数据。</p>
<p>JVM中的字节码指令集按照用途大致可以分成9类：<br>$\bullet$ 加载与存储指令 <br><br>$\bullet$ 算术指令<br><br>$\bullet$ 对象的创建与访问指令<br><br>$\bullet$ 方法调用与返回指令<br><br>$\bullet$ 操作数栈管理指令<br><br>$\bullet$ 比较控制指令<br><br>$\bullet$ 异常处理指令<br><br>$\bullet$ 同步控制指令<br></p>
<h3 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h3><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。<br><strong>常用指令：</strong><br>① 带有<code>load</code>、<code>push</code>、<code>const</code>、<code>ldc</code>的指令都是把数据压入操作数栈。<br>② 带有<code>store</code>的指令都是把数据保存在栈帧的局部变量表中。</p>
<p><strong>局部变量压栈指令：</strong><br>将一个局部变量加载到操作数栈。<br>① <code>[x]load</code>、<code>[x]load_&lt;n&gt;</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>n</code><br>其中<code>n</code>为<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code><br>如<code>iload_3</code>、<code>iload 4</code> n </p>
<p><strong>常用入栈指令：</strong><br>将一个常量加载到操作数栈。<br>①<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_ml</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></p>
<p><strong>出栈装入局部变量表指令：</strong><br>将一个数值从操作数栈存储到局部变量表。<br>① <code>xstore</code>、<code>xstore_&lt;n&gt;</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>n</code><br>其中<code>n</code>为<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code><br>② <code>xastore</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>b</code>、<code>c</code>、<code>s</code></p>
<h4 id="复习：操作数栈与局部变量表"><a href="#复习：操作数栈与局部变量表" class="headerlink" title="复习：操作数栈与局部变量表"></a>复习：操作数栈与局部变量表</h4><div align="center"><img src="/.io//stackframe.png"></div>

<p><strong>操作数栈</strong>用于存放计算的操作数以及返回结果。执行每一条指令之前，Java虚拟机要求该指令的操作数已经被压入操作数栈中。执行指令时，Java虚拟机将该指令所需的操作数弹出，并将指令的结果压入栈中。<br><strong>局部变量表</strong>中存放计算的缓存结果。局部变量表中按照Slot进行划分，一个Slot可以存放4个字节的数据，且非静态方法中索引为0的位置存放this。</p>
<h4 id="局部变量表压栈指令"><a href="#局部变量表压栈指令" class="headerlink" title="局部变量表压栈指令"></a>局部变量表压栈指令</h4><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj, <span class="keyword">long</span> count, <span class="keyword">boolean</span> flag, <span class="keyword">short</span>[] arr)</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字节码指令：</strong></p>
<div align="center"><img src="/.io//loadandstore1.png"></div>

<h4 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h4><h5 id="const指令"><a href="#const指令" class="headerlink" title="const指令"></a>const指令</h5><p>整型：<code>iconst_&lt;i&gt;：i∈[-1, -5]，其中iconst_m1将-1压入栈</code><br>长整型：<code>lconst_&lt;l&gt;：l∈[0, 1]</code><br>float型：<code>fconst_&lt;f&gt;：f∈[0, 2]</code><br>double型：<code>dconst_&lt;d&gt;：d∈[0, 1]</code><br>null值：<code>aconst_null</code></p>
<h5 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h5><p><strong>bipush</strong> 接收8位整数作为参数 <strong>[-128, 127]</strong><br><strong>sipush</strong> 接收16位整数作为参数 <strong>[-32768, 32767]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushConstLdc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">1234567</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//loadandstore2.png" width="80%"></div>


<h5 id="ldc指令"><a href="#ldc指令" class="headerlink" title="ldc指令"></a>ldc指令</h5><p>以上指令都不满足需求的：<br>① 指向<code>int</code>、<code>float</code>、<code>String</code>的索引（8位），用<code>ldc</code>指令。<br>② 有两个8位参数，用<code>ldc_w</code>。<br>③ 对于<code>long</code>和<code>double</code>类型，用<code>ldc2_w</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constLdc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> c1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> c2 = <span class="number">2</span>;</span><br><span class="line">        Date d = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//loadandstore3.png" width="80%"></div>

<h4 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h4><p>这类指令主要以<code>store</code>指令形式存在。<br>① <code>xstore</code>（<code>x</code>为<code>i、l、f、d、a</code>）<br>② <code>xtore_n</code>（<code>x</code>为<code>i、l、f、d、a</code>，<code>n</code>为<code>0、1、2、3</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = k + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">12</span>;</span><br><span class="line">        String str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">10.0F</span>;</span><br><span class="line">        d = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="/.io//loadandstore4.png" width="80%"></div>

<h3 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h3><p><em>《深入理解Java虚拟机》P254</em></p>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。<br>算术指令可以分为两种：① 对整型数据进行运算的指令；② 对浮点型数据进行运算的指令。</p>
<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>比较指令的作用是比较栈顶两个元素的大小，并将比较的结果入栈。<br>比较指令有：<code>dcmpg、dcmpl、fcmpg、fcmpl、lcmp</code><br>其中首字符<code>d</code>表示double类型，<code>f</code>表示float类型，<code>l</code>表示long类型。只有数值类型的数据（byte\short\char\int；long\float\double）才能比大小，boolean和引用类型数据类型不能比较大小。<br><em>假如栈顶元素为v2，栈顶后一位元素为v1，如果v1=v2，压入0，如果v1&gt;v2，压入1，如果v1&lt;v2，压入-1。</em></p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p><em>《深入理解Java虚拟机》P255</em></p>
<p>① 类型转换指令可以将两种不同的数值类型进行相互转换。<br>② 一般用于用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>包括宽化类型转换和窄化类型转换，无论是哪种，当造成精度损失时，不会导致虚拟机异常。<br>注意：<code>byte、short、char</code>在内存中看做<code>int</code>型存储。</p>
<h3 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h3><p><em>《深入理解Java虚拟机》P256</em></p>
<h4 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h4><p>专门用于对象操作，可以进一步细分为创建指令、字段访问指令、数组操纵指令、类型检查指令。<br>① 创建类实例：<code>new</code><br>② 创建数组： <code>newarray（基本类型数组）、anewarray（引用类型数组）、multianewarray（多维数组）</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>] <span class="comment">// newarray 10 (int)</span></span><br><span class="line">Object[] objArray = <span class="keyword">new</span> Object[<span class="number">10</span>] <span class="comment">// anewarray #2 &lt;java/lang/Ojbect&gt;</span></span><br><span class="line"><span class="keyword">int</span>[][] mintArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>] <span class="comment">// multianewarray #6 &lt;[[I&gt; dim2 </span></span><br><span class="line">String[][] strArray = <span class="keyword">new</span> String[<span class="number">10</span>][] <span class="comment">// anewarray #7 &lt;[L java/lang/String;&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h4><p>① 访问类字段（static字段）的指令：<code>getstatci、putstatic</code><br>② 访问类实例字段（非static字段）的指令：<code>getfield、putfield</code></p>
<h3 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h3><p><em>《深入理解Java虚拟机》P257</em></p>
<h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h4><p>① <code>invokevirtual</code>最常见的方法分派方式。<br>② <code>invokeinterface</code>调用接口方法。<br>③ <code>invokespecial</code>调用实例初始化方法、私有方法和父类方法。<br>④ <code>invokestatic</code>调用类中的类方法（static方法）。<br>⑤ <code>invokedynamic</code>调用动态绑定的方法。</p>
<h4 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h4><p>① <code>ireturn、lreturn、freturn、dreturn、areturn</code><br>如果当前返回的是synchronized方法，还会执行一个隐含的<code>monitorexit</code>指令，退出临界区。</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p><em>《深入理解Java虚拟机》P256</em></p>
<p>① <code>pop</code>：将栈顶的1个Slot数值出栈。例如一个short类型数值。<br>② <code>pop2</code>：将栈顶的2个Slot数值出栈。例如一个double类型的数值，或者2个int类型的数值。<br>③ <code>dup、dup2、dup_x1、dup2_x1、dup_x2、dup_x2</code>：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。<br>其中<code>dup</code>开头用于复制1个Slot的数据，<code>dup2</code>开头用于复制2个Slot的数据。不带<code>_x</code>表示仅复制，带<code>_x</code>表示复制栈顶数据并压入栈，<code>dup</code>和<code>_x</code>的系数相加表示要插入的位置。如<code>dup2_x1</code>插入栈顶下2+1=3个Slot下面。<br>④ <code>swap</code>：将栈最顶端的两个Slot数值位置交换。<br>⑤ <code>nop</code>：它的字节码为0x00，什么都不做，用于调试和占位。</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>条件跳转指令通常和比较指令结合使用。<br>包括：<code>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull</code>，这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>栈顶int型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>栈顶int型数值不等于0时跳转</td>
</tr>
<tr>
<td>iflt</td>
<td>小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody></table>
<h4 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h4><p>包括<code>if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne</code>，其中<code>i</code>开头表示<code>int</code>型数据，<code>a</code>开头表示对象引用的比较。</p>
<h4 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h4><p>专为switch-case语句设计的，主要由<code>tableswitch</code>和<code>lookupswitch</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch语句跳转，case值连续，内部只存放起始值、终止值和若干偏移量，效率高</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch语句跳转，case值不连续，内部存放离散的case-offset对，每次需要搜索全部case-offset对，效率低</td>
</tr>
</tbody></table>
<h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p>① <code>goto</code>：接收2个字节的操作数，共同组成一个带符号的整数，用于指定执行的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈定</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td>
</tr>
</tbody></table>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p><em>《深入理解Java虚拟机》P258</em></p>
<h4 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h4><p>显式抛出异常：<code>athrow</code><br>自动抛出异常：<code>idiv、ldiv</code>等</p>
<h4 id="异常处理指令-1"><a href="#异常处理指令-1" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>处理异常不使用字节码指令实现的，而是采用异常表完成。<br>如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。如<br>① 起始位置<br>② 结束为止<br>③ 程序计数器记录的代码处理的偏移地址<br>④ 被捕获的异常类在常量池中的索引</p>
<p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧。不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</p>
<h3 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h3><p><em>《深入理解Java虚拟机》P258</em></p>
<p>Java虚拟机支持两种同步结构：① 方法级的同步；② 方法内部一段指令序列的同步。</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期分为以下7个阶段：</p>
<div align="center"><img src="/.io//classloadingp.png"></div>



<h3 id="过程1：Loading（加载）阶段"><a href="#过程1：Loading（加载）阶段" class="headerlink" title="过程1：Loading（加载）阶段"></a>过程1：Loading（加载）阶段</h3><p><em>《深入理解Java虚拟机》P267</em> </p>
<p>加载阶段Java虚拟机需要做以下三件事情：<br>① 通过一个类的全限定名来获取定义此类的二进制字节流。<br>② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>③ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p>另外，数组类本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的。</p>
<h3 id="过程2：Linking（链接）阶段"><a href="#过程2：Linking（链接）阶段" class="headerlink" title="过程2：Linking（链接）阶段"></a>过程2：Linking（链接）阶段</h3><p><em>《深入理解Java虚拟机》P268</em> </p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的目的是保证加载的字节码是合法、合理并符合规范的。包括：<br><strong>格式检查：</strong> 魔数检查，版本检查，长度检查。<br><strong>语义检查：</strong> 是否继承final，是否有父类，抽象方法是否有实现。<br><strong>字节码验证：</strong> 跳转指令是否指向正确位置，操作数类型是否合理。<br><strong>符号引用验证：</strong> 符号引用的直接引用是否存在。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段为类的<strong>静态变量</strong>分配内存，并将其初始化为默认值。<br>准备阶段<strong>不包括：</strong><br>① 对static final修饰的<strong>静态常量</strong>的情况，由于final在编译的时候就会分配了，准备阶段就会显式赋值。<br>② 实例变量的初始化，实例变量随着对象一起分配到Java堆中。<br>③ 代码执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkingTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> id; </span><br><span class="line">    <span class="comment">// 在准备阶段分配内存并初始化为默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 在编译阶段显式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String constStr1 = <span class="string">&quot;CONST&quot;</span>; </span><br><span class="line">    <span class="comment">// 在编译阶段显式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String conStr2 = <span class="keyword">new</span> String(<span class="string">&quot;CONST&quot;</span>); </span><br><span class="line">    <span class="comment">// 与上不同，而是使用&lt;clinit&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，对应boolean的默认值就是false。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>准备阶段后就进入了解析阶段，将类、接口、字段和方法的符号引用转为直接引用。</p>
<h3 id="过程3：Initialization（初始化）阶段"><a href="#过程3：Initialization（初始化）阶段" class="headerlink" title="过程3：Initialization（初始化）阶段"></a>过程3：Initialization（初始化）阶段</h3><p><em>《深入理解Java虚拟机》P277</em></p>
<p>类的初始化时类装载的最后一个阶段，前面的步骤都没问题就表示类可以顺利装载到系统中，此时类才会开始执行Java字节码。（即在初始化阶段才真正开始执行类中定义的Java程序代码）。</p>
<p>初始化阶段的重要工作室执行类的初始化方法<code>:&lt;clinit&gt;()</code>方法。该方法仅能由Java编译器生成并由JVM调用，它是由类静态成员的赋值语句以及static语句块合并产生的。</p>
<p><strong>说明：</strong><br>在加载一个类之前会先加载该类的父类，因此父类的<code>&lt;clinit&gt;</code>方法总是在子类<code>&lt;clinit&gt;</code>之前被调用。<br>在以下情况，字节码文件中不包含<code>&lt;clinit&gt;()</code>方法：<br>① 一个类中并没有声明任何的类变量，也没有静态代码块时。<br>② 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。<br>③ 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哪些场景不会生成 &lt;clinit&gt;()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span></span>&#123;</span><br><span class="line">    <span class="comment">// 场景1：对于非静态字段，不管是否进行显式赋值，都不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2：静态字段没有显示赋值也不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景3：static final修饰的基本数据类型字段在链接的准备阶段进行显式赋值，不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会生成&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于static final修饰的字段显式赋值的操作，赋值细节</span></span><br><span class="line"><span class="comment">// ① 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment">// ② 在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链接的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链接的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// ① 对于基本数据类型的字段来说，如果使用static final修饰，</span></span><br><span class="line"><span class="comment">//   则显示赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment">// ② 对于引用数据类型，如果使用字面量方式赋值，且用static final修饰，</span></span><br><span class="line"><span class="comment">//   则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment">// 排除上述的在链接阶段的准备环节赋值的情况，其他都在&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>&lt;clinit&gt;()</code>方法是带锁线程安全的。 </p>
<p>Java程序对类的初始化情况有两种，<strong>主动使用</strong>和<strong>被动使用</strong>。<strong>主动使用</strong>时<code>&lt;clinit&gt;()</code>方法就会被调用，<strong>被动使用</strong>时则不会被调用。</p>
<h4 id="类的主动使用："><a href="#类的主动使用：" class="headerlink" title="类的主动使用："></a>类的主动使用：</h4><p>① 当创建一个类时，比如new关键字，或者通过反射、克隆、反序列化。<br>② 当调用类的静态方法时，即当使用了字节码invokestatic指令。<br>③ 当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或putstatic指令。（对应访问变量、赋值变量操作）。<br>④ 当使用java.lang.reflect包中的（反射类）方法时。比如<code>Class.forName(&quot;com.company.java.Test&quot;)</code><br>⑤ 当初始化子类，如果发现其父类还没有进行过初始化，需要先触发其父类的初始化。<br>⑥ 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的初始化，该接口要在其之前被初始化。<br>⑦ 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<br>⑧ 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）。</p>
<h4 id="类的被动使用："><a href="#类的被动使用：" class="headerlink" title="类的被动使用："></a>类的被动使用：</h4><p>① 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化。<br>② 通过数组定义引用，不会触发此类的初始化。<br>③ 引用常量不会触发此类或接口的初始化。因为常量在链接阶段已经被显式赋值了。<br>④ 调用ClassLoader类的LoadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h3 id="过程4：类的Using（使用）"><a href="#过程4：类的Using（使用）" class="headerlink" title="过程4：类的Using（使用）"></a>过程4：类的Using（使用）</h3><p>任何一个类型在使用之前都必须经历<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>三个阶段。成功经历以上三个阶段的类型就可以等待被开发者使用了。</p>
<h3 id="过程5：类的Unloading（卸载）"><a href="#过程5：类的Unloading（卸载）" class="headerlink" title="过程5：类的Unloading（卸载）"></a>过程5：类的Unloading（卸载）</h3><h4 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h4><p>在类的加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类的加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>当Sample类被加载、链接和初始化后，它的生命周期就开始。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。<br>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<div align="center"><img src="/.io//classunload.png"></div>


<h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><p><strong>显示加载：</strong><br>在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。<br><strong>隐式加载：</strong><br>不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 隐式加载</span></span><br><span class="line">        User u = <span class="keyword">new</span> User(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示加载</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line">        &#125;cahtch(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p><strong>类的唯一性：</strong><br>对于任意一个类，需要由<strong>加载它的类加载器</strong>和<strong>这个类本身</strong>一起确认其在Java虚拟机中的唯一性。每一个类加载器都有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试伪代码</span></span><br><span class="line"><span class="keyword">public</span> UserClassLoader extends ClassLoader&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Sring rootDir = <span class="string">&quot;E:\\IDEA\\Demo\\src\\&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            UserClassLoader loader1 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz1 = loader1.findCLass(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            UserClassLoader loader2 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz2 = loader2.findClass(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(clazz1 == clazz2); <span class="comment">// false </span></span><br><span class="line">            System.out.println(clazz1.getClassLoader()); <span class="comment">// com.company.java.UserClassLoader@1540e19d</span></span><br><span class="line">            System.out.println(clazz2.getClassLoader()); <span class="comment">// com.company.java.UserClassLoader@14ae5a5</span></span><br><span class="line">            <span class="comment">// 显然两个加载器是不同的</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的加载器-1"><a href="#类的加载器-1" class="headerlink" title="类的加载器"></a>类的加载器</h3><p><em>《深入理解Java虚拟机》P282</em><br>在<em>JVM学习笔记-上篇</em>中已有介绍。</p>
<p>引导类加载器（Boostrap ClassLoader）<br>扩展类加载器（Extension ClassLoader）<br>应用程序类加载器（Application ClassLoader）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">//null，因为引导类加载器使用C/C++编写的，不会对应Java中的一个对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对于核心类库，使用的是引导类加载器，获取其ClassLoader打印也应该是null</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于用户自定义类，默认使用应用程序类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">&quot;com.company.ClassLoaderTest2&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对于数组，不把它看做类的结构，故不使用类加载器去加载</span></span><br><span class="line">            String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader()); <span class="comment">//null，getClassLoader()返回的是数组中元素类型的类加载器一样的（即String），表示使用的是引导类加载器</span></span><br><span class="line">            System.out.println(arrStr.getClass()); <span class="comment">//class [Ljava.lang.String;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双亲委托模式的弊端"><a href="#双亲委托模式的弊端" class="headerlink" title="双亲委托模式的弊端"></a>双亲委托模式的弊端</h4><p>检查类是否加载委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，引导类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用程序加载器中，为应用类。按照这种模式，应用类访问系统类是没有问题的，但是系统类访问应用类就会出现问题。比如在系统中提供了一个接口，该接口需要在应用类中得以实现，改接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在引导类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<h4 id="双亲委托模式的破坏"><a href="#双亲委托模式的破坏" class="headerlink" title="双亲委托模式的破坏"></a>双亲委托模式的破坏</h4><p><em>《深入理解Java虚拟机》P285</em></p>
<h4 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h4><p>热替换是指在程序运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现在正在运行的系统之上。<br>Java中通过使用ClassLoader来实现热替换。</p>
<div align="center"><img src="/.io//hotexchange.png"></div>
 

<h3 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h3><p>① 扩展机制被移除，扩展类加载器由于向后兼容性的问题被保留，不过被重命名为平台类加载器（Platform Classloader）。可以通过ClassLoader的新方法<code>getPlatformClassLoader()</code>来获取。<br>② 平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在引导类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>。<br>③ 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器名称在调试时很有用。<br>④ 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但是为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。<br>⑤ 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>字节码</tag>
        <tag>类</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Start from Hexo. Chapter 1</title>
    <url>/2020/12/01/Start-from-hexo/</url>
    <content><![CDATA[<p>这是一个自己搭建<em>Hexo</em>博客的记录，踩过的坑和耍过的花样都在这里！</p>
<div align="center"><img src="/.io//a.jpg"></div>

<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Nodejs-和-Hexo"><a href="#Nodejs-和-Hexo" class="headerlink" title="Nodejs 和 Hexo"></a>Nodejs 和 Hexo</h3><p>在安装<em>Hexo</em>之前，<a href="https://nodejs.org/en/">点这里</a>下载并安装<em>Nodejs</em>。</p>
<div align="center"><img src="/.io//nodejs.png" width="80%"></div>

<p>在<em>windows</em>系统下，打开<em>cmd</em>，使用<code>node -v</code>和<code>npm -v</code>查看这两个是否安装成功。</p>
<div align="center"><img src="/.io//nodeandnpm.png" width="50%"></div>

<p>之后，利用安装好的<em>npm</em>来安装<em>cnpm</em>（淘宝的一个镜像源）。<br><code>&gt; npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<p>最后用<br><code>&gt; cnpm install -g hexo-cli</code><br>安装Hexo。</p>
<div align="center"><img src="/.io//hexo.png" width="50%"></div>


<h3 id="搭建Blog"><a href="#搭建Blog" class="headerlink" title="搭建Blog"></a>搭建Blog</h3><p>新建一个文件夹<em>test-blog</em>，作为博客的根目录，在该根目录下，运行<em>cmd</em>，使用<code>hexo init</code>初始化。</p>
<div align="center"><img src="/.io//hexo-init.png" width="50%"></div>

<p>克隆到本地的初始化框架自带<em>landscape</em>主题，是可以用<code>hexo s</code>直接启动的。</p>
<div align="center"><img src="/.io//hexo-s.png" width="50%"></div>

<p>在浏览器中打开端口<code>localhost:4000</code>，就可以看到一个博客页面。</p>
<div align="center"><img src="/.io//landscape-blog.png"></div>


 
<h3 id="更换Blog主题"><a href="#更换Blog主题" class="headerlink" title="更换Blog主题"></a>更换Blog主题</h3><p><em>Hexo</em>官方网站上有很多收集的<a href="https://hexo.io/themes/"><em>Hexo</em>主题</a></p>
<p>以经典的<em>NexT</em>主题为例，在<a href="https://github.com/next-theme/hexo-theme-next"><em>Github-theme-next</em></a>上<em>clone</em>下来。在博客根目录下打开<em>Git</em>。</p>
<p>使用<br><code>&gt; git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p>
<p>将<em>NexT</em>主题<em>clone</em>到<em>themes</em>下的<em>next</em>文件夹中，但是这个过程会非常慢，在链接中<em>github.com</em>后面加上<code>cnpmjs.org</code>可以更换源。即</p>
<p><code>&gt; git clone https://github.com.cnpm.org/next-theme/hexo-theme-next themes/next</code></p>
<div align="center"><img src="/.io//git-clone-next.png" width="80%"></div>

<p>然后，打开根目录下的 <em>_config.yml</em> 文件，将<em>theme</em>改为<em>next</em>。</p>
<div align="center"><img src="/.io//theme-next.png" width="60%"></div>

<p>在<em>cmd</em>中，先后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; hexo clean</span><br><span class="line">&gt; hexo g</span><br><span class="line">&gt; hexo s</span><br></pre></td></tr></table></figure>
<p>再次打开<code>localhost:4000</code>，可以看到<em>next</em>主题下的博客。</p>
<div align="center"><img src="/.io//next-blog.png"></div>

<h3 id="将Hexo部署到服务器"><a href="#将Hexo部署到服务器" class="headerlink" title="将Hexo部署到服务器"></a>将Hexo部署到服务器</h3><p>服务器选用<em>Github</em>的个人仓库 <em>(Repositories)<em>，首先登陆</em>Github</em>，新建一个<em>Repositories</em>，<strong>仓库的名称一定要写成：</strong><code>Github_id.github.io</code></p>
<div align="center"><img src="/.io//github-repo.png" width="80%"></div>

<p>之后我们要将本地的博客部署到这个仓库中，第一次部署时需要安装<em>Hexo</em>部署组件，在<em>cmd</em>中：</p>
<p><code>&gt; cnpm install --save hexo-deployer-git</code></p>
<div align="center"><img src="/.io//deployer-install.png" width="80%"></div>

<p>另外，还需要在根目录下的 <em>_config.yml</em> 文件中，添加部署的参数：</p>
<div align="center"><img src="/.io//deployment.png" width="80%"></div>

<p>在<em>cmd</em>中，执行：</p>
<p><code>&gt; hexo d</code></p>
<p>（<strong>注意</strong>在初次部署时，要使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git config --global user.email &quot;your%example.com&quot;</span><br><span class="line">&gt; git config --global user.name &quot;your name&quot;</span><br></pre></td></tr></table></figure>
<p>初始化一下。）<br>在<em>Github</em>上的仓库中可以看到文件已经部署上去了。</p>
<div align="center"><img src="/.io//github-deployment.png"></div>



<p>在浏览器中打开 <a href="https://givme1sec.github.io,就可以访问热乎出炉的博客啦!/">https://givme1sec.github.io，就可以访问热乎出炉的博客啦！</a></p>
<div align="center"><img src="/.io//givme1sec-1.png"></div>
]]></content>
      <categories>
        <category>杂技</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/08/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>[复习]算法分析与设计-分治篇</title>
    <url>/2020/12/08/%E5%A4%8D%E4%B9%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p><strong>分治法</strong>能解决的问题通常具有以下几个特征：<br>（1）该问题的规模缩小到一定程度就可以很轻易的解决；<br>（2）该问题可以分解为若干个较小规模的相同问题，即该问题具有最优子结构性质；<br>（3）利用该问题分解出的子问题的解可以合并为该问题的解；<br>（4）该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<div align="center"><img src="/.io//a.jpg"></div>

<span id="more"></span>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>对于一个有序的数组（从小到大排列），二分查找可以根据数组的索引大大减少查找所需要的<strong>比较次数</strong>。在查找时，我们先将被查找的键和子数组的中间键比较，如果被查找的键小于中间键，我们就在左子数组继续查找，如果大于我们就在右子数组中进行查找，否则中间键就是我们要找的键。</p>
<h3 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt; lo) <span class="keyword">return</span> lo;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>; <span class="comment">//(lo+hi)/2可能会导致溢出</span></span><br><span class="line">    <span class="comment">// 查找的键小于中间键，则继续查找左子数组</span></span><br><span class="line">    <span class="keyword">if</span>(arr[key] &lt; arr[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key, lo, mid-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找的键大于中间键，则继续查找右子数组</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[key] &gt; arr[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(key, mid+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则中间键就是要查找的键</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代方式实现"><a href="#迭代方式实现" class="headerlink" title="迭代方式实现"></a>迭代方式实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = key.length-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 退出条件为 lo &gt; hi</span></span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[key] &lt; arr[mid])&#123;</span><br><span class="line">            hi = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[key] &gt; arr[mid])&#123;</span><br><span class="line">            lo = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对二分查找的分析"><a href="#对二分查找的分析" class="headerlink" title="对二分查找的分析"></a>对二分查找的分析</h3><p>在N个键的有序数组中进行二分查找最多需要（lgN+1)次比较（无论是否成功）。<br>时间复杂度<code>O(lgN)</code></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>要将一个数组排序，可以先（递归的）将它分成两半分别排序，然后将结果归并起来。归并排序可以保证将任意长度为N的数组排序所需的时间和NlogN成正比；它的主要缺点是它所需的额外空间和N成正比。</p>
<h3 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h3><p>原地归并的方法，如果不使用辅助空间，虽然有方法可以做到，但是实现都非常复杂；如果使用额外的辅助空间，则几行代码就可以实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用一个和数组a一样大的辅助数组aux</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将a[lo..mid]和a[mid+1..hi]归并</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将a[lo..hi]复制到aux[lo..hi]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        <span class="comment">// 左半边用尽（取右半边）</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)                   a[k] = aux[j++];</span><br><span class="line">        <span class="comment">// 右半边用尽（取左半边）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(h &gt; hi)               a[k] = aux[i++];</span><br><span class="line">        <span class="comment">// 右半边的元素小于左半边的元素（取右半边）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j], aux[i])) a[k] = aux[j++];</span><br><span class="line">        <span class="comment">// 右半边的元素大于等于左半边的元素（取左半边）</span></span><br><span class="line">        <span class="keyword">else</span>                          a[k] = aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="自顶向下归并"><a href="#自顶向下归并" class="headerlink" title="自顶向下归并"></a>自顶向下归并</h3><p>如果它能将两个子数组排序，那它就能通过归并两个子数组来将整个数组排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">public</span> Comparable[] aux;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 将数组a[lo..hi]排序</span></span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(NlogN)</code></p>
<h3 id="自底向上归并"><a href="#自底向上归并" class="headerlink" title="自底向上归并"></a>自底向上归并</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeBU</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux; <span class="comment">//归并所需的辅助数组</span></span><br><span class="line">    <span class="comment">// merge()代码见原地归并的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz+sz)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo += sz+sz)&#123;</span><br><span class="line">                merge(a, lo, lo+sz-<span class="number">1</span>, Math.min(lo+sz+sz-<span class="number">1</span>, N-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自底向上的归并会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小sz的初始值为1，每次加倍。最后一个子数组的大小只有在数组大小是sz的偶数倍的时候才会等于sz（否则它会sz小）<br>时间复杂度<code>O(NlogN)</code></p>
<h4 id="习题：利用归并排序计算数组中逆序对数"><a href="#习题：利用归并排序计算数组中逆序对数" class="headerlink" title="习题：利用归并排序计算数组中逆序对数"></a>习题：利用归并排序计算数组中逆序对数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">public</span> Comparable aux[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">public</span> <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 此时左半部分和右半部分都是排序好的</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++];</span><br><span class="line">            <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="comment">// 左半边元素大于右半边元素时，aux[j]要比aux[i:mid]都小，逆序对数为 mid-i+1</span></span><br><span class="line">            <span class="keyword">if</span>(aux[j] &lt; aux[i])&#123;</span><br><span class="line">                a[k] = aux[j++];</span><br><span class="line">                cnt += (mid-i+<span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">while</span>(hi &gt; lo)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi-lo)/<span class="number">2</span>;</span><br><span class="line">            sort(a, lo, mid);</span><br><span class="line">            sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">            merge(a, lo, mid, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(Comparable a[])</span></span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt; <span class="comment">// cnt即为逆序对数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是一种原地排序算法（只需要一个很小的辅助栈），且将长度为N的数组排序所需的时间和NlgN成正比。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quick</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        StdRandom.shuffle(a); <span class="comment">// 消除对输入的依赖</span></span><br><span class="line">        sort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j);</span><br><span class="line">        sort(a, j+<span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切分函数<code>partition()</code>方法将<code>a[j]</code>放到排序后的最终位置，且左边的元素都不大于<code>a[j]</code>，右边的元素都不小于<code>a[j]</code>。</p>
<p>一般的策略是先随意的选取<code>a[j]</code>，作为<em>切分元素</em>，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始扫描找到一个小于等于它的元素。这两个元素显然是没有排定的，因此我们交换他们的位置（由此也可看出快速排序是不稳定的）。如此继续，我们可以保证左指针<code>i</code>的左侧元素都不大于切分元素，右指针<code>j</code>的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素<code>a[lo]</code>和左子数组最右侧的元素（<code>a[j]</code>）交换然后返回<code>j</code>即可。</p>
<h3 id="快速排序的切分"><a href="#快速排序的切分" class="headerlink" title="快速排序的切分"></a>快速排序的切分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi+<span class="number">1</span>;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束并交换元素</span></span><br><span class="line">        <span class="keyword">while</span>(a[++i] &lt; v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[--j] &gt; v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        exch(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    exch(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(NlogN)</code></p>
<h4 id="习题：求第k小的元素（线性选择时间）"><a href="#习题：求第k小的元素（线性选择时间）" class="headerlink" title="习题：求第k小的元素（线性选择时间）"></a>习题：求第k小的元素（线性选择时间）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class Comparable <span class="title">select</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-p &lt; <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="comment">//用某个简单排序算法对数组a[p:r]排序</span></span><br><span class="line">        bubbleSort(p, r);</span><br><span class="line">        <span class="keyword">return</span> a[p+k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将a[p+5*i]至a[p+5*i+4]的第3小元素与a[p+i]交换位置；</span></span><br><span class="line">    <span class="comment">// 找中位数的中位数，r-p-4即上面的n-5</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (r-p-<span class="number">4</span>)/<span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = p+<span class="number">5</span>*i, i = s+<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) bubble(s, t-j);</span><br><span class="line">        swap(a, p+i, s+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Comparable x = select(p, p+(r-p-<span class="number">4</span>)/<span class="number">5</span>, (r-p+<span class="number">6</span>)/<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> i = partition(p, r, x), j = i-p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= j) <span class="keyword">return</span> select(p, i, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> select(i+<span class="number">1</span>, r, k-j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n&gt;=75时，O(n)<br>n&lt;75时， C</p>
<h4 id="习题：循环赛日程表"><a href="#习题：循环赛日程表" class="headerlink" title="习题：循环赛日程表"></a>习题：循环赛日程表</h4><p>设有$n=2^{k}$个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表。<br>（1）每个选手 必须与其他n-1个选手各赛一场；<br>（2）每个选手每天只能赛一次；<br>（3）循环赛一共进行n-1天。</p>
<p><strong>问题分析：</strong><br>设表被划分为4个区域：<br>$\color{red}{区域1}$&emsp;$\color{green}{区域2}$<br><br>$\color{green}{区域3}$&emsp;$\color{red}{区域4}$<br></p>
<p>当k=1时，2个运动员，日程表为<br>$\color{red}{1}$&emsp;$\color{green}{2}$<br><br>$\color{green}{2}$&emsp;$\color{red}{1}$<br></p>
<p>当k=2时，4个运动员，日程表为<br>$\color{red}{1}$&emsp;$\color{red}{2}$&emsp;$\color{green}{3}$&emsp;$\color{green}{4}$<br><br>$\color{red}{2}$&emsp;$\color{red}{1}$&emsp;$\color{green}{4}$&emsp;$\color{green}{3}$<br><br>$\color{green}{3}$&emsp;$\color{green}{4}$&emsp;$\color{red}{1}$&emsp;$\color{red}{2}$<br><br>$\color{green}{4}$&emsp;$\color{green}{3}$&emsp;$\color{red}{2}$&emsp;$\color{red}{1}$<br></p>
<p>当k=3时，8个运动员，日程表为<br>$\color{red}{1}$&emsp;$\color{red}{2}$&emsp;$\color{red}{3}$&emsp;$\color{red}{4}$&emsp;$\color{green}{5}$&emsp;$\color{green}{6}$&emsp;$\color{green}{7}$&emsp;$\color{green}{8}$<br><br>$\color{red}{2}$&emsp;$\color{red}{1}$&emsp;$\color{red}{4}$&emsp;$\color{red}{3}$&emsp;$\color{green}{6}$&emsp;$\color{green}{5}$&emsp;$\color{green}{8}$&emsp;$\color{green}{7}$<br><br>$\color{red}{3}$&emsp;$\color{red}{4}$&emsp;$\color{red}{1}$&emsp;$\color{red}{2}$&emsp;$\color{green}{7}$&emsp;$\color{green}{8}$&emsp;$\color{green}{5}$&emsp;$\color{green}{6}$<br><br>$\color{red}{4}$&emsp;$\color{red}{3}$&emsp;$\color{red}{2}$&emsp;$\color{red}{1}$&emsp;$\color{green}{8}$&emsp;$\color{green}{7}$&emsp;$\color{green}{6}$&emsp;$\color{green}{5}$<br><br>$\color{green}{5}$&emsp;$\color{green}{6}$&emsp;$\color{green}{7}$&emsp;$\color{green}{8}$&emsp;$\color{red}{1}$&emsp;$\color{red}{2}$&emsp;$\color{red}{3}$&emsp;$\color{red}{4}$<br><br>$\color{green}{6}$&emsp;$\color{green}{5}$&emsp;$\color{green}{8}$&emsp;$\color{green}{7}$&emsp;$\color{red}{2}$&emsp;$\color{red}{1}$&emsp;$\color{red}{4}$&emsp;$\color{red}{3}$<br><br>$\color{green}{7}$&emsp;$\color{green}{8}$&emsp;$\color{green}{5}$&emsp;$\color{green}{6}$&emsp;$\color{red}{3}$&emsp;$\color{red}{4}$&emsp;$\color{red}{1}$&emsp;$\color{red}{2}$<br><br>$\color{green}{8}$&emsp;$\color{green}{7}$&emsp;$\color{green}{6}$&emsp;$\color{green}{5}$&emsp;$\color{red}{4}$&emsp;$\color{red}{3}$&emsp;$\color{red}{2}$&emsp;$\color{red}{1}$<br></p>
<p>以此类推，可以用分治的方法自顶向下分解，直到分解到最简单的情况，即人数为2人，这时就可以两两比赛。（区域1复制到区域4，区域2复制到区域3）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Roundrobin</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] table(<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>&lt;&lt;k; <span class="comment">// 1左移k位，高位截取，低位补0,得到2^k</span></span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建赛程表第一行数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            a[<span class="number">0</span>][i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">1</span>; row &lt; n; row &lt;&lt;= <span class="number">1</span>)&#123; <span class="comment">// row左移1位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>*r)&#123;</span><br><span class="line">                copy(a, <span class="number">0</span>, i, row, row+i, row); <span class="comment">// 区域1复制到区域4</span></span><br><span class="line">                copy(a, <span class="number">0</span>, row+i, row, i, row); <span class="comment">// 区域2复制到区域3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> fromx, <span class="keyword">int</span> fromy, <span class="keyword">int</span> tox, <span class="keyword">int</span> toy, <span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)&#123;</span><br><span class="line">                a[tox + i][toy + j] = a[fromx + i][fromy + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] a = table(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;a[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                System.out.print(a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!--
## 最接近点对
给定平面上```n```个点，找其中的一对点，使得在```n```个点的所有点对中，该点对的距离最小。
严格的说，最接近点对可能多于1对。为了简单起见，这里只限找出其中的一对。
用**暴力法**很容易想出解决方法，求出每个点到其他```n-1```个点的距离，取其中最小即可，但是效率很低，时间复杂度为$O(N^{2}$)。
用**分治法**则可以取得该问题的时间下界$O(NlogN)$， 
### 一维空间下的最接近点对
集合```S```为一条坐标轴x上的```n```个点的集合，用某个点```m```将集合```S```划分为```S1```和```S2```两个子集合，使```S1={x∈S|x<=m}```，```S2={x∈S|x>m}```,对于所有的```p∈S1```和```q∈S2```

### 二维空间下的最接近点对
-->]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>[复习]算法分析与设计-动态规划篇</title>
    <url>/2020/12/11/%E5%A4%8D%E4%B9%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><strong>基本思想</strong>：问题的最优解如果可以由子问题的最优解推导得到，则可以先求子问题的最优解，再构造原问题的最优解；若子问题有<strong>较多的重复出现</strong>，则可以<strong>自底向上</strong>从最终子问题向原问题逐步求解。</p>
<div align="center"><img src="/.io//a.jpg"></div>

<span id="more"></span>

<h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><p>给定<code>n</code>个矩阵{A$_1$, A$_2$,…, A$_n$}，其中A$<em>i$与A$</em>{i+1}$是可乘的，i=1, 2,…, n-1，如何确定计算矩阵连乘积的计算次序，使得依此次序计算矩阵连乘积所需要的数乘次数最少。<br>例如，给定三个连乘矩阵{A$_1$, A$_2$, A$_3$}的维数分别为10×100,100×5,5×50，采用(A$_1$A$_2$)A$_3$，乘法次数为10×100×5+10×5×50=7500次，而采用A$_1$(A$_2$A$_3$)，乘法次数为100×5×50+10×100×50=75000次。显然，最好的次序是(A$_1$A$_2$)A$_3$，乘法次数为7500次。</p>
<p><strong>问题分析</strong>：<br>将矩阵连乘积A$<em>i$A$</em>{i+1}$…A$_j$简记为<code>A[i: j]</code>。对于计算<code>A[1: n]</code>的最优计算次序，设这个计算次序在A$<em>k$和A$</em>{k+1}$之间断开，$1≤k≤n$，即(A$_1$…A$<em>k$)(A$</em>{k+1}$…A$_n$)。以此次序，总的计算量为<code>A[1: k]</code>的计算量加上<code>A[k+1, n]</code>的计算量，再加上<code>A[1: k]</code>和<code>A[k+1, n]</code>相乘的计算量。<br>这个问题的关键特征是，计算<code>A[1: n]</code>的最优次序所包含的计算矩阵子链<code>A[1: k]</code>和<code>A[k+1, n]</code>的次序也是最优的。因此，矩阵连乘积计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。</p>
<p><strong>建立递推关系</strong>：<br>设<code>m[i, j]</code>是矩阵链A$<em>i$…A$<em>j$的最优解的代价，则：<br>$$ m[i][j]=\left{<br>\begin{aligned}<br>0 \qquad\qquad\qquad\qquad\qquad\qquad &amp; i = j \<br>\min</em>{\substack{i \le k \lt j}} {m[i][k] + m[k+1][j] + p</em>{i-1}p_kp_j } \qquad &amp; i \lt j<br>\end{aligned}<br>\right.<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**构建辅助表，解决重叠子问题**：</span><br><span class="line">从第二部的递归式可以发现解的过程中会有很多的重叠子问题，可以用一个辅助表```s[n][n]```来表示分割位置```k```。</span><br><span class="line">这里使用自底向上的方法构建```s[i][j]```，按照递增的方式逐步填写子问题的解（先计算长度为2的所有矩阵链的解，再计算长度为3的矩阵链的解，以此类推）。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void MatrixChain(int *p, int n, int **m, int **s)&#123;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++) </span><br><span class="line">        m[i][i] = 0;</span><br><span class="line">    for(int r = 2;, r &lt;= n; r++)&#123;</span><br><span class="line">        int j = i+r-1;</span><br><span class="line">        m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j];</span><br><span class="line">        s[i][j] = i;</span><br><span class="line">        for(int k = i+1; k &lt; j; k++)&#123;</span><br><span class="line">            int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];</span><br><span class="line">            if(t &lt; m[i][j])&#123;</span><br><span class="line">                m[i][j] = t;</span><br><span class="line">                s[i][j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Traceback按算法MaxChain计算出的</span><br><span class="line">// 断点矩阵s指示的加括号方式输出计算A[i:j]的最优计算次序，</span><br><span class="line">// 要输出A[1:n]的最优计算次序，</span><br><span class="line">// 只要调用Trackback(1, n , s)即可</span><br><span class="line">publit static void Trackback(int i, int j, int **s)&#123;</span><br><span class="line">    if(i == j)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    Traceback(i, s[i][j], s);</span><br><span class="line">    Traceback(s[i][j] + 1, j, s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列$X={x_1, x_2,…, x_m}$，则另一序列$Z={z_1, z_2,…, z_k }$，是$X$的子序列是指存在一个<strong>严格递增下标序列</strong>${i_1, i_2,…, i_k}$使得对于所有$j=1, 2,…, k$，有：$z_j = x_{ij}$。例如，序列$Z={B, C, D, B}$是序列$X={A, B, C, B, D, A, B}$的子序列，相应的递增下标序列为${2, 3, 5, 7}$。</p>
<p><strong>最长公共子序列问题</strong>：给定两个序列$X={x_1, x_2,…, x_m}$和$Y={y_1, y_2,…, y_n }$，找出$X$和$Y$的最长公共子序列。</p>
<p><strong>子问题的递归结构</strong>：<br>由最长公共子序列问题的最优子结构性质可知，要找出$X={x_1, x_2,…, x_m}$和$Y={y_1, y_2,…, y_n }$的最长公共子序列，可按以下方式递归地进行：当$x_m=y_n$时，找出$X_{m-1}$和$Y_{n-1}$的最长公共子序列，然后在其尾部加上$x_m$（$x_m=y_n$），即可得$X$和$Y$的最长公共子序列。当$x_m \neq y_n$时，必须解两个子问题，即找出$X_{m-1}$和$Y$的一个最长公共子序列及$X$和$X$和$Y_{n-1}$的一个最长公共子序列。这两个公共子序列中较长者即为$X$和$Y$的最长公共子序列。</p>
<p>$$ c[i][j]=\left{<br>\begin{aligned}<br>0 \qquad \qquad \qquad \qquad &amp; i \gt 0 ; j = 0 \<br>c[i-1][j-1]+1 \qquad \qquad &amp; i, j \gt 0; x_i=y_i \<br>\max {c[i][j-1], c[i-1][j]} \qquad &amp; i, j \gt 0; x_i \neq y_i<br>\end{aligned}<br>\right.<br>$$</p>
<p><strong>计算最优值</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LCSLength</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">char</span> *x, <span class="keyword">char</span> *y, <span class="keyword">int</span> **c, <span class="keyword">int</span> **b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n, i++)&#123;</span><br><span class="line">        c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m, i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i] == y[j])&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                b[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[i-<span class="number">1</span>][j] &gt;= c[i][j-<span class="number">1</span>])&#123;</span><br><span class="line">                c[i][j] = c[i-<span class="number">1</span>][j];</span><br><span class="line">                b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c[i][j] = c[i][j-<span class="number">1</span>];</span><br><span class="line">                b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造最长公共子序列</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span> *x, <span class="keyword">int</span> **b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        LCS(i-<span class="number">1</span>, j-<span class="number">1</span>, x, b);</span><br><span class="line">        System.out.print(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j] == <span class="number">2</span>)</span><br><span class="line">        LCS(i-<span class="number">1</span>, j, x, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LCS(i, j-<span class="number">1</span>, x, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定$n$种物品和一背包。物品$i$的重量是$w_i$，其价值为$v_i$，背包的容量为$c$。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？<br>在选择装入背包的物品时，对每种物品$i$只有装入和不装入两种选择。不能将物品$i$装入背包多次，也不能只装入部分物品$i$。因此，该问题称为0-1背包问题。即：<br>$$<br>\max \sum_{i=1}^n v_ix_i=\left{<br>\begin{aligned}<br>\sum_{i=1}^nw_ix_i \le c &amp; \<br>x_i \in {0, 1} &amp; \qquad 1 \le i \le n<br>\end{aligned}<br>\right.<br>$$</p>
<p><strong>最优子结构性质</strong>：<br>设$(y_1, y_2,…, y_n)$是所给0-1背包问题的一个最优解，则$(y_2, y_3,…, y_n)$是下面相应子问题的一个最优解：<br>$$<br>\max \sum_{i=1}^n v_ix_i=\left{<br>\begin{aligned}<br>\sum_{i=1}^nw_ix_i \le c-w_iy_1 &amp; \<br>x_i \in {0, 1}\qquad &amp; \qquad 2 \le i \le n<br>\end{aligned}<br>\right.<br>$$</p>
<p><strong>建立递归关系</strong>：<br>设所给0-1背包问题的子问题的最优值为$m(i, j)$，即$m(i, j)$是背包容量为$j$，可选择物品为$i$，$i+1$，…，$n$时0-1背包问题的最优值。可建立递推关系如下：<br>$$<br>m(i,j)=\left{<br>\begin{aligned}<br>\max{m(i,j), m(i+1, j-w_i)+v_i} &amp; \qquad j \le w_i \<br>m(i+1, j) \qquad \qquad \qquad&amp; \qquad 0 \le j \le w_i<br>\end{aligned}<br>\right.<br>$$</p>
<p><strong>算法描述</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">(Comparable v, <span class="keyword">int</span> w, <span class="keyword">int</span> c, <span class="keyword">int</span> n, Comparable** m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jMax = Math.min(w[n]-<span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)&#123;</span><br><span class="line">        m[n][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w[n]; j &lt;= c; j++)&#123;</span><br><span class="line">        m[n][j] = v[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt; <span class="number">1</span>; i--)&#123;</span><br><span class="line">        jMax = Math.min(w[i]-<span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= jMax; j++)&#123;</span><br><span class="line">            m[i][j] = m[i+<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= c; j++)&#123;</span><br><span class="line">            m[i][j] = Math.max(m[i+<span class="number">1</span>][j], m[i+<span class="number">1</span>][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m[<span class="number">1</span>][c] = m[<span class="number">2</span>][c];</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= w[<span class="number">1</span>])&#123;</span><br><span class="line">            m[<span class="number">1</span>][c] = Math.max(m[<span class="number">1</span>][c], m[<span class="number">2</span>][c-w[<span class="number">1</span>]]+v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(Comparable **m, <span class="keyword">int</span> w, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i][c] == m[i+<span class="number">1</span>][c])&#123;</span><br><span class="line">            x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x[i] = <span class="number">1</span>;</span><br><span class="line">            c -= w[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x[n] = (m[n][c]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h2><p>对于一颗二叉搜索树，其中的任何一个结点，它的左结点都不比它大，它的右结点都不比它小。<br>如果在二叉树中查找元素不考虑概率及查找不成功的情况下，可以采用红黑树或者平衡二叉树来搜索，这样可以在O(lgn)时间内完成。而现实生活中，查找的关键字是有一定的概率的，就是说有的关键字可能经常被搜索，而有的很少被搜索，而且搜索的关键字可能不存在，为此需要根据关键字出现的概率构建一个二叉树。比如中文输入法字库中各词条（单字、词组等）的先验概率，针对用户习惯可以自动调整词频——所谓动态调频、高频先现原则，以减少用户翻查次数，使得经常用的词汇被放置在前面，这样就能有效地加快查找速度。这就是最优二叉搜索0树所要解决的问题。</p>
<p>给定一个由$n$个互异的关键字组成的有序序列$S={x_1, x_2,…, x_n}$和它们被查询的概率$P={p_1, p_2,…, p_n}$，要求构造一颗二叉搜索树$T$，使得查询所有元素的总的代价最小。对于一个搜索树，当搜索的元素在树内时，表示搜索成功；当不在树内时，表示搜索失败，用一个“虚叶子结点”来表示搜索失败的情况，因此需要$n+1$个虚叶子结点${d_0, d_1,…, d_n}$，对应于$d_i$的概率序列是$Q={q_0, q_1,…, q_n}$，其中$d_0$表示搜索元素小于$x_1$的失败情况，$d_n$表示搜索元素大于$x_n$的失败情况。$d_i(0&lt;i&lt;n)$表示搜索结点在$x_i$和$x_{i+1}$之间时的失败情况。因此有：</p>
<p>$\sum_{i=1}^np_i+\sum_{i=0}^nq_i=1$</p>
<p>由每个结点和每个虚拟结点被搜索的概率，可以确定在一颗给定的二叉搜索树$T$内一次搜索的期望代价$E(T)$。</p>
<p>$E(T)=\sum_{i=1}^n(depth_T(x_i)+1)*p_i+\sum_{i=0}^n(depth_T(d_i)+1)*q_i=1+\sum_{i=1}^ndepth_T(x_i)*p_i+\sum_{i=0}^ndepth_T(d_i)*q_i$</p>
<p><strong>需要注意的是，一颗最优二叉搜索树不一定是一颗整体高度最小的树，也不一定总是把最大概率的结点放在根部。</strong></p>
<p>定义$e_{i,j}$为搜索一颗包含关键字$x_i,x_{i+1},…,x_j$的最优二叉搜索树的期望代价。$e_{i,j}=w_{i,j}*distance_{i,j}$，$distance_{i,j}$为二叉树$T_{i,j}$的平均路长。<br>当 $j=i-1$ 时：<br>此时只有虚拟结点$d_{i-1}$，故$e_{i,i-1}=q_{i-1}$</p>
<p>当 $j \ge i$ 时：<br>需要从$x_i,…,x_j$中选择一个$x_k$，来构造一颗最优二叉搜索树，其中$x_i,…,x_{k-1}$作为左子树，$x_{k+1},…,x_j$作为右子树。定义概率总和为：</p>
<p>$w_{i,j}=\sum_{l=i}^jp_l+\sum_{l=i-1}^jq_l$</p>
<p>如果$x_k$是<strong>最优子树</strong>$x_i,…,x_j$的根，则：</p>
<p>$e_{i,j}=e_{i,k-1}+e_{k+1,j}+w_{i,j}$</p>
<p>最优子结构递推式可写为：<br>$e_{i,j}=w_{i,j}+\min_{\substack{i \le k \le j}}{e_{i,k-1},e_{k+1,j}}  \qquad j \ge i$<br>$e(i,i-1)=0 \qquad 1 \le i \le n$</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OptimalBinarySearchTree</span><span class="params">(Comparable[] p, Comparable[] q, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n+<span class="number">1</span>, i++)&#123;</span><br><span class="line">        e[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">        w[i][i-<span class="number">1</span>] = q[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l, j, r;</span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>, l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n-l+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            j = i+l-<span class="number">1</span>;</span><br><span class="line">            e[i][j] = MAX;</span><br><span class="line">            w[i][j] = w[i][j-<span class="number">1</span>] + p[j] + q[j];</span><br><span class="line">            <span class="keyword">for</span>(r = i; r &lt;= j; r++)&#123;</span><br><span class="line">                <span class="keyword">double</span> t = e[i][r-<span class="number">1</span>]+e[r+<span class="number">1</span>][j]+w[i][j];</span><br><span class="line">                <span class="keyword">if</span>(t &lt; e[i][j])&#123;</span><br><span class="line">                    e[i][j] = t;</span><br><span class="line">                    root[i][j] = r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">contrustOPST</span><span class="params">(<span class="keyword">int</span> i, intj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = root[i][j];</span><br><span class="line">    contrustOPST(i, r-<span class="number">1</span>);</span><br><span class="line">    contrustOPST(r+<span class="number">1</span>, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[复习]算法分析与设计-回溯篇</title>
    <url>/2020/12/08/%E5%A4%8D%E4%B9%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h2 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h2><h2 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h2><h2 id="集装箱装载问题"><a href="#集装箱装载问题" class="headerlink" title="集装箱装载问题"></a>集装箱装载问题</h2><h2 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h2><h2 id="符号三角形问题"><a href="#符号三角形问题" class="headerlink" title="符号三角形问题"></a>符号三角形问题</h2><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><h2 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h2><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><h2 id="图的着色问题"><a href="#图的着色问题" class="headerlink" title="图的着色问题"></a>图的着色问题</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>[复习]算法分析与设计-贪心篇</title>
    <url>/2020/12/08/%E5%A4%8D%E4%B9%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<div align="center"><img src="/.io//a.jpg"></div>

<span id="more"></span>

<h2 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h2><p>设有$n$个活动的集合$E={1,2,…,n}$，其中每个活动要求使用同一资源，如演讲会场，而在同一时间内只有一个活动能使用这一资源。每个活动 $i$ 都有要求使用该资源的起始时间 $s_i$ 和结束时间 $f_i$，且$s_i \lt f_i$。如果选择了活动 $i$ ，则它在半开时间区间$[s_i, f_i)$内占用资源。若区间$[s_i, f_i)$和$[s_j, f_j)$不相交，则称活动 $i$ 与活动 $j$ 是相容的。也就是说，当$s_i \ge f_j$或$s_j \ge f_i$时，活动 $i$ 与活动 $j$相容。<br>将各活动的起始时间和结束时间分别存储在数组 $s$ 和 $f$ 中，且<strong>按结束时间的非减序列</strong>：$f_1 \le f_2 \le … \le f_n$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GreedySelector</span><span class="params">(<span class="keyword">int</span> n, Comparable s[], Comparable f[], <span class="keyword">boolean</span> A[])</span></span>&#123;</span><br><span class="line">    A[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= f[j])&#123;</span><br><span class="line">            A[i] = <span class="keyword">true</span>;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            A[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题（物品可以划分）"><a href="#背包问题（物品可以划分）" class="headerlink" title="背包问题（物品可以划分）"></a>背包问题（物品可以划分）</h2><p>给定$n$种物品和一背包。物品$i$的重量是$w_i$，其价值为$v_i$，背包的容量为$c$。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Knapsack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">float</span> M, <span class="keyword">float</span>[] v, <span class="keyword">float</span>[] w, <span class="keyword">float</span>[] x)</span></span>&#123;</span><br><span class="line">    # 首先计算每种物品的单位价值vi/wi</span><br><span class="line">    # 并按照从大大小的顺序排列，依次选择单位重量价值高</span><br><span class="line">    # 的物品并尽可能多的装入背包，直至背包装满</span><br><span class="line">    Sort(n, v, w);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> c = M;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(w[i] &gt; c)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x[i] = <span class="number">1</span>;</span><br><span class="line">        c -= w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt;= n)&#123;</span><br><span class="line">        x[i] = c/w[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最优装载问题"><a href="#最优装载问题" class="headerlink" title="最优装载问题"></a>最优装载问题</h2><p>有一批集装箱上要装上一艘重量为 $c$ 的轮船。其中集装箱 $i$ 的重量为 $w_i$ 。最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。即：<br>$$<br>\left{<br>\begin{aligned}<br>\max\sum_{i=1}^nx_i \qquad \<br>\sum_{i=1}^nw_ix_i \le c \qquad<br>\end{aligned}<br>x_i \in {0, 1},1 \le i \le n<br>\right.<br>$$</p>
<p>其中，$x_i=0$表示不装入集装箱 $i$ ,$x_i=1$表示装入集装箱 $i$。<br>采用重量最轻者先装的贪心选择策略，可得到装载问题的最优解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Loading</span><span class="params">(<span class="keyword">int</span>[] x, Comparable[] w, Comparable c, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将重量按从小到大的顺序排列</span></span><br><span class="line">    <span class="comment">// 第i轻的货物在w中的位置为t[i]</span></span><br><span class="line">    <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    Sort(w, t, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        x[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; w[t[i]] &lt;= c; i++)&#123;</span><br><span class="line">        x[t[i]] = <span class="number">1</span>;</span><br><span class="line">        c -= w[t[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>哈夫曼编码是一种广泛用于数据文件压缩的十分有效的编码方法。通过自底向上的方式构建表示最优前缀码的二叉树。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a: 45</span><br><span class="line">b: 13</span><br><span class="line">c: 12</span><br><span class="line">d: 16</span><br><span class="line">e: 9</span><br><span class="line">f: 5</span><br><span class="line"></span><br><span class="line">第一步合并：     第二步合并：     第三步合并：    </span><br><span class="line">  a: 45           a: 45          a: 45</span><br><span class="line">  b: 13         b,c: 25        b,c: 25 </span><br><span class="line">  c: 12           d: 16      d,e,f: 30</span><br><span class="line">  d: 16         e,f: 14</span><br><span class="line">e,f: 14</span><br><span class="line"></span><br><span class="line">       第四步合并：              第五步合并：</span><br><span class="line">        a: 45           a,b,c,d,e,f: 100</span><br><span class="line">b,c,d,e,f: 55 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        100</span><br><span class="line">                   0   /  \   1</span><br><span class="line">                     /     \</span><br><span class="line">                  a: 45    55</span><br><span class="line">                         /    \</span><br><span class="line">                  0   /         \  1</span><br><span class="line">                   /              \ </span><br><span class="line">                 25               30</span><br><span class="line">            0  /   \  1       0  /  \  1</span><br><span class="line">             /      \          /     \</span><br><span class="line">          b: 13    c: 12    d: 16    14</span><br><span class="line">                                 0  /   \  1</span><br><span class="line">                                  /      \</span><br><span class="line">                                e: 9    f: 5</span><br><span class="line"></span><br><span class="line">故编码为：</span><br><span class="line">a: 0</span><br><span class="line">b: 100</span><br><span class="line">c: 101</span><br><span class="line">d: 110</span><br><span class="line">e: 1110</span><br><span class="line">f: 1111</span><br></pre></td></tr></table></figure>

<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>$Dijkstra$算法是解决单源最短路径问题的一个贪心算法。其基本思想是，设置顶点集合$S$，并不断的做贪心选择来扩充这个集合。给定一个带权有向图$S={V, E}$，初始时，$S$中仅含有源。设$u$是$G$的一个顶点，把从源到$u$且中间只经过$S$中顶点的路称为从源到$u$的最短路径并用数组$dist$记录当前顶点所对应的最短特殊路径长度$Dijkstra$算法每次从$V-S$中取出具有最短特殊路长度的顶点$u$，将$u$添加到$S$中，同时对数组$dist$做必要的修改。一旦$S$包含了所有$V$中顶点，$dist$就记录了从源到所有其他顶点之间的最短路径长度。例如：</p>
<div align="center"><img src="/.io//dijkstra.png"></div>

<table>
<thead>
<tr>
<th>迭代</th>
<th>S</th>
<th>u</th>
<th>dist[2]</th>
<th>dist[3]</th>
<th>dist[4]</th>
<th>dist[5]</th>
</tr>
</thead>
<tbody><tr>
<td>初始</td>
<td>{1}</td>
<td>-</td>
<td>10</td>
<td>maxint</td>
<td>30</td>
<td>100</td>
</tr>
<tr>
<td>1</td>
<td>{1,2}</td>
<td>2</td>
<td>10</td>
<td>60</td>
<td>30</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>{1,2,4}</td>
<td>4</td>
<td>10</td>
<td>50</td>
<td>30</td>
<td>90</td>
</tr>
<tr>
<td>3</td>
<td>{1,2,3,4}</td>
<td>3</td>
<td>10</td>
<td>50</td>
<td>30</td>
<td>60</td>
</tr>
<tr>
<td>4</td>
<td>{1,2,3,4,5}</td>
<td>5</td>
<td>10</td>
<td>50</td>
<td>30</td>
<td>60</td>
</tr>
</tbody></table>
<h2 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>设$G=(V, E)$是连通带权图，$V={1,2,…,n}$。构造$G$的最小生成树的$Prim$算法的基本思想是：首先置$S={1}$，然后，只要$S$是$V$的真子集，就做如下贪心选择：选取满足条件$i \in S, j \in V-S$，且$c[i][j]$（即权值）最小的边，并将顶点$j$添加到$S$中。这个过程一直进行到$S=V$时为止，选取到的所有边恰好构成$G$的一颗最小生成树。</p>
<div align="center"><img src="/.io//prim1.png" width="60%"></div>
<div><img src="/.io//prim1.jpg" width="20%"><img src="/.io//prim2.jpg" width="20%"><img src="/.io//prim3.jpg" width="20%"><img src="/.io//prim4.jpg" width="20%"><img src="/.io//prim5.jpg" width="20%"></div>
### Kruskal
构造最小生成树的另一个算法是$Kruskal$算法。当图的边数为$e$时，$Kruskal$算法所需的时间是$O(eloge)$。当$e=\Omega(n^2)$时，$Kruskal$算法比$Prim$算法差，但当$e=o(n^2)$时，$Kruskal$算法却比$Prim$算法好得多。
给定无向连通带权图$G=(V, E)$，$V=\{1,2,...,n\}$。构造$G$的最小生成树的$Kruskal$算法的基本思想是：首先将$G$的$n$个顶点看成$n$个孤立的连通分支，将所有的边按从小到大的顺序排列；然后从第一条边开始，以边权递增的顺序查看每条边，如果边的两个端点属于两个不同的连通分支，就加入该边，继续查看下一条边；如果两个端点属于同一个连通分支，直接查看下一条边。这个过程一直进行到只剩下一个连通分支。
<div><img src="/.io//kruskal1.jpg" width="17%"> <img src="/.io//kruskal2.jpg" width="17%"> <img src="/.io//kruskal3.jpg" width="17%"> <img src="/.io//kruskal4.jpg" width="17%"> <img src="/.io//kruskal5.jpg" width="17%"></div>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>简单上手树莓派</title>
    <url>/2021/03/11/%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    <content><![CDATA[<p>近期入手了一块树莓派3B+的板子，想接墨水屏做个 <strong>天气预报+ToDoList</strong> 的常亮桌饰。（不是为了当作嵌入式系统课程的作业…🐕）</p>
<div align="center"><img src="/.io//1.png"></div>

<span id="more"></span>

<p>第一次玩树莓派，从淘宝下单板子到收货这段时间，还是查了很多资料的，上手的时候各种小问题层出不穷，写个blog记录一下，顺便水一篇更新。</p>
<h2 id="0-准备"><a href="#0-准备" class="headerlink" title="0. 准备"></a>0. 准备</h2><p>树莓派3B+ 1GB<br>5V 3A外接电源线<br>SanDisk内存卡16GB C10<br>读卡器</p>
<h2 id="1-下载镜像"><a href="#1-下载镜像" class="headerlink" title="1. 下载镜像"></a>1. 下载镜像</h2><p>使用Raspbian作为烧录系统：<a href="https://www.jianshu.com/p/467335f07e05">下载地址</a></p>
<div><img src="/.io//mirror1.png"></div>

<div><img src="/.io//mirror2.png"></div>

<p>下载完镜像对压缩文件进行解压缩，得到的<code>.img</code>文件就是我们要烧录的镜像文件。</p>
<div><img src="/.io//mirror3.png"></div>

<h2 id="2-安装系统并初始化"><a href="#2-安装系统并初始化" class="headerlink" title="2. 安装系统并初始化"></a>2. 安装系统并初始化</h2><h3 id="2-1-格式化SD卡"><a href="#2-1-格式化SD卡" class="headerlink" title="2.1 格式化SD卡"></a>2.1 格式化SD卡</h3><p>首先将SD卡格式化，使用<code>SDCardFormatter</code>。</p>
<div><img src="/.io//formatter.png"></div>

<h3 id="2-2-烧录镜像"><a href="#2-2-烧录镜像" class="headerlink" title="2.2 烧录镜像"></a>2.2 烧录镜像</h3><p>然后使用<code>win32diskimager</code>烧录<code>.img</code>文件。</p>
<div><img src="/.io//img.png"></div>

<h3 id="2-3-配置文件"><a href="#2-3-配置文件" class="headerlink" title="2.3 配置文件"></a>2.3 配置文件</h3><p>烧录完成后，SD卡的空间变成两个分区，其中<code>boot</code>分区就是系统的<code>\boot</code>文件夹。<br>由于没有外接显示屏，所以为了能够使用Raspberry系统终端，需要通过网络连接树莓派，有以下两个步骤：<br>①新建一个名为<code>ssh</code>的文件，无后缀，字母小写。<br>②新建网络配置文件<code>wpa_supplicant.conf</code>并写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;ForRaspPi&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;WiFi-B&quot;     # 网络ssid</span><br><span class="line">psk=&quot;12345678&quot;    # 网络密码</span><br><span class="line">key_mgmt=WPA-PSK  # 密钥类型，手机热点就是该类型</span><br><span class="line">priority=2        # 连接优先级</span><br><span class="line">scan_ssid=1       # 连接隐藏wifi时需要指定该值为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div><img src="/.io//ssh.png"></div>

<p>设置完成后，从电脑弹出SD卡，并插入树莓派。</p>
<h2 id="3-连接树莓派"><a href="#3-连接树莓派" class="headerlink" title="3. 连接树莓派"></a>3. 连接树莓派</h2><p>给树莓派通上5V3A的电源后，指示灯会亮起，树莓派3B+上，红色等亮起表示接通电源，绿色灯亮起表示系统在对SD进行读写。树莓派启动后，就可以通过<code>ssh</code>连接登录系统。<strong>连接树莓派的电脑和树莓派必须处于同一个网段，连接同一个路由器</strong>。这里给出两种连接方式：</p>
<h3 id="3-1-使用PuTTY连接树莓派（推荐）"><a href="#3-1-使用PuTTY连接树莓派（推荐）" class="headerlink" title="3.1 使用PuTTY连接树莓派（推荐）"></a>3.1 使用PuTTY连接树莓派（推荐）</h3><p>在PuTTY输入IP地址和端口号（默认22）</p>
<div><img src="/.io//conn0.png"></div>

<div><img src="/.io//conn1.png"></div>

<h3 id="3-2-Win10的cmd窗口连接树莓派"><a href="#3-2-Win10的cmd窗口连接树莓派" class="headerlink" title="3.2 Win10的cmd窗口连接树莓派"></a>3.2 Win10的cmd窗口连接树莓派</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 尝试过没成功</span><br><span class="line">&gt; ssh pi@172.20.10.12:22</span><br></pre></td></tr></table></figure>

<h4 id="补充填坑"><a href="#补充填坑" class="headerlink" title="补充填坑"></a>补充填坑</h4><p>由于up学校的校园网需要二次登录，所以只能使用手机热点作为路由器连接树莓派。更不巧的是，up的手机是ios系统，无法查看连接热点的设备的ip😭😭😭<br>经过一番折腾，想到一个办法：用电脑也连接手机热点，然后用一个<code>Network Scanner</code>的软件扫描该网段下的所有设备。</p>
<div><img src="/.io//wifi.png"></div>

<h2 id="4-Raspbian配置"><a href="#4-Raspbian配置" class="headerlink" title="4. Raspbian配置"></a>4. Raspbian配置</h2><p>连接到树莓派后需要先登录系统，树莓派默认ssh账户名<code>pi</code>，密码<code>raspberry</code>。</p>
<h3 id="4-1-修改密码"><a href="#4-1-修改密码" class="headerlink" title="4.1 修改密码"></a>4.1 修改密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改普通账户pi的密码</span><br><span class="line">&gt; sudo passwd pi</span><br><span class="line"></span><br><span class="line"># 修改管理员账户root的密码</span><br><span class="line">&gt; sudo passwd root</span><br></pre></td></tr></table></figure>

<h3 id="4-2-校正时区"><a href="#4-2-校正时区" class="headerlink" title="4.2 校正时区"></a>4.2 校正时区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sudo dpkg-reconfigure tzdata</span><br><span class="line"># 选择 Asia--&gt;Shanghai  </span><br></pre></td></tr></table></figure>

<h3 id="4-3-修改静态ip"><a href="#4-3-修改静态ip" class="headerlink" title="4.3 修改静态ip"></a>4.3 修改静态ip</h3><p>确保树莓派每次启动都连接同一个路由的同一个ip和端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 树莓派终端下查看自己局域网的ip网段</span><br><span class="line">&gt; ifconfig</span><br></pre></td></tr></table></figure>

<div><img src="/.io//staticip1.png"></div>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置静态ip</span><br><span class="line">&gt; sudo nano /etc/dhcpcd.conf</span><br><span class="line"></span><br><span class="line"># 添加如下</span><br><span class="line">#---如果是无线网卡---</span><br><span class="line">interface wlan0                         # 网卡名</span><br><span class="line">static ip_address=172.20.10.12/22       # 树莓派ip</span><br><span class="line">static routers=172.20.10.1              # 路由器ip</span><br><span class="line">static domain_name_servers=172.20.10.1  # DNS,同路由器ip</span><br><span class="line"></span><br><span class="line">#---如果是有线网卡---</span><br><span class="line">interface eth0</span><br><span class="line">static ip_address=172.20.10.12/22</span><br><span class="line">static routers=172.20.10.1</span><br><span class="line">static domain_name_servers=172.20.10.1</span><br></pre></td></tr></table></figure>

<p>路由地址一般最后8位是00000001，即1。或者在连接同一路由的电脑上查看无线网属性：</p>
<div><img src="/.io//staticip3.png"></div>

<p>保存退出</p>
<h3 id="4-3-修改系统软件源"><a href="#4-3-修改系统软件源" class="headerlink" title="4.3 修改系统软件源"></a>4.3 修改系统软件源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 树莓派默认使用nano作为编辑器，修改完成后使用Ctrl+X退出，输入y后回车保存</span><br><span class="line">&gt; sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 修改系统源为清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure>

<h3 id="4-4-修改pip源"><a href="#4-4-修改pip源" class="headerlink" title="4.4 修改pip源"></a>4.4 修改pip源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; mkdir ~/.pip</span><br><span class="line">&gt; nano ~/.pip/pip.conf</span><br><span class="line"></span><br><span class="line"># 添加以下内容（豆瓣源）</span><br><span class="line">[global]</span><br><span class="line">timeout =6000</span><br><span class="line">index-url =http://pypi.douban.com/simple/</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =true </span><br><span class="line">mirrors =http://pypi.douban.com/simple/ </span><br><span class="line">trusted-host =pypi.douban.com</span><br></pre></td></tr></table></figure>

<p>保存并退出</p>
<table>
<thead>
<tr>
<th>国内其他源地址</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>阿里云</td>
<td><a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></td>
</tr>
<tr>
<td>中科大</td>
<td><a href="https://mirrors.bfsu.edu.cn/pypi/web/simple/">https://mirrors.bfsu.edu.cn/pypi/web/simple/</a></td>
</tr>
<tr>
<td>豆瓣</td>
<td><a href="http://pypi.douban.com/simple">http://pypi.douban.com/simple</a></td>
</tr>
<tr>
<td>Python官方</td>
<td><a href="https://pypi.python.org/simple/">https://pypi.python.org/simple/</a></td>
</tr>
<tr>
<td>v2ex</td>
<td><a href="http://pypi.v2ex.com/simple/">http://pypi.v2ex.com/simple/</a></td>
</tr>
<tr>
<td>中科院</td>
<td><a href="http://pypi.mirrors.opencas.cn/simple/">http://pypi.mirrors.opencas.cn/simple/</a></td>
</tr>
</tbody></table>
<h3 id="4-5-安装vim代替nano"><a href="#4-5-安装vim代替nano" class="headerlink" title="4.5 安装vim代替nano"></a>4.5 安装vim代替nano</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sudo apt-get install vim</span><br><span class="line"># 直接使用该命令安装时，会报 Depends:vim-common (=2:7.4.1689-3raspberry1.4) but 2:8.0.1453-1raspberry1.1 is to be installed 的错误</span><br><span class="line"></span><br><span class="line"># 解决方法</span><br><span class="line">&gt; sudo apt-get purge vim-common</span><br><span class="line">&gt; sudo apt-get update</span><br><span class="line">&gt; sudo apt-get upgrade</span><br><span class="line">&gt; sudo apt-get install vim</span><br><span class="line"></span><br><span class="line"># vim配置</span><br><span class="line">&gt; sudo vim /etc/vim/vimrc</span><br><span class="line"></span><br><span class="line"># 添加以下内容</span><br><span class="line">syntax on  # 语法高亮</span><br><span class="line">set nu     # 显示行号</span><br></pre></td></tr></table></figure>

<h2 id="5-开启远程桌面"><a href="#5-开启远程桌面" class="headerlink" title="5. 开启远程桌面"></a>5. 开启远程桌面</h2><h3 id="5-1-启用树莓派VNC"><a href="#5-1-启用树莓派VNC" class="headerlink" title="5.1 启用树莓派VNC"></a>5.1 启用树莓派VNC</h3><p>Raspbian自带有VNC远程桌面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; sudo raspi-config</span><br></pre></td></tr></table></figure>

<div><img src="/.io//vnc1.png"></div>

<div><img src="/.io//vnc2.png"></div>

<div><img src="/.io//vnc3.png"></div>

<p>启用VNC后，在树莓派终端开启VNC服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; vncserver</span><br></pre></td></tr></table></figure>
<div><img src="/.io//vnc4.png"></div>

<p>可以看到的是启用的<code>raspberry:1</code>，其中<code>:1</code>就表示树莓派服务器的端口号。</p>
<h3 id="5-2-启用win端VNC"><a href="#5-2-启用win端VNC" class="headerlink" title="5.2 启用win端VNC"></a>5.2 启用win端VNC</h3><p><a href="https://www.realvnc.com/en/connect/download/viewer/">下载VNC Viewer</a>并启动，通过ip和端口连接树莓派。</p>
<div><img src="/.io//vnc5.png"></div>
<div><img src="/.io//vnc6.png"></div>]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>RaspberryPi</tag>
      </tags>
  </entry>
</search>
