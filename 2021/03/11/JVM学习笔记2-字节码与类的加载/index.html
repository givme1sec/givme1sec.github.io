<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记2-字节码与类的加载">
<meta property="og:url" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/index.html">
<meta property="og:site_name" content="Et1nnn&#39;s Notes">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/1.JPG">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/inttest2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/inttest1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/stringtest2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/stringtest3.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/sontest1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/sontest2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/classfile1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/classfilestruc.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/classfile2.jpg">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/constant.jpg">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/accessflag.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/javap.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/javap1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/javap2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/stackframe.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/loadandstore1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/loadandstore2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/loadandstore3.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/loadandstore4.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/classloadingp.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/classunload.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/hotexchange.png">
<meta property="article:published_time" content="2021-03-11T12:51:44.000Z">
<meta property="article:modified_time" content="2021-04-21T09:29:12.000Z">
<meta property="article:author" content="Etin Ban">
<meta property="article:tag" content="字节码">
<meta property="article:tag" content="类">
<meta property="article:tag" content="Class">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/1.JPG">


<link rel="canonical" href="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/","path":"2021/03/11/JVM学习笔记2-字节码与类的加载/","title":"JVM学习笔记2-字节码与类的加载"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM学习笔记2-字节码与类的加载 | Et1nnn's Notes</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Et1nnn's Notes</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">record every step</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E7%9C%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E7%BB%86%E8%8A%82"><span class="nav-number">1.</span> <span class="nav-text">字节码看代码执行细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B1"><span class="nav-number">1.1.</span> <span class="nav-text">举例1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B2"><span class="nav-number">1.2.</span> <span class="nav-text">举例2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B3"><span class="nav-number">1.3.</span> <span class="nav-text">举例3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">Class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">字节码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">字节码指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E8%AF%BB%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">解读字节码文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">字节码文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">字节码文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E8%A7%A3%E6%9E%90Class%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.</span> <span class="nav-text">指令解析Class文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="nav-number">2.6.1.</span> <span class="nav-text">编译指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4"><span class="nav-number">2.6.2.</span> <span class="nav-text">反编译指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4-1"><span class="nav-number">3.</span> <span class="nav-text">字节码指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.</span> <span class="nav-text">加载与存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">复习：操作数栈与局部变量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.2.</span> <span class="nav-text">局部变量表压栈指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.3.</span> <span class="nav-text">常量入栈指令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">const指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#push%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">push指令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ldc%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">ldc指令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E6%A0%88%E8%A3%85%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.1.4.</span> <span class="nav-text">出栈装入局部变量表指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">算术指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.1.</span> <span class="nav-text">比较指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">3.3.</span> <span class="nav-text">类型转换指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">3.4.</span> <span class="nav-text">对象的创建与访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="nav-number">3.4.1.</span> <span class="nav-text">创建指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">3.4.2.</span> <span class="nav-text">字段访问指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">3.5.</span> <span class="nav-text">方法调用与返回指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.5.1.</span> <span class="nav-text">方法调用指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">3.5.2.</span> <span class="nav-text">方法返回指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">3.6.</span> <span class="nav-text">操作数栈管理指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.</span> <span class="nav-text">控制转移指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.1.</span> <span class="nav-text">条件跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.2.</span> <span class="nav-text">比较条件跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.3.</span> <span class="nav-text">多条件分支跳转指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">3.7.4.</span> <span class="nav-text">无条件跳转指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">3.8.</span> <span class="nav-text">异常处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="nav-number">3.8.1.</span> <span class="nav-text">抛出异常指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4-1"><span class="nav-number">3.8.2.</span> <span class="nav-text">异常处理指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">3.9.</span> <span class="nav-text">同步控制指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.</span> <span class="nav-text">类的加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B1%EF%BC%9ALoading%EF%BC%88%E5%8A%A0%E8%BD%BD%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">4.1.</span> <span class="nav-text">过程1：Loading（加载）阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B2%EF%BC%9ALinking%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">4.2.</span> <span class="nav-text">过程2：Linking（链接）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">4.2.1.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">4.2.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">4.2.3.</span> <span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B3%EF%BC%9AInitialization%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E9%98%B6%E6%AE%B5"><span class="nav-number">4.3.</span> <span class="nav-text">过程3：Initialization（初始化）阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">4.3.1.</span> <span class="nav-text">类的主动使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">4.3.2.</span> <span class="nav-text">类的被动使用：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B4%EF%BC%9A%E7%B1%BB%E7%9A%84Using%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">过程4：类的Using（使用）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B5%EF%BC%9A%E7%B1%BB%E7%9A%84Unloading%EF%BC%88%E5%8D%B8%E8%BD%BD%EF%BC%89"><span class="nav-number">4.5.</span> <span class="nav-text">过程5：类的Unloading（卸载）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E3%80%81%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E3%80%81%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-number">4.5.1.</span> <span class="nav-text">类、类的加载器、类的实例之间的引用关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.5.2.</span> <span class="nav-text">类的生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="nav-number">5.1.1.</span> <span class="nav-text">类的加载方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">5.1.2.</span> <span class="nav-text">命名空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8-1"><span class="nav-number">5.2.</span> <span class="nav-text">类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="nav-number">5.2.1.</span> <span class="nav-text">双亲委托模式的弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A0%B4%E5%9D%8F"><span class="nav-number">5.2.2.</span> <span class="nav-text">双亲委托模式的破坏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%83%AD%E6%9B%BF%E6%8D%A2"><span class="nav-number">5.2.3.</span> <span class="nav-text">热替换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">5.3.</span> <span class="nav-text">Java9新特性</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Etin Ban</p>
  <div class="site-description" itemprop="description">磨刀不误砍柴工，读完硕士再打工</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Etin Ban">
      <meta itemprop="description" content="磨刀不误砍柴工，读完硕士再打工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Et1nnn's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM学习笔记2-字节码与类的加载
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 20:51:44" itemprop="dateCreated datePublished" datetime="2021-03-11T20:51:44+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 17:29:12" itemprop="dateModified" datetime="2021-04-21T17:29:12+08:00">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <div align="center"><img src="1.JPG"></div>

<span id="more"></span>

<h2 id="字节码看代码执行细节"><a href="#字节码看代码执行细节" class="headerlink" title="字节码看代码执行细节"></a>字节码看代码执行细节</h2><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        Integer x = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;</span><br><span class="line">        System.out.println(x == y); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        Integer i1 = <span class="number">10</span>;</span><br><span class="line">        Integer i2 = <span class="number">10</span>;</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Example 3</span></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">//flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="inttest2.png" width="70%"></div>

<p>从上面的字节码文件中可以看到，<code>Integer x = 5</code>调用了<code>Integer</code>对象中的<code>valueOf</code>方法，<code>valueOf</code>方法中的<code>IntegerCache.cache</code>是<code>IntegerCache</code>方法中声明为全局常量的数组，数组大小为256，保存了$[-128, 127]$中的所有整数，如果<code>i</code>的值在该区间，直接从<code>IntegerCache.cache</code>数组中取出这个数，否则new一个<code>Integer</code>。</p>
<div align="center"><img src="inttest1.png" width="80%"></div>

<p><strong>Example1：</strong><br>① <code>5</code>在这个区间中，所以<code>x</code>指向的地址是<code>IntegerCache.cache</code>数组中<code>int</code>型数据<code>5</code>的位置，<code>Integer</code>本身有一个装箱的操作，所以<code>x</code>是一个引用数据类型。字节码文件中的<code>astore_1</code>表示<code>x</code>保存在了局部变量表索引为1的位置（索引为0的位置保存main方法的参数args）。</p>
<p>② <code>int y = 5</code>对基本数据类型<code>y</code>赋值<code>5</code>。一般情况下，引用数据类型和基本数据类型不能做<code>==</code>的操作，但是<code>x</code>又包含拆箱的操作，所以相当于取出了基本数据类型<code>5</code>与<code>y</code>进行比较，返回结果必然是<code>true</code>。</p>
<p><strong>Example2：</strong><br>由于<code>i1</code>和<code>i2</code>指向的都是<code>IntegerCache.cache</code>中<code>10</code>的位置，所以返回<code>true</code>。</p>
<p><strong>Example3：</strong><br>由于<code>i3</code>和<code>i4</code>赋值<code>128</code>超出了<code>IntegerCache.cache</code>的数组的范围，所以new了两个<code>Integer</code>对象，<code>i3</code>和<code>i4</code>指向了不同的索引地址，故返回<code>false</code>。</p>
<h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Example 1</span></span><br><span class="line">        String str1 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        String str2 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        System.out.println(str1 == str2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Example 2</span></span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">        System.out.println(str2 == str3); <span class="comment">// flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="stringtest2.png" width="100%"></div>

<div align="center"><img src="stringtest3.png" width="80%"></div>


<p><strong>Example1：</strong><br>上图中可以看到<code>str1</code>和<code>str2</code>指向的是两个完全不同的对象，所以判断<code>str1 == str2</code>会返回<code>false</code>。</p>
<p><strong>Example2：</strong><br>在<code>String str3 = new String(&quot;helloworld&quot;)</code>中，<code>new String()</code>会调用<code>StringBuilder.toString()</code>方法，内部<code>new</code>了一个<code>String</code>，故<code>str2 == str3</code>返回<code>false</code>。</p>
<h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Father.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        x = <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Son.x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Example1:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father f = <span class="keyword">new</span> Father();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment"> * Father.x = 10</span></span><br><span class="line"><span class="comment"> * 20</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align="center"><img src="sontest1.png" width="100%"></div>


<p>成员变量（非静态）的赋值过程（按先后顺序排列）：①默认初始化 ②显示初始化/代码块中初始化 ③构造器中初始化 ④有了对象之后，可以<code>Object.prop</code>或<code>Object.method()</code>的方式初始化</p>
<figure class="highlight plaintext"><figcaption><span>f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br /&gt;</span><br><span class="line"></span><br><span class="line">**Example2:**</span><br><span class="line">```java</span><br><span class="line">public class SonTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Father f = new Son();</span><br><span class="line">        System.out.println(f.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Output:</span><br><span class="line"> * Son.x = 0</span><br><span class="line"> * Son.x = 30</span><br><span class="line"> * 20</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div align="center"><img src="sontest2.png" width="100%"></div>

<p>代码<code>Father f = new Son()</code>首先new了一个Son对象，调用Son的构造器进行初始化前，先调用其父类对象Father的构造器<code>public Father()&#123;&#125;</code>，里面有<code>this.print()</code>，由于子类对象Son重写了父类对象Father的<code>print()</code>方法，所以实际调用的是Son中的<code>print()</code>，此时Son.x还没有复制，故打印<code>Son.x = 0</code>。父类构造器执行完后，再执行子类构造器，子类构造器对成员变量初始化之前，先有显示初始化方法<code>int x = 30</code>，故在子类构造器中<code>this.print()</code>打印<code>Son.x = 30</code>。最后执行<code>System.out.println(f.x)</code>，由于属性不存在多态性，<code>f.x</code>调用的是父类Father中的<code>x</code>，<code>Father.x</code>在父类构造器中最后被复制为<code>20</code>，故打印<code>20</code>。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><h3 id="字节码文件"><a href="#字节码文件" class="headerlink" title="字节码文件"></a>字节码文件</h3><p>字节码文件由源代码经编译器编译生成，里面是JVM指令，而与C、C++编译后直接生成机器码（这也是C、C++比Java快的原因）。</p>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随其后的零至多个代表此操作所需参数的操作数（operand）构成。虚拟机中的许多指令并不包含操作数，只有一个操作码。</p>
<div align="center"><img src="classfile1.png" width="80%"></div>

<h3 id="解读字节码文件"><a href="#解读字节码文件" class="headerlink" title="解读字节码文件"></a>解读字节码文件</h3><p>① Jclasslib（或IDEA中Jclasslib插件）<br>② javap指令：JDK自带的反解析工具 <code>javap -v Test.class</code>或<code>javap -v Test.class &gt; Test.txt</code><br>④ Binary Viewer<br>③ Notepad++中HEX-editor插件</p>
<h3 id="字节码文件格式"><a href="#字节码文件格式" class="headerlink" title="字节码文件格式"></a>字节码文件格式</h3><p>Class文件没有分隔符，其中的字节顺序、数量都被严格限制。<br>Class文件格式用类似C语言结构体的方式进行数据存储，这种结构只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<br>$\bullet$ 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br /><br>$\bullet$ 表示由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其前面加上个数说明。</p>
<h3 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h3><p>字节码文件的基本结构和框架是非常稳定的，如下：</p>
<div align="center"><img src="classfilestruc.png"></div>

<p>以<strong>Demo.class</strong>的字节码文件为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ind <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num = num + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>编译Demo.class后得到的字节码文件：</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ca	fe	ba	be	00	00	00	34	00	16	0a	00	04	00	12	09</span><br><span class="line">00	03	00	13	07	00	14	07	00	15	01	00	03	6e	75	6d</span><br><span class="line">01	00	01	49	01	00	06	3c	69	6e	69	74	3e	01	00	03</span><br><span class="line">28	29	56	01	00	04	43	6f	64	65	01	00	0f	4c	69	6e</span><br><span class="line">65	4e	75	6d	62	65	72	54	61	62	6c	65	01	00	12	4c</span><br><span class="line">6f	63	61	6c	56	61	72	69	61	62	6c	65	54	61	62	6c</span><br><span class="line">65	01	00	04	74	68	69	73	01	00	13	4c	63	6f	6d	2f</span><br><span class="line">63	6f	6d	70	61	6e	79	2f	44	65	6d	6f	31	3b	01	00</span><br><span class="line">03	61	64	64	01	00	03	28	29	49	01	00	0a	53	6f	75</span><br><span class="line">72	63	65	46	69	6c	65	01	00	0a	44	65	6d	6f	31	2e</span><br><span class="line">6a	61	76	61	0c	00	07	00	08	0c	00	05	00	06	01	00</span><br><span class="line">11	63	6f	6d	2f	63	6f	6d	70	61	6e	79	2f	44	65	6d</span><br><span class="line">6f	31	01	00	10	6a	61	76	61	2f	6c	61	6e	67	2f	4f</span><br><span class="line">62	6a	65	63	74	00	21	00	03	00	04	00	00	00	01	00</span><br><span class="line">02	00	05	00	06	00	00	00	02	00	01	00	07	00	08	00</span><br><span class="line">01	00	09	00	00	00	38	00	02	00	01	00	00	00	0a	2a</span><br><span class="line">b7	00	01	2a	04	b5	00	02	b1	00	00	00	02	00	0a	00</span><br><span class="line">00	00	0a	00	02	00	00	00	03	00	04	00	04	00	0b	00</span><br><span class="line">00	00	0c	00	01	00	00	00	0a	00	0c	00	0d	00	00	00</span><br><span class="line">01	00	0e	00	0f	00	01	00	09	00	00	00	3d	00	03	00</span><br><span class="line">01	00	00	00	0f	2a	2a	b4	00	02	05	60	b5	00	02	2a</span><br><span class="line">b4	00	02	ac	00	00	00	02	00	0a	00	00	00	0a	00	02</span><br><span class="line">00	00	00	06	00	0a	00	07	00	0b	00	00	00	0c	00	01</span><br><span class="line">00	00	00	0f	00	0c	00	0d	00	00	00	01	00	10	00	00</span><br><span class="line">00	02	00	11											</span><br></pre></td></tr></table></figure>

<div align="center"><img src="classfile2.jpg"></div>



<p>$\bullet$ 使用开头<strong>4个字节</strong>的无符号整数表示的<strong>魔数</strong>而不是扩展名来进行识别主要是基于安全性方面的考虑，因为文件扩展名可以随意地改动。魔数固定值为0xCAFEBABE，不会改变。如果一个Class文件不以0xCAFEBABE开头，虚拟机在进行文件校验的时候就会直接抛出<code>ClassFormatError</code>。<br>$\bullet$ 之后的<strong>4个字节</strong>存储Class文件的<strong>版本号</strong>，第5、6个字节表示编译的副版本号<code>minor_version</code>，第7、8个字节表示编译的主版本号<code>major_version</code>。不同版本的Java编译器编译的Class文件对应的版本是不一样的，高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的Java虚拟机不能执行高版本编译器生成的Class文件，抛出<code>java.lang.UnsupportedClassVersionError</code>。<br>版本号和Java编译器的对应关系如下表：</p>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody><tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody></table>
<p>$\bullet$ 版本号后的是<strong>常量池计数器</strong>（<strong>2个字节</strong>，容量计数从1开始，即constant_pool_count=1表示常量池中有0个常量项，而计数0表示不引用任何一个常量项） 和若干个常量池表项。常量池是整个Class文件的基石。<br>常量池<strong>主要</strong>存放两大类常量：字面量（Literal）和符号引用（Symbolic Reference）。  </p>
<p>常量池中每一项常量都是一个表，JDK 1.7之后共有14种不同的表结构数据，如下所示：</p>
<div align="center"><img src="constant.jpg"></div>

<p>这14种表的共同点是：表开始的第一位是一个<code>u1</code>类型的的标志位<code>tag</code>，代表当前这个常量项使用的是哪种表结构。且除了<code>CONSTANT_Utf8_info</code>外其他常量项占用的字节数固定。</p>
<p>常量池是Class文件中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。<br /></p>
<p>$\bullet$ 之后是<strong>访问标识（access_flag）</strong>，<strong>2个字节</strong>，用来识别一些类或者接口层次访问信息。</p>
<p>在<code>Demo.class</code>文件中<code>access_flag</code>的值为<code>0x0021</code>，是<code>ACC_PUBLIC</code>和<code>ACC_SUPER</code>的加和。</p>
<div align="center"><img src="accessflag.png" width="90%"></div>

<p>① 如果一个Class文件被设置了<code>ACC_INTERFACE</code>标志，那么同时也要设置<code>ACC_ABSTRACT</code>标志，并不能再设置<code>ACC_FINAL</code>、<code>ACC_SUPER</code>和<code>ACC_ENUM</code>。</p>
<p>② 如果没有设置<code>ACC_INTERFACE</code>标志，那么这个Class文件可以设置上表中除<code>ACC_ANNOTATION</code>以外的所有标志，但<code>ACC_FINAL</code>和<code>ACC_ABSTRACT</code>是互斥的不可同时设置。</p>
<p>③ 针对Java虚拟机指令集的编译器都应当设置<code>ACC_SUPER</code>。</p>
<p>④ 注解类型必须设置<code>ACC_ANNOTATION</code>标志。</p>
<p>$\bullet$ 访问标记后，会指定该<strong>类的类别、父类类别以及实现的接口</strong>，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>字段表集合</strong>用于描述接口或类中声明的变量，<strong>包括</strong>类级变量以及实例级变量，<strong>不包括</strong>方法内部、代码块内部声明的局部变量和从父类、实现的接口中继承的字段。字段表集合指向常量池索引的集合。<br>字段表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>其中，字段表访问标志：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>方法表集合</strong>指向常量池索引集合，描述每个方法的签名。字节码文件中每一个method_info都对应这一个类或者接口中的方法信息。methods表<strong>包括</strong>当前类或接口中的方法，<strong>不包括</strong>从父类或接口中继承的方法。<br>方法表结构与字段表一样，如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>方法名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody></table>
<p>访问标志：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>public，方法可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>private，方法之能本类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>static，静态方法</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>volatile</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td>0x0080</td>
<td>transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>enum</td>
</tr>
</tbody></table>
<p>$\bullet$ <strong>属性表集合</strong>描述Class文件携带的辅助信息，通常被用于Java虚拟机的验证和运行，以及Java程序的调试，一般无须深入了解。</p>
<p>以属性表的Code属性为例，Code属性表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
<td>属性名索引</td>
</tr>
<tr>
<td>u4</td>
<td>attribute_length</td>
<td>1</td>
<td>属性长度</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
<td>操作数栈深度的最大值</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
<td>局部变量表所需的存续空间</td>
</tr>
<tr>
<td>u4</td>
<td>code_length</td>
<td>1</td>
<td>字节码指令的长度</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_length</td>
<td>存储字节码指令</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
<td>异常表长度</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_length</td>
<td>异常表</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
<td>属性集合计数器</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
<td>属性集合</td>
</tr>
</tbody></table>
<p>Code属性中还有<code>LineNumberTable</code>和<code>LocalVariableTable</code>两个内部属性。</p>
<h3 id="指令解析Class文件"><a href="#指令解析Class文件" class="headerlink" title="指令解析Class文件"></a>指令解析Class文件</h3><h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><p>①<code>javac</code>、<code>javac -g</code>的区别：<br>使用<code>javac test.java</code>编译后得到的字节码文件不会生成对应的局部变量表等信息。<code>javac -g test.java</code>则可以。默认情况下，Eclipse和IEDA在编译时也会生成局部变量表、指令和代码行偏移量映射表等信息。</p>
<h4 id="反编译指令"><a href="#反编译指令" class="headerlink" title="反编译指令"></a>反编译指令</h4><p>使用<code>javap</code>或<code>javap -help</code>可以看到可用选项。</p>
<div align="center"><img src="javap.png"></div>

<p>使用<code>javap -v Demo.class &gt; Demo.txt</code>反解析字节码文件存入<code>Demo.txt</code>中：</p>
<div align="center"><img src="javap1.png"></div>

<div align="center"><img src="javap2.png"></div>

<h2 id="字节码指令-1"><a href="#字节码指令-1" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>Java字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</p>
<p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</p>
<p>对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。</p>
<p><strong>i</strong> 代表对 <strong>int</strong> 类型的数据操作<br><strong>l</strong> 代表 <strong>long</strong><br><strong>s</strong> 代表 <strong>short</strong><br><strong>b</strong> 代表 <strong>byte</strong><br><strong>c</strong> 代表 <strong>char</strong><br><strong>f</strong> 代表 <strong>float</strong><br><strong>d</strong> 代表 <strong>double</strong></p>
<p>由于大部分指令都没有支持整数类型byte、char、short和boolean，编译器会在编译期或运行期将byte和short类型的数据（和数组）带符号扩展为相应的int类型数据。</p>
<p>JVM中的字节码指令集按照用途大致可以分成9类：<br>$\bullet$ 加载与存储指令 <br /><br>$\bullet$ 算术指令<br /><br>$\bullet$ 对象的创建与访问指令<br /><br>$\bullet$ 方法调用与返回指令<br /><br>$\bullet$ 操作数栈管理指令<br /><br>$\bullet$ 比较控制指令<br /><br>$\bullet$ 异常处理指令<br /><br>$\bullet$ 同步控制指令<br /></p>
<h3 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h3><p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递。<br><strong>常用指令：</strong><br>① 带有<code>load</code>、<code>push</code>、<code>const</code>、<code>ldc</code>的指令都是把数据压入操作数栈。<br>② 带有<code>store</code>的指令都是把数据保存在栈帧的局部变量表中。</p>
<p><strong>局部变量压栈指令：</strong><br>将一个局部变量加载到操作数栈。<br>① <code>[x]load</code>、<code>[x]load_&lt;n&gt;</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>n</code><br>其中<code>n</code>为<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code><br>如<code>iload_3</code>、<code>iload 4</code> n </p>
<p><strong>常用入栈指令：</strong><br>将一个常量加载到操作数栈。<br>①<code>bipush</code>、<code>sipush</code>、<code>ldc</code>、<code>ldc_w</code>、<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_ml</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code></p>
<p><strong>出栈装入局部变量表指令：</strong><br>将一个数值从操作数栈存储到局部变量表。<br>① <code>xstore</code>、<code>xstore_&lt;n&gt;</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>n</code><br>其中<code>n</code>为<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code><br>② <code>xastore</code><br>其中<code>x</code>为<code>i</code>、<code>l</code>、<code>f</code>、<code>d</code>、<code>a</code>、<code>b</code>、<code>c</code>、<code>s</code></p>
<h4 id="复习：操作数栈与局部变量表"><a href="#复习：操作数栈与局部变量表" class="headerlink" title="复习：操作数栈与局部变量表"></a>复习：操作数栈与局部变量表</h4><div align="center"><img src="stackframe.png"></div>

<p><strong>操作数栈</strong>用于存放计算的操作数以及返回结果。执行每一条指令之前，Java虚拟机要求该指令的操作数已经被压入操作数栈中。执行指令时，Java虚拟机将该指令所需的操作数弹出，并将指令的结果压入栈中。<br><strong>局部变量表</strong>中存放计算的缓存结果。局部变量表中按照Slot进行划分，一个Slot可以存放4个字节的数据，且非静态方法中索引为0的位置存放this。</p>
<h4 id="局部变量表压栈指令"><a href="#局部变量表压栈指令" class="headerlink" title="局部变量表压栈指令"></a>局部变量表压栈指令</h4><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(<span class="keyword">int</span> num, Object obj, <span class="keyword">long</span> count, <span class="keyword">boolean</span> flag, <span class="keyword">short</span>[] arr)</span></span>&#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字节码指令：</strong></p>
<div align="center"><img src="loadandstore1.png" ></div>

<h4 id="常量入栈指令"><a href="#常量入栈指令" class="headerlink" title="常量入栈指令"></a>常量入栈指令</h4><h5 id="const指令"><a href="#const指令" class="headerlink" title="const指令"></a>const指令</h5><p>整型：<code>iconst_&lt;i&gt;：i∈[-1, -5]，其中iconst_m1将-1压入栈</code><br>长整型：<code>lconst_&lt;l&gt;：l∈[0, 1]</code><br>float型：<code>fconst_&lt;f&gt;：f∈[0, 2]</code><br>double型：<code>dconst_&lt;d&gt;：d∈[0, 1]</code><br>null值：<code>aconst_null</code></p>
<h5 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h5><p><strong>bipush</strong> 接收8位整数作为参数 <strong>[-128, 127]</strong><br><strong>sipush</strong> 接收16位整数作为参数 <strong>[-32768, 32767]</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushConstLdc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">127</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">1234567</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="loadandstore2.png" width="80%"></div>


<h5 id="ldc指令"><a href="#ldc指令" class="headerlink" title="ldc指令"></a>ldc指令</h5><p>以上指令都不满足需求的：<br>① 指向<code>int</code>、<code>float</code>、<code>String</code>的索引（8位），用<code>ldc</code>指令。<br>② 有两个8位参数，用<code>ldc_w</code>。<br>③ 对于<code>long</code>和<code>double</code>类型，用<code>ldc2_w</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constLdc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> a1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b1 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">float</span> b2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">double</span> c1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> c2 = <span class="number">2</span>;</span><br><span class="line">        Date d = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="loadandstore3.png" width="80%"></div>

<h4 id="出栈装入局部变量表指令"><a href="#出栈装入局部变量表指令" class="headerlink" title="出栈装入局部变量表指令"></a>出栈装入局部变量表指令</h4><p>这类指令主要以<code>store</code>指令形式存在。<br>① <code>xstore</code>（<code>x</code>为<code>i、l、f、d、a</code>）<br>② <code>xtore_n</code>（<code>x</code>为<code>i、l、f、d、a</code>，<code>n</code>为<code>0、1、2、3</code>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadAndStoreTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">double</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = k + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">12</span>;</span><br><span class="line">        String str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        <span class="keyword">float</span> f = <span class="number">10.0F</span>;</span><br><span class="line">        d = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="loadandstore4.png" width="80%"></div>

<h3 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h3><p><em>《深入理解Java虚拟机》P254</em></p>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。<br>算术指令可以分为两种：① 对整型数据进行运算的指令；② 对浮点型数据进行运算的指令。</p>
<h4 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h4><p>比较指令的作用是比较栈顶两个元素的大小，并将比较的结果入栈。<br>比较指令有：<code>dcmpg、dcmpl、fcmpg、fcmpl、lcmp</code><br>其中首字符<code>d</code>表示double类型，<code>f</code>表示float类型，<code>l</code>表示long类型。只有数值类型的数据（byte\short\char\int；long\float\double）才能比大小，boolean和引用类型数据类型不能比较大小。<br><em>假如栈顶元素为v2，栈顶后一位元素为v1，如果v1=v2，压入0，如果v1&gt;v2，压入1，如果v1&lt;v2，压入-1。</em></p>
<h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><p><em>《深入理解Java虚拟机》P255</em></p>
<p>① 类型转换指令可以将两种不同的数值类型进行相互转换。<br>② 一般用于用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>包括宽化类型转换和窄化类型转换，无论是哪种，当造成精度损失时，不会导致虚拟机异常。<br>注意：<code>byte、short、char</code>在内存中看做<code>int</code>型存储。</p>
<h3 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h3><p><em>《深入理解Java虚拟机》P256</em></p>
<h4 id="创建指令"><a href="#创建指令" class="headerlink" title="创建指令"></a>创建指令</h4><p>专门用于对象操作，可以进一步细分为创建指令、字段访问指令、数组操纵指令、类型检查指令。<br>① 创建类实例：<code>new</code><br>② 创建数组： <code>newarray（基本类型数组）、anewarray（引用类型数组）、multianewarray（多维数组）</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>] <span class="comment">// newarray 10 (int)</span></span><br><span class="line">Object[] objArray = <span class="keyword">new</span> Object[<span class="number">10</span>] <span class="comment">// anewarray #2 &lt;java/lang/Ojbect&gt;</span></span><br><span class="line"><span class="keyword">int</span>[][] mintArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>] <span class="comment">// multianewarray #6 &lt;[[I&gt; dim2 </span></span><br><span class="line">String[][] strArray = <span class="keyword">new</span> String[<span class="number">10</span>][] <span class="comment">// anewarray #7 &lt;[L java/lang/String;&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="字段访问指令"><a href="#字段访问指令" class="headerlink" title="字段访问指令"></a>字段访问指令</h4><p>① 访问类字段（static字段）的指令：<code>getstatci、putstatic</code><br>② 访问类实例字段（非static字段）的指令：<code>getfield、putfield</code></p>
<h3 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h3><p><em>《深入理解Java虚拟机》P257</em></p>
<h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h4><p>① <code>invokevirtual</code>最常见的方法分派方式。<br>② <code>invokeinterface</code>调用接口方法。<br>③ <code>invokespecial</code>调用实例初始化方法、私有方法和父类方法。<br>④ <code>invokestatic</code>调用类中的类方法（static方法）。<br>⑤ <code>invokedynamic</code>调用动态绑定的方法。</p>
<h4 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h4><p>① <code>ireturn、lreturn、freturn、dreturn、areturn</code><br>如果当前返回的是synchronized方法，还会执行一个隐含的<code>monitorexit</code>指令，退出临界区。</p>
<h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><p><em>《深入理解Java虚拟机》P256</em></p>
<p>① <code>pop</code>：将栈顶的1个Slot数值出栈。例如一个short类型数值。<br>② <code>pop2</code>：将栈顶的2个Slot数值出栈。例如一个double类型的数值，或者2个int类型的数值。<br>③ <code>dup、dup2、dup_x1、dup2_x1、dup_x2、dup_x2</code>：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。<br>其中<code>dup</code>开头用于复制1个Slot的数据，<code>dup2</code>开头用于复制2个Slot的数据。不带<code>_x</code>表示仅复制，带<code>_x</code>表示复制栈顶数据并压入栈，<code>dup</code>和<code>_x</code>的系数相加表示要插入的位置。如<code>dup2_x1</code>插入栈顶下2+1=3个Slot下面。<br>④ <code>swap</code>：将栈最顶端的两个Slot数值位置交换。<br>⑤ <code>nop</code>：它的字节码为0x00，什么都不做，用于调试和占位。</p>
<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><h4 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h4><p>条件跳转指令通常和比较指令结合使用。<br>包括：<code>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull</code>，这些指令都接收两个字节的操作数，用于计算跳转的位置（16位符号整数作为当前位置的offset）。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifeq</td>
<td>栈顶int型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>栈顶int型数值不等于0时跳转</td>
</tr>
<tr>
<td>iflt</td>
<td>小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为null时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为null时跳转</td>
</tr>
</tbody></table>
<h4 id="比较条件跳转指令"><a href="#比较条件跳转指令" class="headerlink" title="比较条件跳转指令"></a>比较条件跳转指令</h4><p>包括<code>if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne</code>，其中<code>i</code>开头表示<code>int</code>型数据，<code>a</code>开头表示对象引用的比较。</p>
<h4 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h4><p>专为switch-case语句设计的，主要由<code>tableswitch</code>和<code>lookupswitch</code>。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tableswitch</td>
<td>用于switch语句跳转，case值连续，内部只存放起始值、终止值和若干偏移量，效率高</td>
</tr>
<tr>
<td>lookupswitch</td>
<td>用于switch语句跳转，case值不连续，内部存放离散的case-offset对，每次需要搜索全部case-offset对，效率低</td>
</tr>
</tbody></table>
<h4 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h4><p>① <code>goto</code>：接收2个字节的操作数，共同组成一个带符号的整数，用于指定执行的偏移量，指令执行的目的就是跳转到偏移量给定的位置处。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>goto</td>
<td>无条件跳转</td>
</tr>
<tr>
<td>goto_w</td>
<td>无条件跳转（宽索引）</td>
</tr>
<tr>
<td>jsr</td>
<td>跳转至指定16位offset位置，并将jsr下一条指令地址压入栈定</td>
</tr>
<tr>
<td>jsr_w</td>
<td>跳转至指定32位offset位置，并将jsr_w下一条指令地址压入栈顶</td>
</tr>
<tr>
<td>ret</td>
<td>返回至由指定的局部变量所给出的指令位置（一般与jsr、jsr_w联合使用）</td>
</tr>
</tbody></table>
<h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><p><em>《深入理解Java虚拟机》P258</em></p>
<h4 id="抛出异常指令"><a href="#抛出异常指令" class="headerlink" title="抛出异常指令"></a>抛出异常指令</h4><p>显式抛出异常：<code>athrow</code><br>自动抛出异常：<code>idiv、ldiv</code>等</p>
<h4 id="异常处理指令-1"><a href="#异常处理指令-1" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p>处理异常不使用字节码指令实现的，而是采用异常表完成。<br>如果一个方法定义了一个try-catch或者try-finally的异常处理，就会创建一个异常表。它包含了每个异常处理或者finally块的信息。异常表保存了每个异常处理信息。如<br>① 起始位置<br>② 结束为止<br>③ 程序计数器记录的代码处理的偏移地址<br>④ 被捕获的异常类在常量池中的索引</p>
<p>当一个异常被抛出时，JVM会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧。不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</p>
<h3 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h3><p><em>《深入理解Java虚拟机》P258</em></p>
<p>Java虚拟机支持两种同步结构：① 方法级的同步；② 方法内部一段指令序列的同步。</p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期分为以下7个阶段：</p>
<div align="center"><img src="classloadingp.png"></div>



<h3 id="过程1：Loading（加载）阶段"><a href="#过程1：Loading（加载）阶段" class="headerlink" title="过程1：Loading（加载）阶段"></a>过程1：Loading（加载）阶段</h3><p><em>《深入理解Java虚拟机》P267</em> </p>
<p>加载阶段Java虚拟机需要做以下三件事情：<br>① 通过一个类的全限定名来获取定义此类的二进制字节流。<br>② 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>③ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p>另外，数组类本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构造出来的。</p>
<h3 id="过程2：Linking（链接）阶段"><a href="#过程2：Linking（链接）阶段" class="headerlink" title="过程2：Linking（链接）阶段"></a>过程2：Linking（链接）阶段</h3><p><em>《深入理解Java虚拟机》P268</em> </p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证的目的是保证加载的字节码是合法、合理并符合规范的。包括：<br><strong>格式检查：</strong> 魔数检查，版本检查，长度检查。<br><strong>语义检查：</strong> 是否继承final，是否有父类，抽象方法是否有实现。<br><strong>字节码验证：</strong> 跳转指令是否指向正确位置，操作数类型是否合理。<br><strong>符号引用验证：</strong> 符号引用的直接引用是否存在。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段为类的<strong>静态变量</strong>分配内存，并将其初始化为默认值。<br>准备阶段<strong>不包括：</strong><br>① 对static final修饰的<strong>静态常量</strong>的情况，由于final在编译的时候就会分配了，准备阶段就会显式赋值。<br>② 实例变量的初始化，实例变量随着对象一起分配到Java堆中。<br>③ 代码执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkingTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> id; </span><br><span class="line">    <span class="comment">// 在准备阶段分配内存并初始化为默认值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 在编译阶段显式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String constStr1 = <span class="string">&quot;CONST&quot;</span>; </span><br><span class="line">    <span class="comment">// 在编译阶段显式赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String conStr2 = <span class="keyword">new</span> String(<span class="string">&quot;CONST&quot;</span>); </span><br><span class="line">    <span class="comment">// 与上不同，而是使用&lt;clinit&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，对应boolean的默认值就是false。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>准备阶段后就进入了解析阶段，将类、接口、字段和方法的符号引用转为直接引用。</p>
<h3 id="过程3：Initialization（初始化）阶段"><a href="#过程3：Initialization（初始化）阶段" class="headerlink" title="过程3：Initialization（初始化）阶段"></a>过程3：Initialization（初始化）阶段</h3><p><em>《深入理解Java虚拟机》P277</em></p>
<p>类的初始化时类装载的最后一个阶段，前面的步骤都没问题就表示类可以顺利装载到系统中，此时类才会开始执行Java字节码。（即在初始化阶段才真正开始执行类中定义的Java程序代码）。</p>
<p>初始化阶段的重要工作室执行类的初始化方法<code>:&lt;clinit&gt;()</code>方法。该方法仅能由Java编译器生成并由JVM调用，它是由类静态成员的赋值语句以及static语句块合并产生的。</p>
<p><strong>说明：</strong><br>在加载一个类之前会先加载该类的父类，因此父类的<code>&lt;clinit&gt;</code>方法总是在子类<code>&lt;clinit&gt;</code>之前被调用。<br>在以下情况，字节码文件中不包含<code>&lt;clinit&gt;()</code>方法：<br>① 一个类中并没有声明任何的类变量，也没有静态代码块时。<br>② 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时。<br>③ 一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哪些场景不会生成 &lt;clinit&gt;()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span></span>&#123;</span><br><span class="line">    <span class="comment">// 场景1：对于非静态字段，不管是否进行显式赋值，都不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景2：静态字段没有显示赋值也不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 场景3：static final修饰的基本数据类型字段在链接的准备阶段进行显式赋值，不会产生&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会生成&lt;clinit&gt;()</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num3 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于static final修饰的字段显式赋值的操作，赋值细节</span></span><br><span class="line"><span class="comment">// ① 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="comment">// ② 在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest2</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链接的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INT_CONSTANT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链接的准备环节赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s0 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在初始化阶段的&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String s1 = <span class="keyword">new</span> String(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结论：</span></span><br><span class="line"><span class="comment">// ① 对于基本数据类型的字段来说，如果使用static final修饰，</span></span><br><span class="line"><span class="comment">//   则显示赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment">// ② 对于引用数据类型，如果使用字面量方式赋值，且用static final修饰，</span></span><br><span class="line"><span class="comment">//   则显式赋值通常是在链接阶段的准备环节进行</span></span><br><span class="line"><span class="comment">// 排除上述的在链接阶段的准备环节赋值的情况，其他都在&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>&lt;clinit&gt;()</code>方法是带锁线程安全的。 </p>
<p>Java程序对类的初始化情况有两种，<strong>主动使用</strong>和<strong>被动使用</strong>。<strong>主动使用</strong>时<code>&lt;clinit&gt;()</code>方法就会被调用，<strong>被动使用</strong>时则不会被调用。</p>
<h4 id="类的主动使用："><a href="#类的主动使用：" class="headerlink" title="类的主动使用："></a>类的主动使用：</h4><p>① 当创建一个类时，比如new关键字，或者通过反射、克隆、反序列化。<br>② 当调用类的静态方法时，即当使用了字节码invokestatic指令。<br>③ 当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或putstatic指令。（对应访问变量、赋值变量操作）。<br>④ 当使用java.lang.reflect包中的（反射类）方法时。比如<code>Class.forName(&quot;com.company.java.Test&quot;)</code><br>⑤ 当初始化子类，如果发现其父类还没有进行过初始化，需要先触发其父类的初始化。<br>⑥ 如果一个接口定义了default方法，那么直接实现或者间接实现该接口的初始化，该接口要在其之前被初始化。<br>⑦ 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。<br>⑧ 当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）。</p>
<h4 id="类的被动使用："><a href="#类的被动使用：" class="headerlink" title="类的被动使用："></a>类的被动使用：</h4><p>① 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化。<br>② 通过数组定义引用，不会触发此类的初始化。<br>③ 引用常量不会触发此类或接口的初始化。因为常量在链接阶段已经被显式赋值了。<br>④ 调用ClassLoader类的LoadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<h3 id="过程4：类的Using（使用）"><a href="#过程4：类的Using（使用）" class="headerlink" title="过程4：类的Using（使用）"></a>过程4：类的Using（使用）</h3><p>任何一个类型在使用之前都必须经历<strong>加载</strong>、<strong>链接</strong>和<strong>初始化</strong>三个阶段。成功经历以上三个阶段的类型就可以等待被开发者使用了。</p>
<h3 id="过程5：类的Unloading（卸载）"><a href="#过程5：类的Unloading（卸载）" class="headerlink" title="过程5：类的Unloading（卸载）"></a>过程5：类的Unloading（卸载）</h3><h4 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h4><p>在类的加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类的加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>
<h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>当Sample类被加载、链接和初始化后，它的生命周期就开始。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。<br>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p>
<div align="center"><img src="classunload.png"></div>


<h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h4><p><strong>显示加载：</strong><br>在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。<br><strong>隐式加载：</strong><br>不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// 隐式加载</span></span><br><span class="line">        User u = <span class="keyword">new</span> User(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示加载</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line">        &#125;cahtch(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p><strong>类的唯一性：</strong><br>对于任意一个类，需要由<strong>加载它的类加载器</strong>和<strong>这个类本身</strong>一起确认其在Java虚拟机中的唯一性。每一个类加载器都有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试伪代码</span></span><br><span class="line"><span class="keyword">public</span> UserClassLoader extends ClassLoader&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Sring rootDir = <span class="string">&quot;E:\\IDEA\\Demo\\src\\&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            UserClassLoader loader1 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz1 = loader1.findCLass(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            UserClassLoader loader2 = <span class="keyword">new</span> UserClassLoader(rootDir);</span><br><span class="line">            Class clazz2 = loader2.findClass(<span class="string">&quot;com.company.java.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(clazz1 == clazz2); <span class="comment">// false </span></span><br><span class="line">            System.out.println(clazz1.getClassLoader()); <span class="comment">// com.company.java.UserClassLoader@1540e19d</span></span><br><span class="line">            System.out.println(clazz2.getClassLoader()); <span class="comment">// com.company.java.UserClassLoader@14ae5a5</span></span><br><span class="line">            <span class="comment">// 显然两个加载器是不同的</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的加载器-1"><a href="#类的加载器-1" class="headerlink" title="类的加载器"></a>类的加载器</h3><p><em>《深入理解Java虚拟机》P282</em><br>在<em>JVM学习笔记-上篇</em>中已有介绍。</p>
<p>引导类加载器（Boostrap ClassLoader）<br>扩展类加载器（Extension ClassLoader）<br>应用程序类加载器（Application ClassLoader）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader); <span class="comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图获取引导类加载器：失败</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader); <span class="comment">//null，因为引导类加载器使用C/C++编写的，不会对应Java中的一个对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对于核心类库，使用的是引导类加载器，获取其ClassLoader打印也应该是null</span></span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于用户自定义类，默认使用应用程序类加载器</span></span><br><span class="line">            ClassLoader classLoader1 = Class.forName(<span class="string">&quot;com.company.ClassLoaderTest2&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对于数组，不把它看做类的结构，故不使用类加载器去加载</span></span><br><span class="line">            String[] arrStr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader()); <span class="comment">//null，getClassLoader()返回的是数组中元素类型的类加载器一样的（即String），表示使用的是引导类加载器</span></span><br><span class="line">            System.out.println(arrStr.getClass()); <span class="comment">//class [Ljava.lang.String;</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双亲委托模式的弊端"><a href="#双亲委托模式的弊端" class="headerlink" title="双亲委托模式的弊端"></a>双亲委托模式的弊端</h4><p>检查类是否加载委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，引导类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用程序加载器中，为应用类。按照这种模式，应用类访问系统类是没有问题的，但是系统类访问应用类就会出现问题。比如在系统中提供了一个接口，该接口需要在应用类中得以实现，改接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在引导类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<h4 id="双亲委托模式的破坏"><a href="#双亲委托模式的破坏" class="headerlink" title="双亲委托模式的破坏"></a>双亲委托模式的破坏</h4><p><em>《深入理解Java虚拟机》P285</em></p>
<h4 id="热替换"><a href="#热替换" class="headerlink" title="热替换"></a>热替换</h4><p>热替换是指在程序运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现在正在运行的系统之上。<br>Java中通过使用ClassLoader来实现热替换。</p>
<div align="center"><img src="hotexchange.png"></div>
 

<h3 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h3><p>① 扩展机制被移除，扩展类加载器由于向后兼容性的问题被保留，不过被重命名为平台类加载器（Platform Classloader）。可以通过ClassLoader的新方法<code>getPlatformClassLoader()</code>来获取。<br>② 平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。现在引导类加载器、平台类加载器、应用程序类加载器全都继承于<code>jdk.internal.loader.BuiltinClassLoader</code>。<br>③ 在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器名称在调试时很有用。<br>④ 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但是为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。<br>⑤ 类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag"># 字节码</a>
              <a href="/tags/%E7%B1%BB/" rel="tag"># 类</a>
              <a href="/tags/Class/" rel="tag"># Class</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="prev" title="JVM学习笔记1-内存与垃圾回收">
                  <i class="fa fa-chevron-left"></i> JVM学习笔记1-内存与垃圾回收
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98/" rel="next" title="JVM学习笔记3-性能监控与调优">
                  JVM学习笔记3-性能监控与调优 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Etin Ban</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
