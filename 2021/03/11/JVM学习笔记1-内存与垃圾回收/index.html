<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="这一个月打算把JVM学习一下，顺便梳理下知识，写个文档方便以后看吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记1-内存与垃圾回收">
<meta property="og:url" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/index.html">
<meta property="og:site_name" content="Et1nnn&#39;s Notes">
<meta property="og:description" content="这一个月打算把JVM学习一下，顺便梳理下知识，写个文档方便以后看吧。">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/jvmposition.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/jvmstructure.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/classloader.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/classloadertype.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/runtimedataarea.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/pctest2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/vmstack.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/stackframe.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/dl3.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/jdk7heap.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/jdk8heap.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ygc1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ygc2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ygc3.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/methodarea.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/methodareajdk6.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/methodareajdk7.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/methodareajdk8.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ee.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/concurrent.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/parallel.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/mark-sweep.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/mark-copying.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/mark-compact.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/region.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/serial-parallel.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/cms.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/region.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/g1.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/rset.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/gczuhe.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/gczuhe2.png">
<meta property="og:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7gc.png">
<meta property="article:published_time" content="2021-03-11T12:46:46.000Z">
<meta property="article:modified_time" content="2021-04-21T13:28:04.000Z">
<meta property="article:author" content="Etin Ban">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="垃圾回收">
<meta property="article:tag" content="内存分配">
<meta property="article:tag" content="内存管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.png">


<link rel="canonical" href="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","path":"2021/03/11/JVM学习笔记1-内存与垃圾回收/","title":"JVM学习笔记1-内存与垃圾回收"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM学习笔记1-内存与垃圾回收 | Et1nnn's Notes</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Et1nnn's Notes</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">record every step</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">JVM发展史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.</span> <span class="nav-text">虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">JVM的位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">JVM整体结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.1.</span> <span class="nav-text">类加载子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">类的加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%EF%BC%88%E5%AF%B9%E5%BA%94%E5%9B%9B%E4%B8%AA%EF%BC%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">两种（对应四个）类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.3.</span> <span class="nav-text">双亲委派机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.1.4.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.5.</span> <span class="nav-text">类的主动使用和被动使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E6%97%A0OOM%E3%80%81%E6%97%A0GC%EF%BC%89"><span class="nav-number">3.2.2.</span> <span class="nav-text">程序计数器（无OOM、无GC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E6%9C%89OOM%E3%80%81%E6%9C%89SOF%E3%80%81%E6%97%A0GC%EF%BC%89"><span class="nav-number">3.2.3.</span> <span class="nav-text">虚拟机栈（有OOM、有SOF、无GC）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%88%E8%BF%90%E8%A1%8C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">栈运行的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%EF%BC%88Local-Variables%EF%BC%89"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">局部变量表（Local Variables）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88Operand-Stack%EF%BC%89"><span class="nav-number">3.2.3.3.</span> <span class="nav-text">操作数栈（Operand Stack）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%BF%9E%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="nav-number">3.2.3.4.</span> <span class="nav-text">动态连接（Dynamic Linking）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%87%BA%E5%8F%A3%EF%BC%88Return-Address%EF%BC%89"><span class="nav-number">3.2.3.5.</span> <span class="nav-text">方法出口（Return Address）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88%E6%9C%89OOM%EF%BC%8C%E6%9C%89SOF%EF%BC%8C%E6%97%A0GC%EF%BC%89"><span class="nav-number">3.2.4.</span> <span class="nav-text">本地方法栈（有OOM，有SOF，无GC）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%EF%BC%88%E6%9C%89OOM%EF%BC%8C%E6%9C%89GC%EF%BC%89"><span class="nav-number">3.2.5.</span> <span class="nav-text">堆（有OOM，有GC）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86%EF%BC%88%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA%EF%BC%89%EF%BC%9A"><span class="nav-number">3.2.5.1.</span> <span class="nav-text">堆空间的划分（分代收集理论）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">3.2.5.2.</span> <span class="nav-text">对象分配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Yong-Minor-Garbage-Collection-YGC-Minor-GC"><span class="nav-number">3.2.5.2.1.</span> <span class="nav-text">Yong&#x2F;Minor Garbage Collection(YGC&#x2F;Minor GC)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Partial-GC%E5%92%8CFull-GC"><span class="nav-number">3.2.5.2.2.</span> <span class="nav-text">Partial GC和Full GC</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.2.5.3.</span> <span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9C%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.2.5.4.</span> <span class="nav-text">从逃逸分析看内存分配策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLAB"><span class="nav-number">3.2.5.5.</span> <span class="nav-text">TLAB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.5.6.</span> <span class="nav-text">堆空间设置参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E6%9C%89OOM%EF%BC%8C%E6%9C%89GC%EF%BC%89"><span class="nav-number">3.2.6.</span> <span class="nav-text">方法区（有OOM，有GC）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HotSpot%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="nav-number">3.2.6.1.</span> <span class="nav-text">HotSpot中方法区的演进</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">3.2.6.2.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.6.3.</span> <span class="nav-text">方法区的垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.6.4.</span> <span class="nav-text">方法区设置参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">3.2.7.</span> <span class="nav-text">对象的实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.7.1.</span> <span class="nav-text">创建对象的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.7.2.</span> <span class="nav-text">创建对象的步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.2.7.3.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">3.2.7.4.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">3.2.8.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">3.3.</span> <span class="nav-text">执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="nav-number">3.3.1.</span> <span class="nav-text">字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%EF%BC%9A%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">前端编译：解释器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.3.3.</span> <span class="nav-text">后端编译：编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">JIT编译器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AOT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">AOT编译器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Graal%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">Graal编译器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%A4%A7%E6%88%90%E8%80%85%E2%80%94%E2%80%94HotSpot"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">集大成者——HotSpot</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringTable"><span class="nav-number">3.4.</span> <span class="nav-text">StringTable</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.1.</span> <span class="nav-text">字符串拼接操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">3.5.1.</span> <span class="nav-text">垃圾回收相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#System-gc"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">System.gc()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">内存溢出与内存泄露</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Stop-The-World"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">Stop-The-World</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">垃圾回收的并行与并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">3.5.1.5.</span> <span class="nav-text">安全点与安全区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">3.5.1.6.</span> <span class="nav-text">Java中的引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.</span> <span class="nav-text">垃圾回收相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">标记阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">清除阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="nav-number">3.5.2.2.1.</span> <span class="nav-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%88Mark-Copying%EF%BC%89"><span class="nav-number">3.5.2.2.2.</span> <span class="nav-text">标记-复制算法（Mark-Copying）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="nav-number">3.5.2.2.3.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.2.4.</span> <span class="nav-text">对比三种算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.3.</span> <span class="nav-text">增量收集算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.2.4.</span> <span class="nav-text">分区算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#finalization%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.2.5.</span> <span class="nav-text">finalization机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.5.3.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.3.1.</span> <span class="nav-text">Serial回收器：串行回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">3.5.3.2.</span> <span class="nav-text">ParNew回收器：并行回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">3.5.3.3.</span> <span class="nav-text">Parallel回收器：吞吐量优先</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">3.5.3.4.</span> <span class="nav-text">CMS回收器：低延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#CMS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%88%86%E4%B8%BA4%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">3.5.3.4.1.</span> <span class="nav-text">CMS工作流程分为4个阶段</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-number">3.5.3.5.</span> <span class="nav-text">G1回收器：区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">3.5.3.5.1.</span> <span class="nav-text">G1的特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">3.5.3.5.2.</span> <span class="nav-text">G1垃圾回收过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E7%9A%84Remembered-Set%EF%BC%88R-Set%EF%BC%89"><span class="nav-number">3.5.3.5.3.</span> <span class="nav-text">G1的Remembered Set（R Set）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8CGC%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB"><span class="nav-number">3.5.3.6.</span> <span class="nav-text">不同GC之间的组合关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC%E7%9A%84%E4%B8%BB%E8%A6%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">3.5.3.7.</span> <span class="nav-text">GC的主要性能指标</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%83%E7%A7%8D%E5%B8%B8%E8%A7%81GC%E6%AF%94%E8%BE%83"><span class="nav-number">3.5.3.8.</span> <span class="nav-text">七种常见GC比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E8%B5%B7%E4%B9%8B%E7%A7%80"><span class="nav-number">3.5.3.9.</span> <span class="nav-text">后起之秀</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Epsilon"><span class="nav-number">3.5.3.9.1.</span> <span class="nav-text">Epsilon</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Shenandoah-GC"><span class="nav-number">3.5.3.9.2.</span> <span class="nav-text">Shenandoah GC</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ZGC"><span class="nav-number">3.5.3.9.3.</span> <span class="nav-text">ZGC</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0"><span class="nav-number">3.5.3.10.</span> <span class="nav-text">GC日志打印</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Etin Ban</p>
  <div class="site-description" itemprop="description">磨刀不误砍柴工，读完硕士再打工</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Etin Ban">
      <meta itemprop="description" content="磨刀不误砍柴工，读完硕士再打工">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Et1nnn's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM学习笔记1-内存与垃圾回收
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-11 20:46:46" itemprop="dateCreated datePublished" datetime="2021-03-11T20:46:46+08:00">2021-03-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-21 21:28:04" itemprop="dateModified" datetime="2021-04-21T21:28:04+08:00">2021-04-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>这一个月打算把JVM学习一下，顺便梳理下知识，写个文档方便以后看吧。</p>
<div align="center"><img src="1.png"></div>

<span id="more"></span>

<h2 id="JVM发展史"><a href="#JVM发展史" class="headerlink" title="JVM发展史"></a>JVM发展史</h2><p>这一部分就简要介绍一下吧，Java虚拟机的发展按顺序可以写为：<br><em>Sun Classic/Exact VM</em>——&gt;<em>HotSpot VM</em>——&gt;<em>Mobile VM</em>——&gt;<em>JRockit 9</em>——&gt;<em>Liquid VM</em>、<em>Azul VM</em>——&gt;<em>Dalvik VM</em></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。系统虚拟机，如VMWare，是对物理计算机的仿真，提供一个可运行完整操作系统的平台。程序虚拟机，如JVM，专门为执行单个计算机指令而设计。<br>Java虚拟机是一台执行Java字节码的虚拟计算机，其运行的Java字节码不一定由Java语言编译而成。特点<strong>①一次编译，到处运行②自动内存管理③自动垃圾回收</strong>。</p>
<h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><div align="center"><img src="jvmposition.png" width="80%"/></div>

<p>JVM运行在操作系统之上，与硬件没有直接交互。</p>
<h2 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h2><div align="center"><img src="jvmstructure.png" width="60%"/></div>

<h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>$\bullet$ 类加载子系统负责从文件系统或者网络中加载Class文件，至于它是否可以运行，则由执行引擎决定。<br /><br>$\bullet$ 加载的类信息存在方法区中。   </p>
<div align="center"><img src="classloader.png" width="80%"/></div>

<h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p><strong>加载阶段：</strong><br>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p><strong>链接阶段：</strong><br><em>验证(Verify)：</em> 保证加载类的正确性。<br><em>准备(Prepare)：</em> 为类变量分配内存并设置该类变量的初值，即零值；准备阶段不包含final修饰的static，因为final在编译的时候就分配了，准备阶段会显式初始化；准备阶段不会为实例变量分配初始化。<br><em>解析(Resolve)：</em> 将常量池内的符号引用转换为直接引用的过程；解析操作往往伴随JVM在执行完初始化之后再执行。</p>
<p><strong>初始化阶段：</strong><br>$\bullet$ 初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程。<br>$\bullet$ 只有当类中存在静态成员变量的赋值操作时，才会有<code>&lt;clinit&gt;()</code>方法出现。<br>$\bullet$ <code>&lt;clinit&gt;()</code>不同于类的构造器。构造器是虚拟机视角下的<code>&lt;init&gt;()</code>。<br>$\bullet$ 若该类有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕。<br>$\bullet$ 虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</p>
<h4 id="两种（对应四个）类加载器"><a href="#两种（对应四个）类加载器" class="headerlink" title="两种（对应四个）类加载器"></a>两种（对应四个）类加载器</h4><p>JVM支持两种类型的类加载器：<strong>引导类加载器(Bootstrap ClassLoader)</strong> 和<strong>自定义类加载器(User-Defined ClassLoader)</strong> ，所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器，由于扩展类加载器(Extension ClassLoader)和系统类加载器(Application ClassLoader)都继承ClassLoader类，故属于自定义加载类。</p>
<div align="center"><img src="classloadertype.png" width="80%"/></div>

<p>对于用户自定义类，默认是使用系统类加载器进行加载的，而对于Java核心类，则使用引导类加载器进行加载。<br>图中四个类加载器之间不是继承关系！<br><strong>引导类加载器：</strong> 使用C/C++实现，嵌套在JVM内部；用来加载Java核心类库(JAVA_HOME/jre/lib路径下的类)；只加载包名为java、javax、sun等开头的类；加载扩展类加载器和系统类加载器；不继承ClassLoader；加载扩展类和应用程序类加载器，并指定为它们的父类加载器。<br><strong>扩展类加载器：</strong> 使用Java实现；继承于ClassLoader类；父类加载器为引导类加载器；用来加载java.ext.dirs系统属性所指定的目录中加载类库，或从jre/lib/ext路径下加载类库。<br><strong>应用程序类加载器：</strong> 使用Java实现；继承于ClassLoader类；父类加载器为扩展类加载器；用来加载java.class.path路径下的类；是程序中的默认类加载器。</p>
<p><strong>用户自定义类加载器：</strong> 它的默认父类加载器是应用程序类加载器；自定义加载器可以实现应用隔离；自定义类加载器通常需要继承于ClassLoader。</p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p><strong>避免类的重复加载，确保类的全局唯一性。</strong></p>
<p>①如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；<br>②如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的引导类加载器；<br>③如果父类加载器可以完成类加载任务，就成功返回；否则子加载器尝试自己加载。</p>
<p><em>例：假如要加载String类，默认先由系统类加载器进行加载，但根据双亲委派机制，系统类加载器要把加载任务委托给它的父类加载器：扩展类加载器，扩展类加载器还具有其父类加载器：引导类加载器，这样层层向上，来到了引导类加载器，由于String类是Java核心类库，属于引导类加载器的任务范围，所以直接由引导类加载器进行加载了。</em></p>
<p>双亲委派机制的优点：避免类的重复加载；保护程序安全，防止核心API被随意篡改（假如项目中有一个从网络传输来的伪装成java核心类库的jar包（java.lang.Attack)，在加载过程中，引导类加载器发现该jar包路径由java开头，于是自己执行加载任务，并加载JAVA_HOME/jre/lib下名字为Attack的的jar包，会发现没有这个jar包并抛出异常，避免了恶意攻击 <strong>（沙箱安全机制）</strong>。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>JVM中判断两个类是否为同一个类的条件：<br>$\bullet$ 类的完整类名必须一致，包括包名。<br /><br>$\bullet$ 加载这个类的类加载器必须相同。<br />   </p>
<h4 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h4><p><strong>主动使用：</strong><br>$\bullet$ 创建类的实例<br /><br>$\bullet$ 访问某个类或接口的静态变量，或者对该静态变量赋值<br /><br>$\bullet$ 调用类的静态方法<br /><br>$\bullet$ 反射(Class.forName(“java.long.String”))<br /><br>$\bullet$ 初始化一个类的子类<br /><br>$\bullet$ Java虚拟机启动时被标明启动类的类<br /><br>$\bullet$ JDK7开始提供的动态预言支持<br /><br><strong>被动使用：</strong><br>除了以上7种情况，其他使用Java类的方式都被看作是对类的被动使用。</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>运行时数据区(Runtime Data Area)包含5个部分：**方法区(Method Area)<strong>、</strong>堆(Heap)<strong>、</strong>虚拟机栈(Virtual Machine Stack)<strong>、</strong>程序计数器(Program Counter Register)<strong>、</strong>本地方法栈(Native Method Stack)**。</p>
<div align="center"><img src="runtimedataarea.png" width="80%"/></div>

<p>运行时数据区与<strong>执行引擎</strong>、<strong>本地方法库</strong>也有交互：字节码文件中的数据加载到运行时数据区，执行引擎将字节码文件编译成机器指令，机器指令在执行时从运行时数据区调取数据并使用；Java调用C中的方法时使用本地方法栈进行分配。 </p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>一个JVM对应着一个进程，只有一个Runtime实例，支持多线程。在HotSpot JVM中，每个线程与操作系统的本地线程直接映射，Java线程终止后，本地线程也被回收。</p>
<p>JVM中的线程分为守护线程和普通线程，JVM中只剩下守护线程时，JVM就可以退出了。</p>
<p>一个JVM进程中的所有线程共享方法区和堆，虚拟机栈、本地方法栈、程序计数器则是线程私有的。</p>
<h4 id="程序计数器（无OOM、无GC）"><a href="#程序计数器（无OOM、无GC）" class="headerlink" title="程序计数器（无OOM、无GC）"></a>程序计数器（无OOM、无GC）</h4><p>JVM中的程序计数器是对物理程序计数器的一种模拟，用于存储指向下一条指令的地址，由执行引擎读取该地址对应的下一条操作指令(即istore_3，把第三个变量保存到局部变量表中)，并操作局部变量表、操作数栈、把字节码指令翻译成机器指令。</p>
<div align="center"><img src="pctest2.png" width="60%"/></div>

<p><strong>为什么使用PC？</strong><br>PC使CPU来回切换线程时指导从哪继续执行，PC为线程私有，每个线程都有一个单独的PC，为了准确记录各个线程当前正在执行的字节码指令的地址。</p>
<h4 id="虚拟机栈（有OOM、有SOF、无GC）"><a href="#虚拟机栈（有OOM、有SOF、无GC）" class="headerlink" title="虚拟机栈（有OOM、有SOF、无GC）"></a>虚拟机栈（有OOM、有SOF、无GC）</h4><p>栈管运行，堆管存储。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧，用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法出口</strong>等信息。不同线程的栈帧之间不能相互引用。</p>
<p><strong>Java虚拟机规范允许Java栈的大小是动态的或是固定不变的。</strong><br>$\bullet$ 如果线程请求分配的栈容量超过Java虚拟机允许的最大容量，Java虚拟机会抛出一个<strong>StackOverflowError</strong>异常。<br>$\bullet$ 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，Java虚拟机会抛出一个<strong>OutOfMemoryError</strong>异常。<br>可以通过<code>-Xss1024k</code>这种方式设置线程的最大栈空间。   </p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pulbic <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"><img src="vmstack.png" width="50%"/></div>

<p>执行<em>methodA()</em> 的时候，为<em>methodA()</em> 创建一个栈帧，$i、j$ 依次入栈，最后会执行<em>methodB()</em> ，再为<em>methodB()</em> 创建一个栈帧，$k、p$ 依次入栈。栈顶方法为当前方法，只有当前方法是有效的。</p>
<h5 id="栈运行的原理"><a href="#栈运行的原理" class="headerlink" title="栈运行的原理"></a>栈运行的原理</h5><p>$\bullet$ 不同线程中所包含的栈帧是不允许相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。<br /><br>$\bullet$ 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的返回结果给前一个栈帧，接着，虚拟机会丢弃该栈帧，使得前一个栈帧称为当前栈帧。<br /><br>$\bullet$ Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另一种是抛出异常。两种方式都会导致栈帧被弹出。<br /></p>
<p><strong>栈帧的内部结构</strong></p>
<div align="center"><img src="stackframe.png" width="80%"/></div>

<h5 id="局部变量表（Local-Variables）"><a href="#局部变量表（Local-Variables）" class="headerlink" title="局部变量表（Local Variables）"></a>局部变量表（Local Variables）</h5><p>$\bullet$ 用数组实现，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型（int、double等）、对象引用（reference），以及returnAddress类型。<br /><br>$\bullet$ 这些数据类型在局部变量表中的存储空间以<strong>局部变量槽（Slot）</strong> 来表示，32位的数据类型占用1个Slot，64位数据类型（long、double）占用两个Slot。<br>$\bullet$ 局部变量表所需的容量大小在编译期确定，运行期间大小不变。<br /><br>$\bullet$ 是线程的私有数据，不存在安全问题。<br /><br>$\bullet$ 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会放在index为0的Slot处。<br /></p>
<p>栈帧中与性能调优关系最密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。<br>局部变量表中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h5 id="操作数栈（Operand-Stack）"><a href="#操作数栈（Operand-Stack）" class="headerlink" title="操作数栈（Operand Stack）"></a>操作数栈（Operand Stack）</h5><p>用数组实现。在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈、出栈。<br>$\bullet$ 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。<br /><br>$\bullet$ <strong>操作数栈是JVM执行引擎的一个工作区</strong>，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。<br>$\bullet$ 操作数栈的深度在编译期确定。<br /><br>$\bullet$ 与局部变量表中的Slot类似，32位的数据占用一个栈单位深度，64位的数据占用两个栈单位深度。<br /><br>$\bullet$ 栈只能通过出栈（Pop）和入栈（Push）操作数据。<br /><br>$\bullet$ 方法有返回值的话，返回值存入当前栈帧的操作数栈中。<br /><br>$\bullet$ Java虚拟机的解释引擎是基于操作数栈的执行引擎。<br /></p>
<p><strong>栈顶缓存技术：</strong><br>HotSpot JVM使用栈顶缓存技术（ToS, Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低内存的读/写次数，提升执行引擎的执行效率。</p>
<h5 id="动态连接（Dynamic-Linking）"><a href="#动态连接（Dynamic-Linking）" class="headerlink" title="动态连接（Dynamic Linking）"></a>动态连接（Dynamic Linking）</h5><p>$\bullet$ 动态连接是帧中保存的<strong>指向运行时常量池</strong>的方法引用。<br>$\bullet$ 在class文件的常量池中，描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，动态连接的作用就是将这些符号引用转换为调用方法的直接引用。<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    methodB();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><img src="dl3.png" width="80%"/></div>

<p><strong>方法的调用：</strong><br><strong>静态连接：</strong> 如果被调用的目标方法在编译期可知，且运行期保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程称为静态连接。<br><strong>动态连接：</strong> 如果被调用的目标方法在编译期无法确定，只能在运行期将调用方法的符号引用转换位直接引用，这种转换过程具有动态性，因此被称为动态连接。<br><strong>非虚方法：</strong> 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，如静态方法、私有方法、final方法、实例构造器、弗雷方法。<br><strong>虚方法：</strong> 其他的方法称为虚方法。</p>
<p><strong>方法调用指令：</strong><br>普通调用指令：<br>$\bullet$ invokestatic：调用静态方法，解析阶段确定唯一方法版本。<br /><br>$\bullet$ invokespecial：调用<code>&lt;init&gt;</code>方法、私有方法、父类方法，解析阶段确定唯一方法版本。<br>$\bullet$ invokevirtual：调用所有虚方法。<br /><br>$\bullet$ invokeinterface：调用接口方法。<br /></p>
<p>动态调用指令：<br>$\bullet$ invokedynamic：动态解析出需要调用的方法，然后执行。<br /></p>
<h5 id="方法出口（Return-Address）"><a href="#方法出口（Return-Address）" class="headerlink" title="方法出口（Return Address）"></a>方法出口（Return Address）</h5><p>方法结束有两种方式：①正常执行完成；②出现未处理的异常，非正常退出。<br>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。<strong>方法正常退出时</strong>，调用者PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。<strong>异常退出时</strong>，返回地址通过异常表现来确定，栈帧中一般不会保存这部分信息。</p>
<h4 id="本地方法栈（有OOM，有SOF，无GC）"><a href="#本地方法栈（有OOM，有SOF，无GC）" class="headerlink" title="本地方法栈（有OOM，有SOF，无GC）"></a>本地方法栈（有OOM，有SOF，无GC）</h4><p><strong>本地方法库：</strong><br>有时Java应用需要与Java外面的环境交互这是本地方法存在的主要原因。目前该方法使用的越来越少了，除非是与硬件有关的应用。</p>
<p>Java虚拟机栈用于管理Java方法的调用，本地方法栈用于管理本地方法的调用。<br>$\bullet$ 本地方法栈允许被实现成固定或者是可动态扩展的内存大小。与VM栈基本相同，也有OOM和SOF。<br /><br>$\bullet$ 本地方法是用C语言实现的。<br /><br>$\bullet$ 具体做法是在本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库。<br /><br>$\bullet$ 当某个线程调用一个本地方法时，它就进入了一个全新的不再受虚拟机管制的世界。<br /><br>$\bullet$ 并不是所有的JVM都支持本地方法，HotSpot JVM中，将本地方法栈和虚拟机栈合二为一。<br /></p>
<h4 id="堆（有OOM，有GC）"><a href="#堆（有OOM，有GC）" class="headerlink" title="堆（有OOM，有GC）"></a>堆（有OOM，有GC）</h4><p>Java堆是被所有线程共享的一块内存区域，也是垃圾收集器管理的内存区域，在虚拟机启动时创建并确定空间大小，但是大小可调节。此内存区域的唯一目的是存放对象实例。</p>
<p>$\bullet$ 栈中存放普通数据和引用数据类型的地址，堆中存放相应的实例对象，栈中的值都被弹出时，堆中的对象不会立即被回收，只有在堆空间不足时，才会调用GC，清理没有被引用的实例。<br /><br>$\bullet$ Java堆可以处于物理上不连续的空间中，但在逻辑上它是连续的。<br /><br>$\bullet$ 并不是所有的对象都在堆上分配内存，也存在栈上分配——逃逸分析（Escape Analysis）<br /><br>$\bullet$ 堆是执行GC的重点区域。<br /></p>
<h5 id="堆空间的划分（分代收集理论）："><a href="#堆空间的划分（分代收集理论）：" class="headerlink" title="堆空间的划分（分代收集理论）："></a>堆空间的划分（分代收集理论）：</h5><p><strong>JDK 1.7及之前</strong><br>$\bullet$ 新生代（New/Young Generation Space）<br /><br>$\bullet$ 老年代（Old/Tenure Generation Space）<br /><br>$\bullet$ 永久代（Permanent Generation）<br /></p>
<div align="center"><img src="jdk7heap.png" width="80%"/></div>

<p><strong>JDK 1.8及以后</strong><br>$\bullet$ 新生代（New/Young Generation Space）<br /><br>$\bullet$ 老年代（Old/Tenure Generation Space）<br /><br>$\bullet$ 元空间（Meta Space）<br /></p>
<p>默认情况下：<br>新生代 $:$ 老年代 $=$ 1 $:$ 2 <br /><br>Eden $:$ S0 $:$ S1 $=$ 8 $:$ 1 $:$ 1 <br /><br>如果默认不是以上比例，关闭自适应内存分配策略<code>-XX:-UseAdaptiveSizePolicy</code></p>
<div align="center"><img src="jdk8heap.png" width="80%"/></div>

<p>存储在JVM中的Java对象可以分为两类：<br>$\bullet$ 生命周期较短，这类对象的创建和消亡都非常迅速。<br /><br>$\bullet$ 生命周期非常长，在某些极端情况下与JVM生命周期保持一致。<br /><br>$\bullet$ 几乎所有的Java对象都是在Eden区被new出来的。<br /><br>$\bullet$ 绝大部分的Java对象在新生代中就被销毁了（朝生夕死，寿命很短）。<br /></p>
<h5 id="对象分配过程"><a href="#对象分配过程" class="headerlink" title="对象分配过程"></a>对象分配过程</h5><h6 id="Yong-Minor-Garbage-Collection-YGC-Minor-GC"><a href="#Yong-Minor-Garbage-Collection-YGC-Minor-GC" class="headerlink" title="Yong/Minor Garbage Collection(YGC/Minor GC)"></a>Yong/Minor Garbage Collection(YGC/Minor GC)</h6><div align="center"><img src="ygc1.png" width="80%"></div>

<p>对象首先分配在Eden，当Eden满的时候，会触发YGC（Minor GC）（GC的同时会出现STW，Stop-The-World，停止用户线程），判断哪些对象是垃圾，哪些不是垃圾，图中红色对象是垃圾，绿色是仍要使用的对象。GC后仍要使用的对象被放入S0区，且寿命加1。</p>
<div align="center"><img src="ygc2.png" width="80%"></div>

<p>Eden的空间被清理干净后，继续会有新的对象分配进来，当Eden满的时候会再次执行GC，Eden中需要继续使用的对象放入S1区中，同时S0中的两个对象也要进行GC，判断哪些是垃圾哪些还要继续使用，S0中需要继续使用的对象也放入S1区中，此时的S0区相当于from区，S1区相当于to区，未被GC的对象寿命均加1。</p>
<div align="center"><img src="ygc3.png" width="80%"></div>

<p>Eden不断被占满、GC的过程周而复始，如图，当S1区中有对象的寿命已经达到15（年龄阈值，默认为15，TenuringThreshold）且仍要继续使用时，这些对象会进行promotion（晋升），放入老年代中。</p>
<p><strong>总结：</strong><br>$\bullet$ GC频繁在新生代收集，很少在老年代收集，几乎不在元空间收集。<br /><br>$\bullet$ 只有当Eden满的时候才会触发YGC，S0、S1满不会触发YGC；YGC一旦触发，会对Eden、S0、S1都进行回收。<br /><br>$\bullet$ <strong>内存分配的特殊情况：</strong>对于超大对象，①Eden中放的下但S0或S1区中放不下，直接晋升到老年代；②如果进行YGC之后Eden中仍然没有足够的空间、或Eden本身的空间就小于对象大小，那么该对象将被直接放入老年代，如果老年代也放不下，进行Major GC，对老年代进行垃圾回收，如果Major GC后的空间足以放下对象，则将对象放入老年代，如果Major GC后的空间仍然不足，抛出OOM。<br>$\bullet$ 堆空间分代的理由就是优化GC性能，不同代进行GC的频率不同。如果不分代，每次GC都要扫描整个堆空间。<br /></p>
<h6 id="Partial-GC和Full-GC"><a href="#Partial-GC和Full-GC" class="headerlink" title="Partial GC和Full GC"></a>Partial GC和Full GC</h6><p><strong>Partial GC:指目标不是完整收集整个Java堆的垃圾收集，分为下面几种</strong><br>$\bullet$ Minor GC/Young GC，新生代的垃圾收集。<br /><br>$\bullet$ Major GC/Old GC，老年代的垃圾收集，（Full GC和Major GC有时会混淆使用，指代老年代收集，要根据上下文区分），Major GC比Minor GC慢10倍以上，STW更长，Major GC后内存还不足就报OOM。<br /><br>$\bullet$ Mixed GC，整个新生代以及部分老年代的垃圾收集，只有G1收集器会有这种行为。<br /><br><strong>Full GC：指目标是整个Java堆和方法区的垃圾收集</strong></p>
<h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><p>$\bullet$ 优先分配到Eden。<br /><br>$\bullet$ 大对象直接分配到老年代，但要尽量避免程序中出现过多的大对象。<br /><br>$\bullet$ 长期存活的对象分配到老年代。<br /><br>$\bullet$ 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。<br /><br>$\bullet$ 空间分配担保，Eden进行Minor GC后仍有很多对象存活，且Survivor区中不足以容纳这些对象时，需要老年代提供空间分配担保。<code>-XX:HandlePromotionFailure</code><br /></p>
<h5 id="从逃逸分析看内存分配策略"><a href="#从逃逸分析看内存分配策略" class="headerlink" title="从逃逸分析看内存分配策略"></a>从逃逸分析看内存分配策略</h5><p>之前提到，堆并不是对象存储的唯一选择，经过<strong>逃逸分析（Escape Analysis）</strong>后，如果发现一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否发生逃逸的关键，看new的对象是否有可能在方法外被调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 1，未发生逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    V v = <span class="keyword">new</span> V();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    v = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 2, 发生逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 3, 未发生逃逸 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example 4， 发生逃逸</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapeAnalysis</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EscapeAnalysis <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">new</span> EscapeAnalysis() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用逃逸分析，编译器可以对代码做如下优化：<br>$\bullet$ <strong>栈上分配</strong>，将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的首选。线程结束，栈空间被回收，局部变量对象也被回收，这样就无需GC。<br>$\bullet$ <strong>同步省略</strong>，如果一个对象发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。线程同步的代价很高，会降低并发性和性能，锁对象只能被一个线程访问而没有被发布到其他线程时，可以取消同步（同步省略），也叫锁消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis)&#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">            <span class="function">v</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object hollis = <span class="keyword">new</span> Object();</span><br><span class="line">    System.out.println(hollis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$\bullet$ <strong>分离对象或标量替换</strong>，有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。标量（Scalar）指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。还可以再分解的数据叫聚合量（Aggregate），如Java中的对象。在JIT阶段，经过逃逸分析发现一个对象不会被外界访问的话，就会把这个对象拆解成若干个其中包含若干个成员变量来代替。这个过程就是标量替换。</p>
<h5 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h5><p>为什么有TLAB？<br>$\bullet$ 堆区是线程共享区域，任何线程都可以访问堆区的共享数据。<br /><br>$\bullet$ 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。<br /><br>$\bullet$ 为了避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。<br /></p>
<p>TLAB，Thread Local Allocation Buffer（%1Eden），对Eden区进行划分，JVM为每个线程分配了一个私有缓存区域，可以避免非线程安全问题，并提升内存分配吞吐量（称为快速分配策略），对象大于TLAB大小时，在剩余Eden空间进行分配。</p>
<h5 id="堆空间设置参数"><a href="#堆空间设置参数" class="headerlink" title="堆空间设置参数"></a>堆空间设置参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintFlagsInitial: 查看所有参数初始默认值</span><br><span class="line">-XX:+PrintFlagsFinal: 查看所有参数最终值</span><br><span class="line">-Xms256m: 初始堆空间设置为256MB，默认为物理内存的<span class="number">1</span>/<span class="number">64</span></span><br><span class="line">-Xmx256m: 最大堆空间内存设置为256MB，默认为物理内存的<span class="number">1</span>/<span class="number">4</span>，建议将初始堆内存和最大堆内存设置成一样大</span><br><span class="line">-Xmn128m: 新生代大小设置为128MB</span><br><span class="line">-XX:NewRatio=<span class="number">2</span>: 老年代:新生代 比例为<span class="number">2</span></span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span>: Eden:S0/S1 比例为<span class="number">8</span></span><br><span class="line">-XX:MaxTenuringThreshold: 新生代垃圾最大年龄阈值</span><br><span class="line">-XX:+PrintGCDetails: 打印GC日志</span><br><span class="line"></span><br><span class="line">cmd指令：</span><br><span class="line">jps: 查看JVM进程号</span><br><span class="line">jinfo -flag NewRatio 进程号: 查看JVM老年代与新生代的比例</span><br></pre></td></tr></table></figure>

<h4 id="方法区（有OOM，有GC）"><a href="#方法区（有OOM，有GC）" class="headerlink" title="方法区（有OOM，有GC）"></a>方法区（有OOM，有GC）</h4><p>栈、堆、方法区的交互关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法区 java栈      java堆</span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>逻辑上将方法区看做堆的一部分，堆有GC和压缩算法（处理内存碎片），方法区可能没有对二者的实现，方法区还有一个别名叫Non-Heap（非堆），目的就是要与堆分开。所以，方法区看做是一块独立于Java堆的内存空间。</p>
<div align="ceneter"><img src="methodarea.png" width="80%"/></div>

<p>$\bullet$ 方法区与Java堆一样，是各个线程共享的内存区域。<br /><br>$\bullet$ 方法区在JVM启动的时候被创建，它在实际物理内存空间中不一定是连续的，与堆一样。<br /><br>$\bullet$ 方法区的大小可以选择固定大小或可扩展，与堆一样。<br /><br>$\bullet$ 方法区的大小决定系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出OOM错误（①加载大量第三方Jar包②Tomcat部署工程过多（30-50个）③大量动态的生成反射类）。<br /><br>$\bullet$ 关闭JVM就会释放方法区的内存。<br /></p>
<h5 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h5><p>JDK 1.7及以前，方法区称为永久代。JDK 1.8及以后，使用元空间取代了永久代。本质上，方法区和永久代并不等价。（永久代更像是HotSpot虚拟机中的方言，在JDK 1.7及以前把方法区叫做永久代，在JDK 1.8及以后把方法区叫做元空间。在其他Java虚拟机中，如BEA JRockit和IBM J9，方法区就是方法区，没有永久代的叫法。）</p>
<p>永久代与元空间的最大区别在于：元空间不再虚拟机设置的内存中，而是使用本地内存，不只是名字变了，内部结构也发生了变化。</p>
<p><strong>方法区演进细节</strong></p>
<p><strong>JDK 1.6及以前：</strong><br>有永久代，静态变量存放在永久代。</p>
<div align="center"><img src="methodareajdk6.png" width="70%"/></div>

<p><strong>JDK 1.7：</strong><br>有永久代，但已逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中。</p>
<div align="center"><img src="methodareajdk7.png" width="70%"/></div>

<p><strong>JDK 1.8及以后：</strong><br>使用本地内存，无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆。</p>
<div align="center"><img src="methodareajdk8.png" width="70%"/></div>

<p><strong>调整StringTable位置的原因：</strong><br>JDK 1.7中将StringTable放到了堆空间里，因为永久代的回收效率很低，在Full GC时才会触发，而Full GC只有在老年代、永久代空间不足时才会出现。这就导致StringTable回收效率不高，而开发时会有大量字符串被创建，回收效率低会导致永久代内存不足，放到堆里可以及时回收内存。</p>
<p><strong>静态变量的位置</strong><br>对于静态变量，它的对象实体始终都存在堆空间里，而指向对象实体的静态引用从方法区转移到了堆中，故在JDK 1.8中，静态变量与类型都存储在堆中。</p>
<p><strong>为什么用元空间替换永久代？</strong><br>①是完成JRockit与HotSpot融合工作的一部分，JRockit中没有永久代。<br>②为永久代设置的空间大小很难确定。<br>③对永久代调优困难。</p>
<h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，字节码文件中的常量池加载到方法区后，就称为运行时常量池，包含数量值、字符串值、类引用、字段引用、方法引用。如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，JVM就会抛出OOM异常。</p>
<p>常量池可以看做成一张表，它的作用就就是使虚拟机根据这张表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h5 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h5><p>方法区的有时也会需要垃圾回收，但是效果往往难以令人满意。它主要回收两部分内容：①常量池中废弃的常量；②不再使用的类型。</p>
<p>废弃的常量判断：没有被任何地方引用，就可以回收。<br>废弃的类型判断：①该类所有的实例（该类及派生子类）都已经被回收；②加载该类的加载器都已经被回收；③该类对应的java.lang.Class对象没有在任何地方被引用（即不能再通过反射访问）。</p>
<h5 id="方法区设置参数"><a href="#方法区设置参数" class="headerlink" title="方法区设置参数"></a>方法区设置参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">1.7</span></span><br><span class="line">-XX:PermSize=100m 为永久代设置初始分配空间，默认值<span class="number">20.</span>75MB</span><br><span class="line">-XX:MaxPerSize=100m 为永久代设置最大可分配空间，<span class="number">32</span>位机器默认值64MB，<span class="number">64</span>位机器默认值82MB</span><br><span class="line"></span><br><span class="line">JDK <span class="number">1.8</span></span><br><span class="line">-XX:MetaspaceSize=100m 为元空间设置初始分配空间，默认值21MB</span><br><span class="line">-XX:MaxMetaspaceSize=100m 为元空间设置最大可分配空间，默认值-<span class="number">1</span>，表示没有限制</span><br></pre></td></tr></table></figure>

<h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><h5 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h5><p>$\bullet$ new<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m a person.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line">PersonBuilder或PersonFactory的静态方法</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 反射<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种，Class的newInstance，只能调用空参的构造器，权限必须是public</span></span><br><span class="line">Object person = Class.forName(<span class="string">&quot;Person&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种，Constructor的newInstance，可以调用空参和带参的构造器，权限无要求</span></span><br><span class="line"><span class="comment">// 空参</span></span><br><span class="line">Constructor person1 = Class.forName(<span class="string">&quot;Person&quot;</span>).getDeclaredConstructor().newInstance();</span><br><span class="line"><span class="comment">// 带参</span></span><br><span class="line">Constructor person2 = Class.forName(<span class="string">&quot;Person&quot;</span>).getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;).newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">5</span>,<span class="number">6</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 使用clone()，不调用任何的构造器，但当前的类需要实现Cloneable()接口，实现clone()方法。<br /><br>$\bullet$ 使用反序列化：从文件中或网络中获取对象的二进制流，还原成内存中的对象。<br /><br>$\bullet$ 使用第三方库Objenesis。<br /></p>
<h5 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h5><p>$\bullet$ 判断对象对应的类是否加载、链接、初始化（加载对象所处的类）。<br /><br>$\bullet$ 为对象分配内存。①如果内存规整：指针碰撞（指针指向可用内存的起始地址，每分配一部分空间，指针向后移动分配出的空间大小，再次指向可用内存）；②如果内存不规整：虚拟机维护一个列表（记录哪些内存块是可用的），在列表中找到足够大的空间分配给对象实例，称为空闲列表。<br /><br>$\bullet$ 处理并发安全问题。①采用CAS（Compare And Swap）配上失败重试保证更新的原子性。②每个线程预先分配一个TLAB。<br /><br>$\bullet$ 初始化分配到的空间，所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。<br /><br>$\bullet$ 设置对象的对象头。<br /><br>$\bullet$ 执行init方法进行初始化，初始化后一个真正可用额对象才被完全创建出来。<br /></p>
<h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>$\bullet$ <strong>对象头</strong>，包含<strong>①运行时元数据</strong>（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）<strong>②类型指针</strong>，指向类元数据InstanceClass，确定该对象所属的类型。<br>$\bullet$ <strong>实例数据</strong>，这是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段。<br>$\bullet$ <strong>对齐填充</strong>，仅仅起到占位符的作用。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。<br><strong>句柄访问：</strong><br>①优点：稳定句柄地址，对象被移动时只改变句柄中的实例数据指针，栈空间的地址不需要修改。<br>②缺点：有空间开销，且访问效率较低。<br><strong>直接指针（HotSpot采用）：</strong><br>①优点：速度快，节省了一次指针定位的开销。<br>②缺点：对象被移动时，栈空间中的地址要进行修改。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存不是虚拟机运行时数据区的一部分，而是Java堆外的、直接向系统申请的内存区间。通常访问直接内存的速度会优于Java堆，即读写性能高。<br>$\bullet$ 读写频繁的场合会考虑使用直接内存。<br /><br>$\bullet$ Java的NIO（New IO/Non-Blocking IO）库允许Java程序使用直接内存，用于数据缓存区。<br /><br>$\bullet$ 也有OOM。<br /><br>$\bullet$ 缺点：分配回收成本高；不受JVM内存回收管理。<br /><br>$\bullet$ 通过<code>-XX:MaxDirectMemorySize</code>设置。<br /></p>
<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><p>虚拟机的执行引擎是由软件自行实现的，不受物理条件限制地定制指令集和执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。<br>JVM的主要任务是负责装载字节码到其内部，执行引擎的任务是把字节码指令解释/编译为对应平台上的本地机器指令，充当了将高级语言翻译为机器语言的译者。</p>
<div align="center"><img src="ee.png" width="80%"></div>

<p>Java是半编译半解释型语言，既包括解释器，有包括编译器，在执行Java代码时，解释执行和编译执行二者结合起来进行。</p>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>字节码是一种中间状态的二进制代码，比机器码更加抽象，需要翻译后才能成为机器码。</p>
<h4 id="前端编译：解释器"><a href="#前端编译：解释器" class="headerlink" title="前端编译：解释器"></a>前端编译：解释器</h4><p>当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将字节码文件中每条指令“翻译”为对应平台的本地机器指令执行。<br>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<p>前端编译器不包含在JVM中。</p>
<h4 id="后端编译：编译器"><a href="#后端编译：编译器" class="headerlink" title="后端编译：编译器"></a>后端编译：编译器</h4><h5 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h5><p>JIT（Just In Time Compiler）即时编译器是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。<br><strong>热点代码：</strong><br>根据字节码中的代码被调用执行的频率，决定需要直接编译为对应平台本地机器指令的代码，这些需要被编译为本地代码的字节码，称为“热点代码”。JIT会对被频繁调用的“热点代码”做深度优化。<br>如：一个被多次调用的方法，循环次数较多的循环体。由于JIT在编译这些代码时发生在方法执行过程中，故称为栈上替换（OSR， On Stack Replacement）。<br>HotSpot中采用的热点探测方式是基于计数器的热点探测（使用热度衰减）。</p>
<h5 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h5><p>AOT（Ahead Of Time Compiler）提前编译器<strong>在程序运行之前</strong>直接把程序编译成与目标机器指令集相关的二进制代码。<br>AOT编译的过程为：.java$\rightarrow$.class$\rightarrow$.so(机器码)<br>由于机器码与硬件是紧密相关的，所以AOT其实破坏了Java“一次编译，导出运行”的特性。</p>
<h5 id="Graal编译器"><a href="#Graal编译器" class="headerlink" title="Graal编译器"></a>Graal编译器</h5><p>JDK 10中加入的新的即时编译器，仍在Experimental状态。使用<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMC1Compiler</code>，效果已追平C2编译器。</p>
<h5 id="集大成者——HotSpot"><a href="#集大成者——HotSpot" class="headerlink" title="集大成者——HotSpot"></a>集大成者——HotSpot</h5><p>HotSpot采用解释器与即时编译器并存的架构，在JVM运行时，解释器和即时编译器能够相互协作，选择最合适的方式权衡直接解释执行代码和编译本地代码的时间。<br>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。而编译器需要先将代码编译成本地代码，需要一定的执行时间，但编译为本地代码后，执行效率高。<br>当Java虚拟机启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<br>同时，解释执行在编译执行进行激进优化不成立的时候，作为编译器的“逃生门”。<br><strong>C1和C2编译器：</strong><br>在HotSpot中，有两个JIT编译器，分别为Client Compiler和Server Compiler，简称为C1和C2编译器。C1编译器会对字节码进行简单和可靠地优化，耗时短；C2编译器会进行激进优化，耗时长，但优化的代码执行效率更高。基于逃逸分析，C2的优化有标量替换、栈上分配、同步消除。</p>
<h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><h4 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h4><p>$\bullet$ 常量与常量的拼接结果在常量池，原理是编译器优化。<br /><br>$\bullet$ 常量池中不会存在相同内容的变量。<br /><br>$\bullet$ 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder。<br /><br>$\bullet$ 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回次对象地址。<br /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StringTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s3 = <span class="string">&quot;stringtable&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;string&quot;</span> + <span class="string">&quot;table&quot;</span>; <span class="comment">//编译期优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是变量拼接，需要在堆空间中new String()，字符串内容为拼接后的结果</span></span><br><span class="line">    String s5 = s1 + <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;string&quot;</span> + s2;</span><br><span class="line"></span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    s1 + s2 的细节：</span></span><br><span class="line"><span class="comment">    StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">    s.append(&quot;string&quot;);</span></span><br><span class="line"><span class="comment">    s.append(&quot;table&quot;);</span></span><br><span class="line"><span class="comment">    s.toString()  ---&gt; 约等于new String(&quot;stringtable&quot;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    【StringBuilder.append()方法比拼接符&quot;+&quot;的速度快。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ①：StringBuilder.append()自始至终只创建一个StringBuilder对象；</span></span><br><span class="line"><span class="comment">    &quot;+&quot;拼接方式则创建了多个StringBuilder和String对象；</span></span><br><span class="line"><span class="comment">    ②：使用&quot;+&quot;拼接方式，内存中由于创建了较多的StringBuilder和String对象，</span></span><br><span class="line"><span class="comment">    内存占用更大，如果进行GC，需要花费更多的时间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在实际开发中，如果基本确定前后添加的字符串长度不高于某个限定值highlevel的情况下，建议使用构造器：</span></span><br><span class="line"><span class="comment">    StringBuilder s = new StringBuilder(highlevel); // new char [highlevel]】</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* intern()：判断字符串常量池中是否存在&quot;stringtable&quot;值，</span></span><br><span class="line"><span class="comment">     *如果存在，则返回常量池中&quot;stringtable&quot;的地址，</span></span><br><span class="line"><span class="comment">     *如果不存在，则在常量池中加载一份&quot;stringtable&quot;，并返回该对象的地址。*/</span></span><br><span class="line">    String s8 = s6.intern();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定都使用StringBuilder</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，</span></span><br><span class="line"><span class="comment">       则仍然使用编译期优化，即非StringBuilder的方式</span></span><br><span class="line"><span class="comment">    2. 针对与final修饰类、方法、基本数据类型、引用数据类型的，</span></span><br><span class="line"><span class="comment">       能使用final则建议使用final</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">final</span> String s9 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s10 = <span class="string">&quot;table&quot;</span>;</span><br><span class="line">    String s11 = s9 + s10;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    s3 == s4 true</span></span><br><span class="line"><span class="comment">    s3 == s5 false</span></span><br><span class="line"><span class="comment">    s3 == s6 false</span></span><br><span class="line"><span class="comment">    s3 == s7 false</span></span><br><span class="line"><span class="comment">    s5 == s6 false</span></span><br><span class="line"><span class="comment">    s5 == s7 false</span></span><br><span class="line"><span class="comment">    s6 == s7 false</span></span><br><span class="line"><span class="comment">    s3 == s8 true</span></span><br><span class="line"><span class="comment">    s3 == s11 true</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如何保证变量s指向的是字符串常量池的数据：</span></span><br><span class="line"><span class="comment">    1. String s = &quot;stringtable&quot;; // 字面量定义</span></span><br><span class="line"><span class="comment">    2. String s = new String(&quot;stringtable&quot;).intern();</span></span><br><span class="line"><span class="comment">       String s = new StringBuilder(&quot;stringtable&quot;).toString().intern();</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">StringTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// jdk7后把字符串常量池放在了堆中，所有jdk版本不一样，结果也不一样</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种与jdk版本无影响</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>); <span class="comment">//返回堆空间的1</span></span><br><span class="line">    s.intern(); </span><br><span class="line">    <span class="comment">/* 注意不是s = s.intern()，s.intern()只是在执行了</span></span><br><span class="line"><span class="comment">     * 下在常量池中查找1的操作，即使它找到了1，也没有返回，</span></span><br><span class="line"><span class="comment">     * 而s=s.intern()则把在字符串常量池中查找到的1的地址</span></span><br><span class="line"><span class="comment">     * 重新返回给了自己。调用之前字符串中有现成的1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String s2 = <span class="string">&quot;1&quot;</span>; <span class="comment">// 字面量方式，指向常量池中的1</span></span><br><span class="line">    System.out.println(s == s2);</span><br><span class="line">    <span class="comment">// jdk6及以前 false</span></span><br><span class="line">    <span class="comment">// jdk7及以后 false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种jdk版本有影响</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> String(<span class="string">&quot;1&quot;</span>); </span><br><span class="line">    <span class="comment">/* s3的地址为；new String(&quot;11&quot;)，但执行完后，</span></span><br><span class="line"><span class="comment">     * 字符串常量池中不存在11（与jdk版本无关）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    s3.intern(); </span><br><span class="line">    <span class="comment">/* jdk6中：在字符串常量池中创建了一个新的对象&quot;11&quot;，</span></span><br><span class="line"><span class="comment">     * 有新的地址。在jdk7及以后，由于常量池在堆中，</span></span><br><span class="line"><span class="comment">     * 而堆中已经有&quot;11&quot;了，常量池中直接存储堆中&quot;11&quot;的地址*/</span></span><br><span class="line">    String s4 = <span class="string">&quot;11&quot;</span>; </span><br><span class="line">    <span class="comment">//s4记录上一行代码执行时，常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">    System.out.println(<span class="string">&quot;s3 == s4&quot;</span>);</span><br><span class="line">    <span class="comment">// jdk6及以前 false</span></span><br><span class="line">    <span class="comment">// jdk7及以后 true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. new String(&quot;ab&quot;)会创建几个对象？</span></span><br><span class="line"><span class="comment">   2个</span></span><br><span class="line"><span class="comment">   在堆中放入java.lang.String;</span></span><br><span class="line"><span class="comment">   在字符串常量池放ab(字节码中可以看)。</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   new String(&quot;a&quot;) + new String(&quot;b&quot;)会创建介个对象？</span></span><br><span class="line"><span class="comment">   6个</span></span><br><span class="line"><span class="comment">   变量拼接，创建java.lang.StringBuilder；</span></span><br><span class="line"><span class="comment">   在堆中创建java.lang.String；</span></span><br><span class="line"><span class="comment">   在字符串常量池中创建a；</span></span><br><span class="line"><span class="comment">   在队中创建java.lang.String；</span></span><br><span class="line"><span class="comment">   在字符串常量池中创建b。</span></span><br><span class="line"><span class="comment">   StringBuilder中的toString()会在堆中生成ab，在字符串常量池中没有ab</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>String的垃圾回收：<code>-XX:+PrintStringTableStatistics</code></p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java和C++最大的区别就在于内存动态分配和垃圾收集技术。GC发生在方法区和<strong>堆空间</strong>。<br>关于垃圾收集有三个经典问题：<br>①哪些内存需要回收？<br>②什么时候回收？<br>③如何回收？</p>
<p><strong>什么是垃圾？</strong><br>垃圾是指运行程序中没有任何指针指向的对象。这个对象就是需要被回收的垃圾。<br>如果不及时对内存中的垃圾进行回收，那么这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致<strong>内存溢出（OutOfMemory）</strong>。<br>倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄露</strong>。</p>
<p><strong>为什么需要GC？</strong></p>
<p>如果不进行垃圾回收，内存迟早会被消耗完。<br>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。<br>没有GC就不能保证应用程序的正常进行。<br>Java的自动内存管理机制，无需开发人员手动参与内存的分配与回收，降低内存泄露和内存溢出的风险，更专注于业务开发，但也弱化了Java开发人员对出现内存溢出问题时的定位和解决能力。</p>
<h4 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h4><h5 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h5><p>调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>会显式触发<strong>Full GC</strong>，但<code>System.gc()</code>不确保垃圾回收能立即执行。</p>
<h5 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h5><p>$\bullet$ 内存溢出（OutOfMemory）：没有空闲内存，并且垃圾收集器也无法提供更多内存。<br /><br><strong>没有空闲内存：</strong> ①Java虚拟机的堆内存设置不够（可能存在内存泄露）；②创建了大量对象，并且长时间不能被垃圾收集器收集。<br><strong>GC后也无足够内存：</strong> ①JVM尝试回收软引用指向的对象；②对于超大对象JVM判断GC不能解决问题，于是不触发GC直接抛出OOM。</p>
<p>$\bullet$ 内存泄露（MemoryLeak）<br /><br>只有对象不会再被程序用到了，但GC又不能回收他们的情况，才叫内存泄露。<br>例子：①单例模式：单例（一个进程只有一个实例）的生命周期和应用程序一样长，如果单例程序持有对外部对象的应用的话，那么这个外部对象是不能回收的，导致内存泄露；②：数据库连接（<code>dataSource.getConnection()</code>），网络连接（<code>socket</code>）和IO连接必须手动close，否则是不能回收的。</p>
<h5 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop-The-World"></a>Stop-The-World</h5><p>指在GC事件发生时，用户线程会停顿，没有有任何响应，这个停顿称为STW。被STW中断的用户线程会在完成GC后恢复，频繁中断会造成用户体验不佳，要尽量减少STW。<br>STW是JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，STW不可避免，但优秀的GC会使用户几乎感觉不到STW。<br>开发中不要使用<code>System.gc()</code>，会导致STW。</p>
<h5 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h5><p><strong>并发（Concurrent）：</strong><br>①在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在$\color{red}一个处理器$上运行。<br>②并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间区间，然后在这几个时间区间中来回切换，由于CPU处理速度非常快，只要时间间隔处理得当，就可以让用户感觉是多个应用程序在同时进行。</p>
<div align="center"><img src="concurrent.png" width="80%"></div>

<p><strong>并行（Parallel）：</strong><br>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，称为并行。<br>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，一个CPU多个核也可以并行。</p>
<div align="center"><img src="parallel.png" width="87%"></div>

<p><strong>垃圾回收的并行：</strong> STW时，多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<br><strong>垃圾回收的串行：</strong> 相较于并行的概念，单线程执行；如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程。<br><strong>垃圾回收的并发：</strong> 用户线程和垃圾收集线程同时执行（不一定是并行，因为仍然存在STW），CMS、G1都是这样。</p>
<h5 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h5><p><strong>安全点（Safe Point）：</strong> 应用程序线程并不是在所有地方都能停下来开始GC，只有在特定位置才能停下来开始GC，这些位置称为安全点。安全点太少会使GC等待时间过长，安全点太多会使GC过于频繁。<br><strong>如何保证GC时，所有线程都在最近的安全点停下？</strong><br>①主动式中断：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己中断挂起。<br>②抢先式中断（目前没有虚拟机采用了）：中断所有线程，如果有线程不在安全点，就恢复线程使其到达最近安全点。<br><strong>安全区域（Safe Region）：</strong> 程序在执行时，走到安全点挂起，当程序本身就在Sleep或Blocked状态时，是不能向前走的，这时用安全区域的方法。安全区域指在一段代码中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。安全区域看做扩展长度的安全点。 </p>
<h5 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h5><p>JDK1.2之后对引用的概念进行了扩充，强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），引用强度依次减弱。<br><strong>强引用：</strong> 程序代码中普遍存在的引用赋值，任何情况下，只要强引用还在，GC就不会回收被引用的对象。<br><strong>软引用：</strong> 内存足够时，不会回收软引用的对象；系统发生内存溢出之前，才会回收软引用的对象，如果回收后仍没有足够空间，抛出OOM。<br><strong>弱引用：</strong> 只要发生GC，弱引用对象就会被回收。<br><strong>虚引用：</strong> 一个对象是否有虚引用的存在，完全不会对其生存周期构成影响。唯一目的是该对象被回收时收到一个系统通知。</p>
<h4 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h4><h5 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h5><p>在堆内存中区分出哪些是存活对象，哪些是死亡对象，当一个对象不被任何存活对象引用时，就宣判该对象已死亡。标记为死亡的对象才会释放其内存空间，这个过程称为<strong>垃圾标记阶段</strong>。判断对象存活有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</p>
<h6 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h6><p>对每个对象都保留一个整型的引用计数器属性，用于记录对象被引用的情况。</p>
<p><strong>算法思想：</strong><br>对于一个对象A，只要有任何一个对象引用了A，A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，表示A不再被使用，可进行回收。<br><strong>优点：</strong> 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。<br><strong>缺点：</strong> ①需要单独的字段存储计数器，增加了存储空间开销。②每次赋值需要更新计数器，伴随加减法操作，增加了时间开销。③无法处理循环引用问题，故在Java的垃圾回收器中没有使用这类算法。</p>
<h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p>也称为根搜索算法、追踪性垃圾收集。实现简单、执行高效，可以解决循环引用的问题，防止内村泄露，是Java垃圾回收器选择的垃圾标记算法。</p>
<p><strong>GC Roots</strong>根集合是一组必须活跃的引用，包括：<br>①虚拟机栈中引用的对象；②本地方法栈内JNI（本地方法）引用的对象；③方法区中类静态属性引用的对象；④方法区中常量引用的对象；⑤Java虚拟机内部的引用；⑥反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p><strong>算法思想：</strong><br>$\bullet$ 以GC Roots为起始点，从上至下搜索被根对象集合所连接的目标对象是否可达。<br /><br>$\bullet$ 内存中存活的对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）。<br /><br>$\bullet$ 如果目标对象没有任何引用链相连，则是不可达的，说明该对象已经死亡，标记为垃圾对象，其他对象则为存活对象。<br /></p>
<h5 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h5><p>在区分出内存中的存活对象和死亡对象之后，GC就要执行垃圾回收释放内存了。下面是常见的三种垃圾收集算法。。</p>
<h6 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h6><p>堆中的有效内存空间被耗尽时，执行Stop-The-World，然后进行两项工作：标记、清除。<br><strong>标记：</strong> 从引用根节点开始遍历，标记所有被引用的对象，记录在Header中。<br><strong>清除：</strong> 对堆内存从头到尾线性遍历，如果发现某个对象的Header没有标记为可达，则回收。这里的清除并不是真的置空，而是把需要清除的对象地址保存在空闲列表中，下次有新的对象需要加载时，判断列表的位置空间是否够，够就存放。</p>
<div align="center"><img src="mark-sweep.png" width="80%"></div>

<p><strong>优点；</strong> 基础且常见。<br><strong>缺点：</strong> ①效率不高（标记时要从根节点递归遍历所有可达对象，清除时要遍历整个内存空间）；②GC时需要STW；③清理出的内存空间不一定连续，有内存碎片。</p>
<h6 id="标记-复制算法（Mark-Copying）"><a href="#标记-复制算法（Mark-Copying）" class="headerlink" title="标记-复制算法（Mark-Copying）"></a>标记-复制算法（Mark-Copying）</h6><p>解决了标记-清除算法收集效率方面的缺陷。将活着的内存空间分为两块，每次只使用其中的一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>
<div align="center"><img src="mark-copying.png" width="80%"></div>

<p><strong>优点：</strong> ①没有标记和清除过程，实现简单，运行高效；②复制过去以后保证空间的连续性，不会出现内存碎片。<br><strong>缺点：</strong> ①需要两倍内存空间；②对于G1这种将内存拆分成大量region的GC，来回复制需要GC维护region之间的引用关系，开销也大。③复制的存活对象数量不能太大。</p>
<h6 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h6><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但在老年代，大部分对象都是存活对象。基于老年代垃圾回收的特性，需要使用其他算法。<br>$\bullet$ 第一阶段和标记-清除算法一样，从根节点开始标记所有被引用对象。<br /><br>$\bullet$ 第二阶段将所有的存活对象压缩到内存的一端，按顺序存放。之后清理边界外所有的空间。<br /></p>
<div align="center"><img src="mark-compact.png" width="80%"></div>

<p><strong>优点：</strong> ①消除了标记-清除算法中，内存区域分散的缺点，给新对象分配内存时，JVM只需持有一个内存的起始地址即可；②避免了复制算法中内存减半的代价。<br><strong>缺点：</strong> ①效率低于标记-复制算法；②移动对象的同时，如果对象被其他对象引用，需要调整引用地址；③移动时有STW。</p>
<h6 id="对比三种算法"><a href="#对比三种算法" class="headerlink" title="对比三种算法"></a>对比三种算法</h6><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>需要两倍内存大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<p>目前所有的GC都是采用分代收集（Generational Collecting）算法执行垃圾回收的，不用生命周期的对象可以采取不同的收集方式，以便提高回收效率。</p>
<p>$\bullet$ 年轻代（Young Gen）<br /><br>年轻代区域相对老年代较小，对象生命周期短、存活率低，回收频繁。<br>使用<em>标记-复制</em>算法，复制算法效率只与当前存活对象大小有关，很适用于年轻代的回收。复制算法内存利用率不高的问题，通过HosSpot中的两个survivor的设计得到缓解。</p>
<p>$\bullet$ 老年代（Old Gen）<br /><br>老年代区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。<br>由于存在大量存活率高的对象，复制算法不再适用，一般由<em>标记-清除和标记-整理算法混合实现</em> <strong>（CMS）</strong>。<br>CMS是基于标记-清除算法实现的，对对象的回收率很高，同时采用基于标记-整理算法的Serial Old回收器进行Full GC处理碎片问题。</p>
<h5 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h5><p>上述的算法在垃圾回收过程中会出现STW状态，增量收集算法让垃圾收集线程和应用程序线程交替执行。每次垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。<br>增量收集算法的基础是标记-清除和标记-复制算法，通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。<br><strong>缺点：</strong> 由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总成本上升，造成系统吞吐量下降。</p>
<h5 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h5><p>主要针对G1垃圾收集器，与增量收集算法一样，都是为了降低GC产生的停顿时间。堆空间很大时，GC需要的时间也长，通过将内存区域划分成多个region，每个region独立使用独立回收，每次合理地回收若干个region，而不是整个堆空间，从而减少一次GC所产生的的停顿。<br><strong>分代算法</strong> 按照对象的生命周期，将堆空间分为新生代和老年代两部分。<br><strong>分区算法</strong> 则将堆空间分成连续的region（有的region里放Eden区数据，有的region放survivor区数据，有的region放old gen数据，有的region放大对象(Humongous)）。</p>
<div align="center"><img src="region.png" width="80%"></div>


<h5 id="finalization机制"><a href="#finalization机制" class="headerlink" title="finalization机制"></a>finalization机制</h5><p>是对象被销毁之前的自定义处理逻辑，回收对象之前，先调用这个对象的finalize()方法，可以被重写，用于对象被回收时进行资源释放。<br>不要主动调用finalize()方法，应交给垃圾回收机制调用：①finalize()可能会导致对象复活；②finalize()方法的执行时间没有保证，完全由GC线程决定；③糟糕的finalize()会影响GC性能。</p>
<p><strong>对象的三种状态：</strong><br>$\bullet$ 可触及的：存在对这个对象的引用，即存活。<br /><br>$\bullet$ 可复活的：对这个对象的所有引用都被释放，但在finalize()中可能复活（又出现了新的引用）。<br /><br>$\bullet$ 不可触及的：finalize()调用后仍没有复活，该对象进入不可触及状态，一定要死亡，且finalize()只能调用一次。<br /></p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p>可以用过<code>-XX:+PrintCommandLineFlags</code>可以查看默认的垃圾回收器。或者通过命令行指令<code>jinfo -flag 相关垃圾回收器参数 进程ID</code>。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; jinfo -flag UseParallelGC <span class="number">924</span></span><br><span class="line">-XX:+UseParallelGC // +号表示正在使用           </span><br><span class="line">&gt; jinfo -flag UseParallelOldGC <span class="number">924</span></span><br><span class="line">-XX:+UseParallelGCOldGC</span><br><span class="line">&gt; jinfo -flag UseG1GC <span class="number">924</span></span><br><span class="line">-XX:-UseG1GC // -号表示没有使用</span><br></pre></td></tr></table></figure>
<p>$\bullet$ 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器。<br /></p>
<div align="center"><img src="serial-parallel.png" width="80%"></div>

<p>串行垃圾回收指同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾回收结束。串行回收默认被应用在客户端的Client模式下的JVM中。<br>并行垃圾回收可以运用多个CPU同时执行垃圾回收，提升了应用的吞吐量，但与串行回收一样有STW独占停顿时间。<br>$\bullet$ 按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。<br /><br>并发式垃圾回收器与应用程序线程交替工作，以减少应用程序停顿时间。<br>独占式垃圾回收器（Stop-The-World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收完全结束。<br>$\bullet$ 按照碎片处理方式，可以分为压缩式垃圾回收器和非压缩式垃圾回收器。<br /><br>$\bullet$ 按工作的内存空间分，分为年轻代垃圾回收器和老年代垃圾回收器。<br /></p>
<h5 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h5><p><strong>Serial回收器</strong>采用复制算法、串行回收和Stop-The-World机制。是HotSpot中Client模式下的默认新生代垃圾回收器。<br><strong>Serial Old回收器</strong>采用标记-压缩算法，串行回收和Stop-The-World机制。Client模式下默认的老年代垃圾回收器。在Server模式下，①与Parallel Scavenge配合使用；②作为老年代CMS回收器的后备垃圾收集方案。<br><strong>优点：</strong> 简单、高效（与其他单线程GC相比）。<br><strong>缺点：</strong> 只会使用一个CPU或一条收集线程去完成垃圾收集工作，并STW。<br><strong>总结：</strong> 对于交互性强的应用不可接受，已经不使用。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC // 新生代使用Serial GC，老年代使用Serial Old GC</span><br></pre></td></tr></table></figure>

<h5 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h5><p>ParNew回收器是Serial回收器的多线程版本,Par代表并行，New代表新生代。<br>ParNew回收器采用复制算法，并行回收和Stop-The-World，是很多JVM在Server模式下默认的新生代垃圾回收器。（由于和ParNew组合使用的CMS和Serial Old已经废弃了，ParNew基本也不使用了）<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParNewGC // 新生代使用ParNew GC</span><br></pre></td></tr></table></figure>
<h5 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h5><p><strong>Parallel Scavenge回收器</strong>采用复制算法，并行回收和Stop-The-World，在HotSpot中用于回收年轻代的垃圾。<br>与ParNew不同，Parallel Scavenge回收器目的是达到可控的吞吐量，并具有自适应调节策略。<strong>适用于</strong>后台运算、低交互的任务。<br><strong>Parallel Old回收器</strong>采用标记-压缩算法，并行回收和Stop-The-World，在JDK 1.6开始替代Serial Old成为老年代的默认回收器。<br>Parallel<br>Parallel Scavenge和Parallel Old的底层架构是自成一派的。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC // 新生代使用Parallel GC</span><br><span class="line">-XX:+UseParallelOldGC // 老年代使用Parallel Old GC</span><br><span class="line">// 这两个参数，开启其中一个，另一个也会被激活</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads //设置年轻代并行回收器的线程数，一般与CPU数相等，CPU数量小于8，设置为CPU数量；CPU数量大于8，设置为3+(5*CPU_count)/8</span><br><span class="line"></span><br><span class="line">-XX:MaxGCPauseMillis // 设置垃圾回收器最大停顿时间（STW时间，单位毫秒）</span><br><span class="line">-XX:GCTimeRatio // 垃圾收集时间占总时间的比例</span><br><span class="line">// 这两个参数之间的关系也是此消彼长的</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy </span><br><span class="line">/* 设置Parallel Scavenge回收器自适应调节策略</span><br><span class="line">在这种模式下，年轻代的大小、Eden和Survivor的比例、</span><br><span class="line">晋升老年代的对象年龄等参数会被自动调整，</span><br><span class="line">已达到在堆大小、吞吐量和停顿时间之间的平衡点*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h5><p>CMS（Concurrent Mark Sweep）回收器是HotSpot中第一款真正意义上的并发垃圾回收器（非独占式），第一次实现了让垃圾收集线程和用户线程同时工作。<br>CMS采用标记-清除算法，并发回收和Stop-The-World，是老年代垃圾回收器。CMS尽可能的缩短GC时用户线程停顿时间，这种低延迟的特性适合强交互的应用。</p>
<h6 id="CMS工作流程分为4个阶段"><a href="#CMS工作流程分为4个阶段" class="headerlink" title="CMS工作流程分为4个阶段"></a>CMS工作流程分为4个阶段</h6><div align="center"><img src="cms.png"></div>

<p><strong>初始标记阶段（Init-Mark）：</strong> 执行STW，所有工作线程由于STW而短暂暂停，该阶段仅标记出GC Roots能直接关联到的对象。<br><strong>并发标记阶段（Concurrent-Mark）：</strong> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时长但是不需要停顿用户线程，与垃圾收集线程一起并发运行。<br><strong>重新标记阶段（Remark）：</strong> 执行STW，由于在并发标记过程中，程序的工作线程会和垃圾收集线程同时运行或交叉运行，为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长，但比并发标记阶段时间段。<br><strong>并发清除阶段（Concurrent-Sweep）：</strong> 清理删除标记阶段判断的已经死亡的对象，释放内存空间，与用户线程并发。</p>
<p><strong>总结：</strong><br>①在并发标记阶段，用户线程还在继续执行，应确保用户线程有足够的内存可用，因此CMS不能像其他垃圾回收器一样等到老年代几乎被填满才进行回收，而是当堆内存使用率达到某一阈值时就开始进行回收，如果CMS运行期间预留的内存无法满足用户线程需要，会出现Concurrent Mode Failure，虚拟机临时启用Serial Old回收器作为后备方案，这时停顿时间会变长。<br>②由于CMS采用标记-清除算法，不可避免会产生内存碎片，需要使用空闲列表进行内存分配。之所以不采用标记-压缩算法是因为，在并发清除阶段，用户线程和垃圾回收线程是并发工作的，如果使用标记-压缩算法，会移动对象的位置，导致用户线程找不到对象。<br><strong>优点：</strong> 并发收集，低延迟。<br><strong>缺点：</strong> ①会产生内存碎片，可能导致提前触发Full GC；②对CPU资源敏感，CMS虽然不会停顿用户线程，但回收时会占用一部分CPU资源，导致用户线程变慢；③无法处理浮动垃圾。<br><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC // 手动指定使用CMS</span><br><span class="line">// 开启该参数后会自动将-XX:+UseParNewGC打开，即</span><br><span class="line">// ParNew(Young Gen) + CMS(Old Gen) + Serial Old 的组合</span><br><span class="line"></span><br><span class="line">-XX:CMSInitiatingOccupanyFraction </span><br><span class="line">// 设置堆内存使用率的阈值，一旦达到该阈值，就开始回收</span><br><span class="line">// JDK 6及以后默认92%</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h5><p>为了适应不断扩大的内存和不断增加的处理器数量，G1垃圾回收器在JDK 7引入、JDK 9中代替了CMS成为默认的垃圾回收器。G1的目标是：在延迟可控的情况下获得尽可能高的吞吐量。</p>
<p>G1是并行回收器，它把堆内存分为很多不相关的区域（Region，物理上不连续），用不同的Region表示Eden、S0、S1、老年代。G1有计划的避免在整个Java堆上进行全区域的垃圾回收，通过跟踪各个Region里面垃圾堆积的价值大小（回收获得的空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许收集的时间，优先回收价值最大的Region。由于该方法侧重于回收垃圾最大的Region，所以称为Garbage First，G1。</p>
<h6 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h6><p><strong>并行与并发：</strong><br>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW。<br>并发性：G1可以与应用程序交替执行，部分工作可以和应用程序同时执行。一般来说不会在整个回收阶段发生完全阻塞应用程序的情况。<br><strong>分代收集：</strong><br>G1是分代型垃圾回收器，它不要求整个Eden、年轻代、老年代都是连续的，也不坚持固定的大小和固定的数量，而是使用Region代替。G1还增加了一种新的内存区域，叫做Humongous，主要用于存储大对象，如果超过1.5个Region，就放到H，如果一个H区装不下一个大对象，G1就会寻找连续的H区来存储。G1基本把H区看做老年代的一部分。<br>Region中包含了逻辑上的年轻代和老年代。<br>与之前的各类回收器不同，它同时兼顾年轻代和老年代的垃圾收集！</p>
<div align="center"><img src="region.png" width="80%"></div>

<p><strong>空间整合：</strong><br>G1执行的内存回收以Region为单位，Region之间是复制算法，但整体上可看作标记-压缩算法，避免了内存碎片，有利于大对象的分配。<br><strong>可预测的停顿时间模型（Soft Real-Time）：</strong><br>G1除了追求低停顿外，还建立了可预测的停顿时间模型，可以明确指定在一个M毫秒的时间片段内，消耗在垃圾收集上的时间不多于N毫秒（尽可能的，所以是Soft）。优先回收价值最大的Region。</p>
<p><strong>缺点：</strong> G1为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。小内存上CMS表现大概率优于G1，大内存上G1有优势，平衡点在6-8GB之间。</p>
<p><strong>参数设置：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC // 手动指定使用G1回收器</span><br><span class="line">-XX:G1HeapRegionSize // 设置每个Region大小，值是2的幂，范围1MB-32MB，默认为堆空间的1/2000</span><br><span class="line">-XX:MaxGCPauseMillis // 设置期望达到的最大GC停顿时间指标，默认200ms，过小会导致Full GC</span><br><span class="line">-XX:ParallelGCThread // 设置STW工作线程数，最大为8</span><br><span class="line">-XX:ConcGCThreads // 设置并发标记的线程数，为并行垃圾回收线程数（ParallelGCThreads）的1/4做左右</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=percent // 设置触发并发GC周期的Java堆占用率阈值，默认45%</span><br></pre></td></tr></table></figure>
<h6 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h6><p>主要包括3个环节<br><strong>年轻代GC（Young GC）：</strong> 先STW，年轻代Eden区用尽时开始年轻代回收，从年轻代区间移动存活对象到S0、S1或老年代区间，也有可能是两个区间都涉及。<br><strong>老年代并发标记过程（Concurrent Marking）：</strong> 堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。<br><strong>混合回收（Mixed GC）：</strong> 标记完成后马上开始混合回收过程。G1 GC从老年代区间移动存活对象到空闲区间，这些空闲区间也称为老年代的一部分。G1的老年代回收不需要回收整个老年代，一次只需要扫描/回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起回收的。<br><strong>（特殊情况下，用于提供一种失败保护机制）Full GC</strong></p>
<div align="center"><img src="g1.png" width="80%"></div>

<h6 id="G1的Remembered-Set（R-Set）"><a href="#G1的Remembered-Set（R-Set）" class="headerlink" title="G1的Remembered Set（R Set）"></a>G1的Remembered Set（R Set）</h6><p>一个Region中的对象可能被其他Region的对象所引用，这是否意味着判断对象存活时，需要扫描整个堆？<br>无论是G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描。每个Region都有一个对应的Remembered Set。R Set中记录指向该Region中对象的所有引用。<br>每次Reference类型数据写操作时，都会产生一个Write Barrier（写屏障）暂时中断操作，检查要写入的Reference指向的对象与Reference是否在一个Region中，如果不同，通过CardTable把相关引用信息记录到Reference指向的对象所在Region对应的R Set中。<br>当进行垃圾收集时，在GC根节点的枚举范围内加入R Set，就可以保证不进行全局扫描也不会有遗漏。</p>
<div align="center"><img src="rset.png" width="80%"></div>

<p>JDK11中引入Epsilon垃圾回收器和ZGC（可伸缩的低延迟垃圾回收器）</p>
<h5 id="不同GC之间的组合关系"><a href="#不同GC之间的组合关系" class="headerlink" title="不同GC之间的组合关系"></a>不同GC之间的组合关系</h5><p>一共有7款<strong>经典</strong>的垃圾回收器（Garbage Collector）：</p>
<table>
<thead>
<tr>
<th></th>
<th>按工作方式分</th>
</tr>
</thead>
<tbody><tr>
<td>串行回收器</td>
<td>Serial、Serial Old</td>
</tr>
<tr>
<td>并行回收器</td>
<td>ParNew、Parallel Scavenge、Parallel Old</td>
</tr>
<tr>
<td>并发回收器</td>
<td>CMS、G1</td>
</tr>
</tbody></table>
<div align="center"><img src="gczuhe.png" width="80%"></div>


<table>
<thead>
<tr>
<th></th>
<th>按工作的内存空间分</th>
</tr>
</thead>
<tbody><tr>
<td>新生代回收器</td>
<td>Serial、ParNew、Parallel Scavenge</td>
</tr>
<tr>
<td>老年代回收器</td>
<td>Serial Old、Parallel Old、CMS</td>
</tr>
<tr>
<td>整堆回收器（新生代、老年代都能回收）</td>
<td>G1</td>
</tr>
</tbody></table>
<div align="center"><img src="gczuhe2.png" width="80%"></div>

<p><strong>——黑色实线</strong> 表示两个回收器可以搭配使用<br /><br>$\color{red}- -红色虚线$ 表示JDK 8时将Serial+CMS、ParNew+Serial Old声明废弃，并在JDK 9中完全取消。<br /><br>$\color{green}- -绿色虚线$ 表示在JDK 14中弃用Parallel Scavenge+SerialOld。<br /><br>$\color{blue}- -青色虚线$ 表示在JDK 14中删除CMS。<br /><br>CMS与Parallel Scavenge不兼容，CMS与Serial Old作为储备方案。不同的GC适用不同的场景，要妥善选择。</p>
<h5 id="GC的主要性能指标"><a href="#GC的主要性能指标" class="headerlink" title="GC的主要性能指标"></a>GC的主要性能指标</h5><p><strong>吞吐量（Throughput）：</strong> 运行用户代码的时间占总运行时间的比例。</p>
<p>$吞吐量={运行用户代码时间 \over 运行用户代码时间+垃圾收集时间}$</p>
<p>吞吐量优先，意味着在单位时间内，STW时间最短。<br><strong>暂停时间（Pause Time）：</strong> 执行垃圾收集时，程序的工作线程被暂停的时间。<br>暂停时间短一般回收频率高，延迟低。暂停时间和吞吐量之间的关系是此消彼长的，二者的折衷方案是，<strong>最大吞吐量优先的情况下，降低停顿时间</strong>。<br><strong>内存占用：</strong> Java堆区所占的内存大小。</p>
<h5 id="七种常见GC比较"><a href="#七种常见GC比较" class="headerlink" title="七种常见GC比较"></a>七种常见GC比较</h5><div align="center"><img src="7gc.png" width="100%"></div>

<h5 id="后起之秀"><a href="#后起之秀" class="headerlink" title="后起之秀"></a>后起之秀</h5><h6 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h6><p>Epsilon只做内存分配，不做垃圾回收。</p>
<h6 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h6><p>在OpenJDK 12引入，特点是低停顿时间，但吞吐量下降。由RedHat公司提出。</p>
<h6 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h6><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">官方文档</a><br>在JDK 11引入，特点也是低停顿时间，仍处于Experimental阶段。<br>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现任意堆内存大小都可以把垃圾收集的停顿时间限制在10ms以内的低延迟。<br>ZGC是一款基于Region内存布局的，不设分代的（暂时），使用了读屏障、染色指针、内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。<br>ZGC的工作过程可以分为4个阶段：并发标记$\rightarrow$并发预备重分配$\rightarrow$并发重分配$\rightarrow$并发重映射。<br>ZGC几乎在所有地方都是并发执行的，除了初始标记是STW，所以停顿时间几乎就耗费在了初始标记上，这部分的实际时间是非常少的。</p>
<h5 id="GC日志打印"><a href="#GC日志打印" class="headerlink" title="GC日志打印"></a>GC日志打印</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log // 根目录是project</span><br></pre></td></tr></table></figure>
<p>常见的日志分析工具：GCViewer、<strong>GCEasy</strong></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" rel="tag"># 垃圾回收</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># 内存分配</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag"># 内存管理</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/11/%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B%E6%A0%91%E8%8E%93%E6%B4%BE/" rel="prev" title="简单上手树莓派">
                  <i class="fa fa-chevron-left"></i> 简单上手树莓派
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/11/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/" rel="next" title="JVM学习笔记2-字节码与类的加载">
                  JVM学习笔记2-字节码与类的加载 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Etin Ban</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>




  





</body>
</html>
